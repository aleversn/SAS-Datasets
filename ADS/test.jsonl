{"score": "10", "answer": "错误。不一定。入栈元素可以入栈即出，不一定等到全部元素都入栈再出\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2，（2n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "1.当冒泡排序后序列为从大到小排序，而输入序列为从小到大时。如原本为1 2 3 4 5 而要获得5 4 3 2 1。\n2.快速排序没有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "6", "answer": "ai=3，理由：队列元素的进出规则为先进先出，而栈元素的进出规则的先进后出，故出队顺序与入队顺序相同，而由出栈时第一个元素为3n可知是所有元素全部进栈后开始出栈，则最后一个出栈的元素为第一个进队元素3.\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "\n\n如果这n个元素是一次性进栈的话，该叙述正确，它们的出栈顺序和进栈顺序一定正好相反。\n1，2，3一次性进栈，其出栈顺序一定是3，2，1.\n\n\n如果这n个元素不是一次性进栈，而是一边进栈一边出栈的话，该叙述错误。\n1，2，3的出栈顺序完全可以是1，2，3（每个元素进栈后立即出栈）。\n\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点：每个栈仅用一个顺序存储空间时，操作简单。缺点：无法根据需要灵活调配空间，易发生溢出或浪费太多空间\n(2)优点：多个栈仅用一个顺序存储空间，充分利用了存储空间，从而节省了空间的占用，只有在整个存储空间都用完时才会产生溢出。缺点：栈满时，要检查是否有空闲空间，若有，要进行元素的移动，还需检查栈是否满的情况\n(3)优点：使用链栈一般时一般不会考虑溢出现象，可以灵活调配栈的容量。缺点：链栈实现要用到指针连接，比顺序栈多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "等概率(后插)时插入位置0..n则平均移动元素个数为n／2。若不等概率则平均移动的元素个数为。\n等概率(后插)时,插入位置0..n,则平均移动元素个数为n／2。若不等概率,则平均移动的元素个数为。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "h(n)=C(2n,n)/(n+1) (n=1,2,3,...)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "(1) 分别用多个顺序存储空间建立多个独立的顺序栈。\n\n\n\n\n优点\n\n\n\n\n\n结构简单, 方便管理以及维护.\n\n\n\n\n\n缺点\n\n\n\n\n\n空间大小固定.\n\n\n非动态调整存储空间, 空间利用率不高.\n\n\n\n\n\n(2) 多个栈共享一个顺序存储空间。\n\n\n\n\n优点\n\n\n\n\n\n空间利用率高.\n\n\n\n\n\n缺点\n\n\n\n\n\n维护复杂, 访存栈时有额外的性能开销.\n\n\n空间大小仍相对受限, 不易调整.\n\n\n\n\n\n(3) 分别建立多个独立的链栈。\n\n\n\n\n优点\n\n\n\n\n\n可动态调整栈的大小.\n\n\n\n\n\n缺点\n\n\n\n\n\n维护较为复杂.\n\n\n占用了更多的存储空间, 在存储元素值之外还需存储指针域.\n\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "0", "answer": "\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比较n次时，其中一个有序表的所有元素都比另一个有序表的所有元素小\n比较2n-1次时，两个有序表的所有元素大小交错，如1,3,5和2,4,6\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "不涉及插入和删除操作的时候\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "描述1：\n利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入栈操作。\n当需要出队时，则对S2执行出栈操作。\n由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而执行操作前必须判断S2是否为空，否则会导致顺序混乱。\n当栈S1和S2都为空时，队列为空。\n入队2：\n\n\n\n\n\n两个栈S1，S2都为空，执行入队操作，将元素直接插入S1中。\n\n\n栈S1为满，栈S2不为空，则队列为满，无法执行入队操作\n\n\n栈S1为满，栈S2为空，执行入队操作，先将栈S1中的元素逐一出栈，再逐一入栈S2；\n当S1为空时，将元素插入S1中，实现入队操作。\n出队3：\n\n\n栈S2不为空，则队首元素位于S2的栈顶（栈S1为满，S2不为空），执行出队操作，将S2中的栈顶元素出栈，实现出队操作。\n\n\n栈S2为空，栈S1为空，则队列为空，无法实现出队操作。\n\n\n栈S1不空，栈S2为空，执行出队操作时，先将S1中元素逐一从S1出栈，再逐一入栈S2，最后将S2中的栈顶元素出栈，实现出队操作。\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n\n\n\n\n栈底元素同时有可能是栈顶元素，此时可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "1.入队：s1未满时所有元素顺序入栈s1，s1中元素逆序出栈s1栈满而s2为空时，s1中元素逆序出栈入栈s2。\n2.出队：优先出栈s2中s1溢出元素，而后所有s1中元素逆序出栈，入栈s2，再逆序出栈，此时s2中元素出栈顺序与s1中元素入栈顺序相同。\n3.判空：s1不为空且s2不为空时，队列不为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表的优点是可以随机访问数据元素\n缺点是大小固定，不利于增删结点。\n链表的优点是采用指针方式增减结点，非常方便（只需要改变指针指向，不移动结点）。\n缺点是不能进行随机访问，另外，每个结点上增加指针域，造成额外存储空间增大。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "共2^(n-1)个。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "储存规模可以估计，很少进行插入删除操作或插入删除操作只在尾部进行的时候。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "当栈顶元素等于栈底元素时可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "插入一个元素需要平均移动的元素个数是 n/2\n\n\n\n\n插入一个元素需要平均移动的元素个数 （2*n + 1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "这个叙述是错误的，解释：当n个元素进栈后，不能得知n个元素是否是连续进栈，因此不能判断它们出栈顺序和进栈顺序一定是相反的。例如入栈顺序abcd，出栈顺序可以是adcb。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "顺序表：存储空间静态分配，将数据元素放到一块连续的空间，一旦确定就无法改变；插入删除数据元素较慢。\n链表：采用指针方式增减节点，动态分配空间，插入删除速度快。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "0", "answer": "1个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai = 3n -3i + 3\n因为队列先进先出,进队出队不改变序列顺序,在入栈前依旧保持原顺序;\n因为a1 = 3n ,所以在3n入栈前其他元素无法出栈,直到3n出栈入栈,而3n恰好为最后一个元素,所以该序列按原有顺序出栈入栈\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "需要随机访问（按脚标访问）数据；已知最大表长；需要对线性表进行随机存取时；不需要大量插入、删除元素；需要随机访问表中的元素的时候。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*（n-i+1）;\n由于出栈时先出栈3n，说明在按照3,6,9,12,……3n顺序入栈时，只有当最后一个3n入栈后才开始出栈操作，所以出栈顺序应该为入栈顺序的逆序。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "这种叙述是错误的。\n\n\n\n\n因为当栈只有一个元素时，即栈顶和栈底元素相同，是可以删除的。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "9", "answer": "2^n-1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.优点：每个栈仅用一个顺序存储空间时，操作简单。\n缺点：分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n2.优点：充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。\n缺点：当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n3.优点：不考虑栈的溢出。\n缺点：多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以，需要知道前一个结点才可以删除。\n双链表可以，根据p来找到对应的前驱结点和后继结点，时间复杂度为O（1）\n循环单链表也可以，一直循环遍历下去，可以遍历到p的前一个结点，然后删除*p,时间复杂度为O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "4", "answer": "1.方便在第1个位置进行插入、删除操作时同其他位置一样\n2.出现多个链表时，可以运用结构体分开赋值头节点\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "（1）入队：栈S1存放进原本要进队列的元素，把S1中的元素全部出栈，出栈后立即进栈至栈S2\n（2）出队：把S2的元素全部出栈，该元素出栈的顺序和出队的顺序一致，若还有元素要入栈到S2，则需等待栈S2全都出栈后才能再入栈\n（3）判断队列是否为空：若栈S2和S1都为空，则代表元素已全部出栈，则队列为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2 (2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表：\n逻辑相邻，物理相邻\n无须为表示元素间的逻辑关系而增加额外的存储空间\n存储空间使用紧凑\n可随机存取任一元素\n插入、删除操作需要移动大量的元素\n预先分配空间需按最大空间分配，利用不充分\n表容量难以扩充\n链表：\n避免了数组要求连续的单元存储元素的缺点\n在执行插入或删除运算时，不再需要移动元素——当元素的粒\n度很大时，移动元素是很费时的。\n需要在每个单元中设置指针来表示表中元素之间的逻辑关系，因\n而增加了额外的存储空间，为获得上述优点付出代价。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "顺序表存储数据实行的是 一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "1.要实现删除* p 结点的操作,要找到其前驱结点,修改其指针域的值使其指向 *p 的后继结点,以实现删除结点 p 。单链表不可以,因为不知道头指针故找不到 p 的前驱结点。双链表和循环单链表可以实现删除 *p 结点。\n2.循环单链表删除 *p 结点的时间复杂度为 O(n) ,双链表删除 *P 结点的时间复杂度为 O(1) 。.\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1、需要随机访问（按照数组下标或序号访问）数据时。\n2、能事先确定表中最大元素个数（即最大表长时）。\n3、不需要频繁地插入、删除元素时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1、使链表操作统一，方便单链表操作，降低程序复杂度\n2、防止单链表为空\n3、插入和删除数据元素的算法统一了，不再需要判断是否在第一个元素之前插入或删除第一个元素\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确的。\n\n\n\n\nn个元素按顺序入栈，因为只能从栈顶出栈，所以第一个出栈的元素是第n个入栈的元素，以此类推，它们的出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "①.在等概率的前提下，插入一个元素\n需要平均移动的元素个数是n/2。\n\n\n\n\n②.若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数是(2n+1)/3。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一，顺序栈的意思是：利用 顺序存储结构 实现的栈，其意味的是采用地址连续的存储空间（数组或者STL）依次存储栈中元素\n和栈中元素大小是否有序没有任何关联。\n第二，随便举个反例:进站1，2，3，4\n操作顺序PPOPOOPO，得到的出栈顺序是2,3,1,4，大小无序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1.当出现多个链表的时候，可以运用结构体分开赋值头节点\n2.方便在头结点前插入或删除节点\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。有可能进栈后马上出栈，这样出栈顺序和进栈顺序一致。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "1、可以同意在头部和链表中间插入和删除结点的操作，不需要在插入操作的时候特判\n2、加上头结点后可以统一空表和风控表的处理，方便操作\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作。\n2.防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、单链表：由于不知道头指针，故无法找到p的前驱，所以无法删除p。\n2、双链表：可以通过p直接找到其前驱和后继，所以可以删除。时间复杂度为O（1）。\n3、循环链表：可以直接找到p后继并通过查找找到p的前驱，所以可以删除p。时间复杂度为O（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "\n\n例如3、2、1，在第一趟排序后2移至首位，向相反方向移动。\n\n\n没有\n\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "元素之间顺序关系弱，增删操作少的时候，或增删在表尾时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "(1) 每个栈相互独立地工作，且各个栈的容量完全为自己所用，不受其他栈的影响。顺序存储优点是读取快速且占用内存小存储密度大。缺点是当数据量较小时容易造成空间浪费，数据量较大时容易造成空间不足。\n(2) 当某个栈较空闲时剩余的空间可以为其他栈所用，节省了空间。且读取快速且占用内存小存储密度大。缺点是当多个栈的数据量都较大时更容易溢出，需要对整个栈移动扩充。\n(3) 空间可变不受限。缺点是空间利用率低。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "a\ni\n\t​\n\n=3(n−i+1) (1≤i≤n)\n\n\n\n\n求解原因:\n\n\n\n\n由队列的先进先出结构特性, 经过一个队列后, 出队顺序与入队顺序相同. 即出队顺序为 3, 6, 9, 12, ..., 3n.\n\n\n\n\n又由栈先进后出的顺序, 栈将以出队顺序入栈, 在元素全部入栈之后栈将会是: [栈顶] 3n, ..., 12, 9, 6, 3 ||[栈底].\n\n\n\n\n因此出栈时的输出序列将会是从栈顶到栈底, 即 3n, ..., 12, 9, 6, 3. 易得 a\ni\n\t​\n\n=3(n−i+1) (1≤i≤n)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n顺序栈是用顺序存储结构实现的栈，元素不一定有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n\n\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "7", "answer": "采用链式存储结构。因为链式存储结构在插入和删除数据元素时不需要移动数据元素,只需要修改结点的指针域就可以改变数据元素之间的逻辑关系。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "队列的特点是先进入队列的元素先先出去，而栈的特点是先进入栈的元素后退出，后进入栈的元素先退出，所以有：\n队列：3、6、9、12...3n\n栈：3n...12、9、6、3\n所以a1=3n。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：每个栈仅用一个顺序储存空间时，操作简单。缺点：容易造成空间溢出或浪费。\n（2）优点：充分利用存储空间。缺点：查询左右空闲单位时比较复杂耗时。\n（3）优点：不用考虑溢出问题。缺点：比顺序存储多占用空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n队列先进先出，栈后进先出\n\n\n出队顺序为3、6、9、...3n\n\n\n入栈顺序为3、6、9、...3n\n\n\n因为栈后进先出，所以出栈顺序为3n、3(n-1)、...3\n\n\nai = 3(n - i + 1)\n\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：只能知道该结点的后继，由于不知道头指针，无法得知前驱，故无法删去该结点。\n双链表：可以通过该结点得知其前驱和后继，所以可以删去，其时间复杂度为O(1).\n循环单链表：可以直接知道该结点的后继，通过不断查找也可以知道其前驱，所以也可以删去，其时间复杂度为O(n).\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "使用链表。\n因为链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 O(n);\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "随机访问表中的元素，并且插入，删除操作少的时候使用顺序表更好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "例子： 1 ，7，6，5，3\n在快速排序过程中没有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "错误\nn个元素进栈的过程中，可以随时进行出栈操作\n如1，2，3三个元素进栈：\n执行两次进栈（1，2先进栈），执行一次出栈（2出栈），执行一次进栈（3进栈），再执行两次出栈（3，1出栈）\n最后出栈顺序为2，3，1和进栈顺序不一定正好相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "顺序表：查询快，大小固定不利于增删结点\n\n\n\n\n链表：查询慢，增删结点快，需要额外存储空间\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "最多的比较次数是当两个有序表的数据刚好是插空顺序的时候，比如：第一个序列是1,3,5，第二个序列是2,4,6，把第二个序列插入到第一个序列中，先把第二个序列中的第一个元素2和第一个序列依次比较，需要比较2次（和1，3比较），第二个元素4需要比较2次（和3,5比较，因为4比2大，2之前的元素都不用比较了），第三个元素6需要比较1次（只和5比较），所以最多需要比较5次。即2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "错误。栈每次只能把元素插入到第一个位置（栈顶），每次只能读取栈顶的元素，栈只能访问栈顶元素，即“后进先出”。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "除根节点外每个节点都有两种状态可以选择（左偏 或者 右偏）\n所以剩下n-1个节点都有两种选择，故为2^（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "只需要通过下标访问元素，不需要插入或者删除元素时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表不可以，双链表和循环单链表可以，时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "用序列{5，4，3，2，1}说明\n第一次冒泡后，序列变成{4，3，2，1，5}序列{4，3}都往相反的位置移动\n快速排序也会\n对序列[5，1，3，2，4]以5 划分时，序列变成{4，3，2，1，5}，4往前面移动\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "不一定是有序的。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的 若用data [1…m]表示顺序栈的存储空间，则对栈的进栈、出栈操作最多只能进行m次。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n快速排序中也有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "错误。当栈底元素上面没有元素时可以被删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "需要访问读取大量元素，而几乎不需要增添，删除元素的情况下使用顺序表比链表好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1) 对带头结点的链表,在表的任何结点之前插入结点或删除表中任何结点,所要做的都是修改前一结点的指针域,因为任何元素结点都有前驱结点。若链表没有头结点,则首元素结点没有前驱结点,在其前插入结点或删除该结点时操作会复杂些。\n(2) 对带头结点的链表,表头指针是指向头结点的非空指针,因此空表与非空表的处理是一样的。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。栈的结构就是后进先出，每次都是pop栈顶元素，所以不能删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "0", "answer": "1个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1.方便在头节点前插入或删除节点。\n2.出现多个链表时，可以运用结构体分开赋值头节点。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。\n假如n = 4，元素分别为1，2，3，4：可以是1、2先进栈，然后2就立即出栈，3、4再进栈，最后再依次出栈。\n那么出栈顺序就为2，4，3，1（进栈顺序为1234）。出栈顺序和进栈顺序不相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。\n栈底元素是可以删除的元素，最先进入栈的元素被压入栈底，前面的元素不断出栈轮到栈底元素可以出栈即可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "9", "answer": "\n\n入队\n * 将元素elem压入栈S1中(S1.push(elem))\n\n\n\n\n\n出队\n * 若S2不为空, 将栈顶元素出栈(S2.pop())\n * 若S2为空, 将S1的所有元素逐个出栈, 并压入栈S2中\n\n\n\n\n\n判断队列为空\n * 队列为空当且仅当 S1, S2均为空\n\n\n\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。\n栈的特点是先入栈的后出栈，后入栈的先出栈，所以出栈顺序和进栈顺序相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "假设排序情况为升序\n最少情况：表1的第一个元素大于表2的任一元素\n最多情况：表1的第一个元素大于表2的第一个元素，表2的第二个元素大于表1的第一个元素，表1的第二个元素大于表2的第二个元素......以此类推\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "插入、删除相对较少时，或插入、删除在尾部进行时，适合采用顺序表。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）n/2\n（2）（2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1),因为a1=3n，即3n是最先出栈的，所以3n一定是最后一个入栈，则出栈顺序是3n，\n3n-3，3n-6，3n-9......3（n-i+1).\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.对于单链表来说，由于不知道头指针，无法找到结点p之前的那个结点。所以单链表无法将结点p从相应的链表中删去。\n2.对于双链表和循环链表，则可以将结点*p从相应的链表中删去，其时间复杂度均为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "正确。栈底是固定的，不允许进行插入和删除的另一端。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误。\n顺序栈的“顺序”意指“利用顺序存储结构实现”，而非“栈中元素值的大小有序”。\n顺序栈中的元素值大小完全可以是无序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "其中一个表的元素全都小于另外一个表的任意一个元素\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "假设n个元素入栈后（前提），那么他们出栈的顺序必定与入栈顺序相反。不管n个元素入完栈之后是否有其他元素入出栈，你跟踪这n个元素，总会发现是与入栈顺序相反的顺序。\n所以没有错。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。先进后出，栈顶元素先出栈。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一问：n/2\n第二问：(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误的; 这里顺序的意思是顺序存储结构，而不代表存储元素一定有序。有序的栈结构一般称为单调栈\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1.入队操作：将输入的元素放入S1中，如果是进行过出队操作后的入队，先将S2的元素出栈入栈到S1中\n2.出队操作：将S1的元素出栈入栈到S2中，形成倒序，再将S2出栈\n3.判断队列是否为空：即判断S1,S2是否同时为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "7", "answer": "当线性表插入和删除结点操作较少或插入和删除操作总在尾部进行时，使用顺序表比链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n(1)的优点在于操作简单；缺点在于每个栈的分配空间不好确定，\n分配空间过小时容易溢出，分配空间过大时容易造成空间的浪费。\n\n\n(2)的优点在于多个栈共享一个顺序存储空间充分利用了存储空间，\n只有所有存储空间都用完了才会溢出；缺点在于操作不够简单，当接近栈满时，\n要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程很耗时。\n\n\n(3)的优点在于基本不用考虑栈的溢出；缺点在于栈中元素要以指针相链接，\n比顺序存储多占用了存储空间。\n\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以删去，无法知道它的前驱是谁；双链表和循环单链表可以，其时间复杂度分别为O（1）、O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "1)\n优点：每个栈仅用一个顺序存储空间时，操作简单。\n缺点：可能因空间分配不合理及各栈不能共享空间，造成空间浪费。\n\n\n\n\n(2)\n优点：充分利用了存储空间。\n缺点：是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n\n\n(3)\n优点：是多个链栈可不考虑栈的溢出（理论上）。\n缺点：是栈中元素以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "应该使用链式存储结构，因为采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。但移动指针域操作比移动元素操作花费的时间少得多。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "进队序列为3、6、9、12、...3n，经过一个队列后，即进队3、6、9、12、...3n，则出队序列为3、6、9、12、...3n，然后出队序列依次进栈，则出栈序列为3n、3(n-1)、3(n-2)、...3，\n\n\n\n\n所以a1=3n时，ai=(3n+1)-n=2n+1。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "用s1和s2两个栈，将s1作为输入栈，将s2作为输出栈，即可模拟队列。\n入队：入队时，将元素压入栈s1，此时元素顺序为逆序。\n出队：出队时，先将s1的元素按顺序压入栈s2，再将s2中的元素按顺序从栈顶弹出。即可视作元素中先入队的先出队。\n判空：当s1和s2两栈都为空时，则判定该队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。不一定是有序的。顺序栈是指利用顺序存储结构实现的栈。采用地址连续的存储空间(数组)依次存储栈中数据元素。元素地址是连续的，元素值不一定\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.为了方便单链表的特殊操作,插入在表头或者删除第一个结点.\n2.减少了程序的复杂性，更有逻辑性。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、如序列4、3、2、1第一次排序的结果是3、2、1、4。其中3朝着最终排序相反的方向移动。\n\n\n\n\n2、快速排序没有这种现象，因为在快速排序中比基准数小的元素就将放在基准数的左侧，比基准数大的元素就将放在右侧，不会出现小的元素往后移动的情况，也不会出现大元素往前移动的情况。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误,是顺序储存结构,里面元素不一定有序\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "链表，利用制作进行插入和删除比较方便。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表存储密度高,用物理上的邻接关系来表示逻辑结构，每个结点只存储数据元素,顺序表是一种随机存取的存储结构。\n链表存储用指针表示逻辑结构，并且可以不用事先估计存储规模，可以动态的对存储空间进行扩充，存储密度较低，是一种非随机存储结构。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "3", "answer": "队列按序列全部入队后，全部再按照队列出队入栈后，第一个出栈的为3n\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "除根节点外每个节点都有两种状态可以选择（因为高度为n，所以只有左偏右偏两种）因此剩下n-1个节点都有两种选择，故为2^（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "1）由于队列是先进先出的，所以进队顺序和出栈顺序相同。这样，进栈的顺序为：6，9，12......3n。而栈是后进先出的，当a1=3n时，说明最后进栈的元素最先出栈，这样，就只有一种出栈序列：3n,3n-3,......9,6,3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最小次数时：其中一个表所有元素都小于另一个表，则只需要该表的第一个元素与另一个表的所有元素比较一遍，即比较n次后，直接拼接即可。\n最多次数时：两个表的元素互相交错，此时需要重新排序，则除了第一个表最后一个元素外，每个元素都要与第二个表中的元素比较2次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "2n-1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表将无法删除，因为无法找到*p之前的那个节点，而双链表和单循环链表则可以，时间复杂度为n.\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "1.对带头结点的链表,在表的任何结点之前插入结点或删除表中任何结点,所要做的都是修改前一结点的指针域,因为任何元素结点都有前驱结点，若链表没有头结点,则这些操作会麻烦些。\n2.对带头结点的链表,表头指针是指向头结点的非空指针,因此空表与非空表的处理是一样的。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "当后一个有序表的所有元素的排序码值都比前一个有序表的大时，或者后一个有序表所有元素的排序码值都比前一个有序表的小时，如{1，2，3，4}和{5，6，7，8}，只需要n次比较就能完成排序；\n而当两个有序表的所有元素的排序码值交错排列时，如{2，5，9，11}与{4，7，10，12}，就需要2n-1次比较\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "当不涉及或涉及少量删除和插入操作的时候，因为顺序表插入、删除操作需要移动大量的元素。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "2^n-2\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，顺序指的是顺序存储结构，而不代表存储元素一定有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。当栈中只有一个元素时，这个元素也称作栈底元素，但是它是可以删除的。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "1.顺序表存储方式特点：存取速度高，通过下标来直接存储；内存空间连续；\n2.链表存储方式的特点：内存空间不连续；没有空间限制，可以存储很多元素。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "错误；\n当栈只剩下一个元素时，即为栈底元素，可被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误的\n：因为栈只能在栈顶插入和删除，当我们在栈顶连续运行插入时，栈底元素就会是我们刚刚第一个插入的元素（最早被插入的元素）；当我们在栈顶连续不断运行删除时，栈底元素就会是我们最后删除的元素（最后被删除的元素）\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "7", "answer": "ai=3*(n+1-i);\n入队列为后进先出，每次都为队列的第一个先出；\n栈则与之想反，后进先出；\n则栈的出栈顺序应与入栈顺序想反；\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一点，方便单链表的特殊操作。能有效减少代码量，在表头插入或删除第一个结点时不用考虑特殊情况，其操作完全和中间的结点一样；\n第二点，单链表设置头结点后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了，方便了对单链表的操作，减少了程序的复杂性；\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n2.优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n\n\n3.优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "6", "answer": "当线性表很少进行插入，删除等操作时用顺序表较好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序亦为3、6、9、12、...、3n。而栈是后进先出的，当a1=3n时，说明最后进栈的元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "比较侧重于查询数据元素的操作，而插入删除数据元素的操作较少。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*(n+1-i）原因：队列是先进先出，栈是先进后出，所以输出序列与进队数列相反了。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、顺序表存储\n原理：将表中元素一个个存入一组连续的存储单元中，这种存储结构是顺序结构。\n优点：存取速度高效，通过下标来直接存储，存储空间是连续的，通常用数组实现。因此，可以通过索引查找，优点是查找修改速度比较快，\n缺点：1.增加和删除要移动数据，操作比较麻烦，速度也较慢。；2.不可以增长长度\n2、链式表存储\n原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题\n优点：插入和删除速度快，保留原有的物理顺序\n缺点：存储空间是不连续的，每个元素通过指针连接起来的，正好不顺序表相反，查找比较耗时\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "4", "answer": "单链表不可以\n双链表时间复杂度为\n循环单链表时间复杂度为\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "4", "answer": "如果是单链表，那么你必须知道一个在p前面的结点。\n如果是双链表和循环单链表则只要知道任意一个结点就可以了。\n时间复杂度全是O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "(1)优点：每个栈仅用一个顺序存储空间时，操作简单。\n缺点：分配空间较小时，容易产生溢出；分配空间较大时，容易造成浪费；各栈不能共享空间。\n(2)优点：多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。\n缺点：当一个栈满时，要向左、右查询有无空闲单元；如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点：多个链栈一般不考虑栈的溢出。\n缺点：栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙。存储数据实行的是 \"一次开辟，永久使用\"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。\n\n\n\n\n链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持。链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "顺序栈是指利用顺序存储结构实现的栈。采用地址连续的存储空间（数组)依次存储栈中数据元素，由于入栈和出栈运算都是在栈顶进行\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "Σ(n-i+1)=n/2\nΣ(n-i)(n-i)/(n(n+1)/2) = (2*n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误,可以删除当栈只有一个元素时\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误。假设栈足够大，1~n按顺序入栈，可以执行入栈后立即出栈的操作，此时出入栈的顺序相同。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n\n待排序序列后面的若干排序码比前面的排序码小，则在冒泡排序过程中元素可能与最终它应移向的位置相反的方向移动。\n\n\n\n\n\n\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3在第一趟移向了与最终位置相反的方向\n\n\n\n\n\n\n快速排序没有这种现象， 因为每一次都进行了分组， 不会浪费交换次数\n\n\n\n\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "9", "answer": "当栈底只剩下一个元素的时候，它既是栈顶元素也是栈底元素，她是可以删除的\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "当第一个元素最大，第二个元素也很大时，第一轮冒泡会使大元素向前移动\n有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n例如 初始 4 3 1 2\n第一趟 3 1 2 4\n快速排序中也有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "错误，顺序栈是指顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比如 要求升序排序 8 6 4 1\n第一趟排序 6 4 1 8\n6朝着反方向移动\n快速排序就没有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "4", "answer": "但是在快速排序过程中不会有这种现象，因为在快速排序中，以枢轴为基准，比它小的元素往前移，比它大的元素往后移，可能在排序过程中某些元素有些波动，但不会朝着其相反的方向移动。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "在不涉及插入和删除的操作时，顺序表比链表好。顺序表在插入删除时要移动大量元素，较不方便。而若只是读取访问元素，则更为方便。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表：采用顺序存储方式，逻辑上相邻的数据再计算机内的存储位置也是相邻的。顺序存储方式中，元素存储是连续的，中间不允许有空，并且可以快速定位元素位置。但在不利于插入和删除元素。\n链表：用指针将存储表元素的单元串联在一起，删除和插入数据时不需要移动大量的数据，但要在每个单元内设置指针来表示表中元素的关系。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "8", "answer": "1.需要随机存储表中任意元素时、需要用简单，直观的公式表示元素存储位置时用顺序表比较好。\n2.查询操作多，插入，删除数据少时用顺序表比较好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2的(n-1)次方\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不行,双链表的时间复杂度为O(1),循环单链表的时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "栈底元素总是最先被插入的元素，从而也是最后才能被删除，如果栈底元素已经成为了栈顶元素，可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "7", "answer": "采用链式存储结构。\n\n\n\n\n根据实际需要申请内存空间，而当不需要时又可以将不用节点空间返还给系统。在链式存储结构中插入和删除操作不需要移动元素。\n\n\n\n\n1、比顺序存储结构的存储密度大(链式存储结构中每个结点都由数据域与指针域两部分组成，相比顺序存储结构增加了存储空间)。\n\n\n\n\n2、逻辑上相邻的节点物理上不必相邻。\n\n\n\n\n3、插入、删除灵活 (不必移动节点，只要改变节点中的指针)。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误.\n顺序栈指的是用一块连续的内存空间去存储栈的内容, 顺序栈存储空间是有序的, 但是并没有规定元素值的大小也必须是有序的. 只要元素值是合法的, 元素值可以是任意的值. 栈中元素的次序只和入栈的先后顺序有关.\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "顺序表可以随机访问元素，但是不方便增删元素，链表方便增删元素，但不能随机访问元素\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "如果待排序列的后面的若干排序码比前面的排序码小，则有可能后移。如{4，3，2，1}，第一趟后为{3，2，1，4}，3就后移了。快排不会。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n2.不会；\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "int Empty(Stack &s1,Stack &s2)\n{\nif(s1.empty()&&s2.empty())\nreturn 1;\nelse return 0;\n}\nvoid POP(stack &s1,stack &s2,elemtype &x)\n{\nif(!empty(s2))\n{\npop(s2,x);\n}\nelse if(!empty(s1))\n{\ncout<<\"队列为空\"<<endl;\n}\nelse{\nwhile(!empty(s1))\n{\npop(s1,x);\npush(s2,x);\n}\npop(s2,x);\n}\n}\nint PUSH(stack &s1,stack &s2,elemtype x)\n{\nif(!overflow(s1))\n{\npush(s1,x);\nreturn 1;\n}\nif(overflow(s1)&&!empty(s2))\n{\ncout<<\"满\"<<endl;\nreturn 0;\n}\nif(overflow(s1)&&empty(s2))\n{\nwhile(!empty(s1))\n{\npop(s1,x);\npush(s2,x);\n}\npush(s1,x);\nreturn 1;\n}\n}\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "2", "answer": "可以。在单链表、双链表和循环单链表中，删去操作的时间复杂度都为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "入队时，先入栈S1（此时为逆序），出队时，先将S1的元素出栈再入栈到S2中（此时为顺序），再出栈。如果S1和S2都为空则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "1、防止单链表是空的。若单链表是空的，则单链表的头指针指向NULL。\n2、有益于删除单链表的第一个元素的操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一点答案：优点是每个栈仅用一个顺序存储空间时，操作简单，缺点是分配的空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n第二点答案：优点是多个栈仅用一个顺序存储空间，只有在整个存储空间都要用完是才会产生溢出，缺点是当一个栈满是要向左、右查询有无空闲单元，如果有，则要移动元素和修改相关栈底和栈顶指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n\n\n第三点答案：优点是多个链栈一般不考虑栈的溢出，缺点是栈中元素要以指针相链接，比顺序存储多占用了存储单元。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.需要随机访问时，顺序表的存储空间是连续的一片的，但是链表是分散的，需要借助指针\n2.确定元素数量时\n3.不需要大量地增减，插入删除等需要大量移动元素的操作时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "答：最多的比较次数是当两个有序表的数据刚好是插空顺序的时候。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.入队：若s2不为空，将s2所有数据弹出，按照弹出顺序一次进入栈s1中。若s2为空，入队就直接将数据进入栈s1。\n2.出队：若s1不为空，将s1的数据出栈，按出栈顺序依次进入栈s2，出队列也就是将数据从s2中弹出。\n3.判断队列是否为空：也就是判断s1，s2是否都为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "序列{4,3,2,1}在第一次冒泡排序时4与3会交换，3从下标2到下标1，但是3的最终下标在3。\n\n\n\n\n没有。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "除了根节点外，每个高度的结点都只有一个，且都有在左边或在右边两种可能性，所以共有2^（n-1）种二叉树\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、对于带头节点的单链表，在单链表的任何节点之前插入节点或者删除节点，所要做的是修改前一个节点的指针域，因为任何节点都有前驱结点。\n2、对于带头节点的链表，在表空是也存在一个头节点，因此空表与非空表的处理 是一样的。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "2", "answer": "可以删去，但是单链表需要枚举头指针，而其余两个不用。时间复杂度：单链表和循环单链表和双链表都为O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "顺序表是提前申请一大部分空间再按照顺序存储数据，无法改变空间大小。\n链表是要存储数据时才申请空间，其数据依靠指针进行联系，可以按照需求进行一定的空间拓宽。\n当需要涉及到元素的插入，删除，移动时，多用链表，需要直接访问元素时，多用顺序表。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "2", "answer": "可以删去，复杂度均为o（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "错，因为栈只能在栈顶插入和删除，当我们在栈顶连续运行插入时，栈底元素就会是我们刚刚第一个插入的元素（最早被插入的元素）；当我们在栈顶连续不断运行删除时，栈底元素就会是我们最后删除的元素（最后被删除的元素）\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "7", "answer": "宜采用链表存储结构。因为链表存储结构插入和删除操作不需要移动元素，只需要改变指针的指向，效率高。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "最少比较n次：\nA顺序表的最大值比B顺序表的最小值还要小，只需要拿B的最小元素与A中所有元素比较一遍即可，所以只需要比较n次。\n\n\n\n\n最多比较2n-1次：\n当两个有序表的数据刚好是插空顺序，比如：第一个序列是1,3,5，第二个序列是2,4,6\nB中的元素2要和A中的元素1和元素3比较两次，B中的元素4要和A中的元素3和元素5比较两次，4一定是比2大的，2之前的元素无需再比较，类比下去，B中的每一个元素都要比较两次（除了最后一个元素，最后一个元素只需比较一次就可以）总的次数=2（n-1）+1=2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：每个栈仅用一个顺序存储空间时，操作简单。\n缺点：分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n（2）优点：多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。\n缺点：当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针，这一过程计算复杂且十分耗时。\n（3）优点：链栈是动态分配空间，相比顺序存储，不需要考虑溢出和空间浪费。\n缺点：栈中元素要以指针相链接，比顺序存储多占用了存储空间，且操作更麻烦一点。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "7", "answer": "（1）优点：操作简便，使用下标就可进行操作。\n缺点：在建立时需要确定栈的大小。\n（2）优点：节省空间。\n缺点：操作繁琐。\n（3）优点：栈的大小可以尽量大。\n缺点：需要申请额外的空间以存放指针域。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表特点：开辟一次，永久使用，可以通过下标直接进行访问\n\n\n\n\n链表特点：随时需要，随时开辟，动态的进行开辟空间，一般不会出现溢出，内存不足情况\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "1.可以统一空表和非空表的操作\n2.便于一些特殊操作，插入或删除第一个结点时不用考虑特殊情况\n3.链表为空时，无头结点，头指针为null，而有头结点，头指针指向头结点\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "比较n次，两个表有序排列，比较2n-1次，两个表反序排列\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "当高度为1时有1个；当高度为2时有2个；当高度为3时有4个满足要求。\n设有n个节点并且高度为n的二叉树个数为N。\nN=2^(n-1).\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。当栈中只有一个元素时，这个元素被称为栈低元素，可以被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "顺序表：储存空间连续，储存密度高，删除插入操作较复杂。\n链表：储存空间不连续，储存密度低，删除插入操作较简单。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "错误。栈底元素可以被删除，当用一个指针指向栈底时，利用该指针将其删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "n/2;\n(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：不可以。不知道头指针就无法找不到p指针所指结点的前驱，无法实现删除操作\n双链表：可以，可以用p指针指向的结点的左指针找到前一个结点（设为q），然后实现q - >right = p ->right,时间复杂度为O（1）\n循环链表：可以，循环链表可以通过循环来找到p结点的前驱，从而实现删除操作，时间复杂度为O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "错误，顺序栈是指用顺序存储结构的栈，并不是指元素值的大小是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "当不涉及插入.删除.移动等操作的时候，用顺序表比链表好，因为对于顺序表而言进行插入，删除等操作时，需要移动差不多一半的元素，比较费力。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误的，当栈中只有一个元素时，该元素称为栈底元素，它可以被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "ai=(n+1-i)*3;\n根据队列元素先进先出的特点，队列进队后立即出队的顺序为3，6，9...3n,根据栈元素为先进后出的特点，所以栈顶元素为3n，即a1=3n，a2=3(n-1),a3=3(n-2)...推知ai=(n+1-i)*3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1)\n因为队列是先进先出，后进后出，队列元素出对按3，6，9，12，...，3n的顺序出对，并按此顺序入栈，所以栈底元素为3，栈顶元素为3n，若a1=3n，则\na2=3（n-1）............ai=3(n-i+1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "a2=3n-3,a3=3n-6..\n因为出队序列必为3，6，9，12...3n\n则栈的入栈序列为3,6,9,12...3n\n又因为a1=3n\n所以a1出栈时3，6，9，12...3n-3必还在栈里\n出栈则必为3n-3..12,9,6,3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "采用链式存储结构。\n\n\n\n\n根据实际需要申请内存空间，而当不需要时又可以将不用节点空间返还给系统。在链式存储结构中插入和删除操作不需要移动元素。\n\n\n\n\n1、比顺序存储结构的存储密度大(链式存储结构中每个结点都由数据域与指针域两部分组成，相比顺序存储结构增加了存储空间)。\n\n\n\n\n2、逻辑上相邻的节点物理上不必相邻。\n\n\n\n\n3、插入、删除灵活 (不必移动节点，只要改变节点中的指针)。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.入队：在s1中入栈\n2.出队：将s1中，栈底元素以外的元素按顺序出栈并立刻进入栈s2，再将s2中的元素按顺序出栈，并立刻进入栈s1\n3.判断队列是否为空：判断栈s1 是否为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "如序列 1 ，9， 2， 3， 4， 5， 6，第二次排序时9会一直移动到序列的最右侧。\n有。从左边寻找的第一个比基准数大的数会与从右边寻找的第一个比基准数小的数进行位置交换。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "正确。n个元素都进栈后，他们的出栈顺序唯一，即和入栈顺序相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "链式储存结构，这种方法进行增删时不需要移动结点，速度快\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "h(n)=C(2n,n)/(n+1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1、举例：待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n\n\n2、存在\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "第一种方法：\n更符合人的编程习惯。对栈各开空间，方便分开操作，无需考虑两栈相冲突等等。\n瓶颈也很明显：开顺序存储空间本身就意味着上限是固定的，无法动态增加，以及会浪费空间（不过这其实是存储方式的问题，和栈本身没联系）\n\n\n\n\n第二种方法：\n优点是：\n应该只有节省空间了，但空间并非稀有资源，优势有限。\n缺点是：\n不符合人的编程习惯，要考虑各个栈的栈底和栈顶在哪个位置，彼此之间不能冲突，大大增加编程难度。\n试想：当一个栈满时，要向左右查询是否有空闲空间，然后还要移动元素，修改指针..\n\n\n\n\n第三种方法：\n优点是：\n1.综合了第一种方法的优点和第二种方法的优点，既可以动态开辟空间，不用考虑空间浪费或者不足。\n2.也方便对各个栈进行操作，无需考虑两栈相冲突等。\n缺点是：\n1.用链表来实现栈，会比较难写啊。所以日常中比较少看到这种写法。\n2.就空间考虑，还要以指针相链接，和顺序相比也多占用了一些并不是很多但也算的存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.输入数据为：4,3,2,1进行降序排列，最终排列为1,2,3,4，4移动到了相反方向\n2.输入数据为：4,3,2,1进行降序排列，快速排序中，第一趟以4为基准，导致1移动到第一位形成序列为1,3,2,4\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "8", "answer": "链表存储方式是动态分配空间，顺序表的存储空间是静态分配的。顺序表存储是用一块连续的内存存储空间，但是不好动态增加长度，可以直接用下标查找和存储，但在插入和删除一个元素时，需要遍历整个顺序表。链表只要存储器还有空间，就不会发生存储溢出的现象，插入和删除元素的速度快，只需改变指针指向，但每一次查找元素都需要循环链表访问。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "采用链表\n因为相对于使用顺序表时，需要对某节点前或后所有元素都进行操作，移动一遍节点，\n用链表只需要改变某节点的指针域，使其指向另一个节点，时间复杂度很小。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.每个栈用一个连续存储空间时，操作简便，但如果分配存储空间小，有可能会产生溢出，分配空间大了，会造成空间上的浪费，各栈不能共享空间。\n2.多个栈共享一个连续存储空间，充分利用存储空间，其缺点是当一个栈满时要向左、右栈查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈顶指针。当接近栈满时，查询空闲单元、移动元素和修改栈底栈顶指针的操作频繁，计算复杂并且耗费时间。\n3.多个链栈一般不考虑栈的溢出，仅受用户内存空间限制，缺点是栈中元素要以指针相链接，比顺序存储多占空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.单链表必须知道要删除节点的前一个节点，不知道头指针不能删除。\n2.双链表可以，因为提供的是双向链接，因此根据已知结点可以查找到其前后，从而可以删除该结点。时间复杂度为O(1)\n3.单循环链表也可以，根据已知结点位置，可以直接得到其直接后继，再循环到其前一个。时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "链表。链表的插入操作仅需对指针进行修改，不需要大量的数据移动\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。栈实现的是先进后出，后进先出，所以在n个元素全部进栈后，他们的出栈顺序和进栈顺序一定相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\nn / 2\n\n\n（2 * n + 1) / 3\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比如：初始：5.4.3.2.1\n第一次排序：4.3.2.1.5\n4往后移动了\n没有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "4", "answer": "顺序表就是将数据元素放到一块连续的内存存储空间，而链表存储是在程序运行过程中动态的分配一块空间\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "答：\n\n\n\n\n(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.当不涉及插入和删除操作的时候\n2.需要对表中随机某个元素进行操作时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "例如，30，20，10，15在第一次冒泡后序列变为20，10，15，30，20朝着与最终排序相反的方向移动了。\n在快速排序中也会出现这种情况，例如：对序列90，30，20，50，60以90划分时，序列变为60，30，20，50，90。其中60也朝与最终排序相反的方向移动了。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "防止单链表是空的而设的。\n\n\n\n\n为了方便单链表的特殊操作,插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "（1）满二叉树：2^n-1=n\nn=1\n（2）完全二叉树：2^(n-1)-1<n<2^n-1\nn=2\n所以有2个。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、在表首进行链表的删除、插入操作时，不需要进行头指针的指向更新。\n2、统一空表和非空表的处理，头结点的设置使得对链表的第一个位置上的操作与在表中其它位置上的操作一致。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "待排序序列后面的若干关键字比前面的关键字小，则可能出现上述情况。\n快速排序不会出现这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "6", "answer": "\n\n入队：先用栈s1存储所要入队的元素，s1里的元素再出栈，所出的元素入栈到s2。\n\n\n出队：s2里的元素出栈\n\n\n判断队列是否为空：s2.size==0即队列为空。\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "比较次数是当两个有序表的数据刚好是插空顺序的时候，比如：第一个序列是1,3,5，第二个序列是2,4,6，把第二个序列插入到第一个序列中，先把第二个序列中的第一个元素2和第一个序列依次比较，需要比较2次（和1，3比较），第二个元素4需要比较2次（和3,5比较，因为4比2大，2之前的元素都不用比较了），第三个元素6需要比较1次（只和5比较），所以最多需要比较5次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）归并排序是多次将两个或两个以上的有序表合并成一个新的有序表。最简单的归并是直接将两个有序的子表合并成一个有序的表。归并排序最好情况下的复杂度为 O(n)。\n\n\n\n\n（2）最多的比较次数是当两个有序表的数据刚好是插空顺序的时候\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "在等概率的前提下，插入一个元素需要平均移动n-i个元素\n\n\n\n\n元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2),则插入一个元素需要平均移动(n-i)(2(n-i)/n/(n+1))个元素\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.当插入在表头或者删除第一个结点时，操作会和其他地方一致，保持了单链表操作的统一性。\n2.当链表为空时，头结点的指针域的数值为NULL，方便看出\n3.单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "6", "answer": "比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n\n\n快排有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "9", "answer": "使用两个栈模拟队列是通过先把元素入栈到S1，再出栈后入栈到S2，就可以实现先入栈S1的元素先出栈S2，与队列先进先出的特点一致。\n1.入队：把元素入栈到S1，入栈后再从出栈立即入栈到S2；\n2.出队：将S2的栈顶元素出栈；\n3.如果栈S1和栈S2均为空则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "方便在第1个位置进行插入、删除操作时同其他位置一样。 加了头结点之后，插入、删除都是在后继指针next上进行操作，不用动头指针；若不加头指针的话，在第1个位置插入或者删除第1个元素时，需要动的是头指针。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n有些栈被称为顺序栈是因为存储空间是顺序的，而不是其顺序栈中元素值的大小是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点：所列基本运算都可在O(1)的时间里完成，效率高。\n缺点：为了使每个栈都不会溢出，通常要为每个栈预置一个较大的栈空间。另一方面，由于各个栈的实际大小在算法运行过程中不断变化，经常会发生其中一个栈满而另一个栈空的情形，空间利用率低。\n(2)优点：提高空间利用率，减少栈发生上溢的可能性。\n缺点：当一个栈满时，需要查询左右单元有无空闲单元，较为耗时。\n(3)优点：存储空间自由，不用担心溢出情况。\n缺点：需要额外的存储空间来存放用于连接的指针，对于存储同样多元素而言存储空间消耗较大。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "冒泡排序过程中，有的排序码在某一次冒泡中可能朝着与最终排序相反的方向移动。对记录13，79，56，20，40进行冒泡排序，第一次冒泡后的结果为13，56，20，40，79。排序码56朝着与最终方向相反的方向移动了。没有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "6", "answer": "单链表不能删除，因为不知道头指针，就不知道指针p之前的节点，就无法删除。双链表和循环单链表可以，时间复杂度均为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "①已知所需要的存储规模。\n②需要访问已知地址的数据元素。\n③不需要频繁进行插入删除等操作的。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "例如：7 4 3 1 2 5（要求从小到大排列）\n最终4应当排在第四个位置，3应该排在第三个位置\n而在第一趟中\n4 7 3 1 2 5\n4 3 7 1 2 5\n4 3 1 7 2 5\n4 3 1 2 7 5\n4 3 1 2 5 7\n即4和3朝着与最终排序相反的方向移动。\n快速排序中没有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "这句话是错误的，顺序栈是指用顺序存储结构实现的栈，与栈中元素的顺序无关，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.多个顺序存储空间建立多个独立的顺序栈，优点是每个栈仅用一个顺序存储空间，出栈进栈操作简单，缺点是必须事先确定数组存储空间的大小，分配空间小了，容易溢出，分配空间大了，容易造成浪费。\n2.多个栈共享一个顺序存储空间。优点是充分利用了存储空间。缺点是多个栈的数据类型要相同，同时在一个栈快满的时候，要向左、右查询有无空闲空间。如果有，则要移动元素和修改相关的栈底和栈项指针，这一过程十分耗时。\n3.分别建立多个独立的链栈。优点是不用考虑栈的溢出问题，缺点是栈中每个元素都有指针域，比顺序存储多占用了空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.是为了方便单链表的特殊操作，能有效减少代码量，在插入在表头或者删除第一个结点时不用考虑特殊情况。\n2.当链表为空的时候,带头结点的头指针就指向头结点，如果当链表为空的时候,单链表没有带头结点,那么它的头指针就为NULL。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、插入和删除结点时，无需特判该结点前是否有其他结点。\n2、对带头结点的链表,表头指针是指向头结点的非空指针,因此空表与非空表的处理是一样的。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1).\n因为可推知每个节点只有一个孩子，除根结点外每个节点都有左、右位置两种选择。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "链式结构而非顺序表\n频繁地对一个线性表进行插入和删除操作时，如果是链式结构的链表只需要改变少数元素的指针域即可，顺序表则需要大量地移动元素，耗时大效率低\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表：1.无须为表示表元素之间的逻辑关系增加额外的存储空间；\n2.可以方便的随机存取任一位置的元素。\n链表：1.在执行插入和删除运算时，不再需要移动元素来腾出空间或填补空缺。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "9", "answer": "由于队列先进先出，输出顺序不变，由于栈后进先出，所以ai = 3n，3n-3 ... 9，6， 3 （1<=i<=n）\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最简单的归并是直接将两个有序的子表合并成一个有序的表。归并排序最好情况下的复杂度\n为 O(n)。\n\n\n\n\n最多的比较次数是当两个有序表的数据刚好是插空顺序的时候，比如：第一个序列是1,3,5，第二个序列是2,4,6，把第二个序列插入到第一个序列中，先把第二个序列中的第一个元素2和第一个序列依次比较，需要比较2次（和1，3比较），第二个元素4需要比较2次（和3,5比较，因为4比2大，2之前的元素都不用比较了），第三个元素6需要比较1次（只和5比较），所以最多需要比较5次。即2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "链表。因为链表在插入和删除时不需要移动被修改位置前后的所有元素，长度可随时变化，节省运行时间。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1，防止单链表为空。\n2，使得第1个位置的插入、删除等操作同其他位置一样，不需另外写代码来考虑第1个位置存在的特殊情况，实现程序高效性。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "一、顺序表\n1、优点：逻辑相邻，物理相邻；\n无须为表示元素间的逻辑关系而增加额外的存储空间；\n存储空间使用紧凑；\n可随机存取任一元素。\n2、缺点：插入、删除操作需要移动大量的元素；\n预先分配空间需按最大空间分配，利用不充分；\n表容量难以扩充。\n二、链表：\n1、优点：避免了数组要求连续的单元存储特点；\n在执行插入或删除运算时，不再需要移动元素；\n2、缺点：需要在每个单元中设置指针来表示表中元素之间的逻辑关系，增加了额外的存储空间。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "9", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的序列 也是 3,6,9.....3n.\n又因为栈是后进先出的，当a1=3n时，说明最后进栈的元素先出栈，这样只有一种出栈序列，为3n,3n-1,.....,9,6,3.\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.当储存的数据类型相同，并且储存数据的规模已知时顺序表比链表好。\n2.插入删除等操作几乎都是在尾部时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3n-3（i-1）。\n因为栈的输出特点为后进先出，而队列为先进先出，所以经过第一个队列输出后顺序没变，而经过栈输出后顺序相反了。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "错。是元素之间的存储是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：不可以\n双链表：可以，时间复杂度为O(1)\n循环链表：可以，时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "不正确。\n解释：\n1.由栈的操作可知，栈底的元素是最先插入的元素，也是最后删除的元素。所以，栈底的元素当然可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "队列是先进先出的，出队顺序是3、6、9、12、... 3n，入栈顺序也是3、6、9、12、... 3n，栈是后进后出的，a1=3n说明最后一个元素最先出栈，所以只有一种出栈顺序，3n,3n-3......9,6,3, ai=3（n+1-i）\n，\n，\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "采用链式存储结构，插入和删除时，时间上比顺序结构少了移动节点的时间\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是空间分配不灵活，空间小了，容易溢出，空间大了，容易浪费，而且各栈不能共享空间。\n(2)优点是充分利用了存储空间。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.最主要的是不必特判在第一个节点前进行插入或者删除，使得所有节点操作起来代码都一样。\n2.统一了非空表和空表，初始化时也更好写，好处大致同第一点。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.单链表：当我们知道指针p指向某结点时，能够找到其后继，可是不知道其头指针，所以无法访问到p指针指向的结点的前驱。所以不能删去这个结点。\n2.双链表：链表提供双向链接，根据结点可以查找到其前驱和后继，所以可以删除该结点。时间复杂度为O(1)。\n3.单循环链表：由结点位置，可以得到其后继，由于是循环链表，因此可以通过查找，得到该结点的前驱。所以能删去p所指结点。时间复杂度应为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "由于队列先进先出，输出顺序不变，由于栈后进先出，所以ai = 3n，3n-3 ... 9，6， 3 （1<=i<=n）\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.使得对所有节点的操作都能通用，不用再对首元素另外操作。\n2.避免单链表成为一个节点都没有的空表。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "顺序表：逻辑上相邻的元素物理位置也相邻，且存储单元是连续的，存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。\n链表：逻辑上相邻的元素物理位置不相邻，链表存储是在程序运行过程中动态的分配空间\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是 一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小。而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "当后一个 有序表的所有元素的排序码值都比以前一个有序表的大时，或后一个有序表的所有元素的排序码值都比以前一个序表小时，只要n次比较就能完成排序；当两个有序表的所有元素的排序码值交错排列时，需要2n-1次排序码比较。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "2的n次方-1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最小：前半段均小于后半段（例如前半段1,2,3,4,5...,后半段11,12,13,1,4,15...）\n最多：插空的排法（例如前半段恰好为奇数1,3,5,7,9...，后半段恰好为偶数2,4,6,8...）\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "    顺序表优点:容易实现对表的遍历，容易在表尾插入新元素。缺点:在非表尾位置插入、删除元素时需操作从该位置起的后面所有元素，十分费时。\n    链表优点:在插入或删除元素时，无须移动元素来腾出空间。缺点:需要在每个单元中设置指针来表示表中元素之间的逻辑关系，而需使用额外的存储空间。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "由于栈的特点是先进后出，为了模拟先进先出的队列，必须用两个栈，其中栈SI用于插入元素，栈S2用于删除元素。每次删除元素时应将前一个栈的所有元素读出然后进入第二个栈中，这样才能达到模拟队列的效果，这里使用找的一些基本操作如下：\npush(ST,x):栈的压入;\nptop(ST,x):退出找顶元素赋给X;\nsempty(ST);判定栈是否为空。\n本题的函数如下：\nvoid enqueue(s1,x)\nstack s1:\nint x;\nif(s1->top==m0-1) printf(\"队列上溢出!\\n\");\nelse push(s1,x);\nvoid dequeue(s1,s2,x)\nint x;\ns2->top=0;/将s2清空,将s1的元素退栈后推入s2,此时s1为空/\nwhile(!scrapty(s1))\npush(s2, ptop(s1));\nstop(s2,x);/将s2的栈顶元素退栈并赋给x/\nwhile(!sempty(s2))\npush(sl, ptop(s2)); /将s2的所有元素退栈并推入s1中/\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "若无一边入栈一边出栈，那么出栈顺序和进栈顺序相反\n理由如下：\n假设n个元素入栈后（前提），那么他们出栈的顺序必定与入栈顺序相反。不管n个元素入完栈之后是否有其他元素入出栈，你跟踪这n个元素，总会发现是与入栈顺序相反的顺序。\n所以没有错。\n如果 入栈 1, 入栈2，入栈3，（考虑1,2,3，这三个元素），入栈X，出栈，出栈，入栈Y，出栈，出栈，出栈。\n你会发现入栈顺序，123\n出栈顺序X3Y21,仅考虑1,2,3，元素，顺序就是321，所以与入栈顺序123相反。\n若一边入栈一边出栈，那么出栈顺序和进栈顺序不相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "待排序列中，某元素后面的若干元素都比他小，就可能往相反方向移动，如 2、3、6、5、4、1，一趟排序后为2、3、5、4、1、6。5向相反方向移动。\n\n\n\n\n快速排序没有。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "错误，例如进栈序列为123，出栈的顺序可以是132。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "采用链式结构存储线性表，使用这种方法只需要改动指针来进行插入和删除，不需要移动节点，更方便\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是n/2；\n\n\n\n\n若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数是(2n+1)/3\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表的存取速度高效，通过下标来直接存储，所以当我们经常性的需要存或者取出某个元素的时候就用顺序表\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "对于单链表：若想要删除结点p，必须知道p的前一个结点，使前一个结点指向指针p的下一个结点，再释放p空间。现在不知道前一个结点，故不能删除。\n对于双向链表：知道p指向的结点，将p->next赋值给p的前一个结点的next，将p->next->front赋值给p->front，如此，便删除了p\n对于循环链表：知道p指向的结点，再由p的下一个结点指向p的下一个结点的下一个结点，又由于这是一个单向循环链表，所以最终可以遍历到p的前一个结点，将p->next赋值给p前一个结点的next，就删除了*p。\n时间复杂度全为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "错误，顺序栈只是存储空间按照顺序进行，和元素值无关。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "使用链表。链表可以更为快速便捷的插入或删除元素，不需要移动元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "堆栈的特征：FILO 先进后出\n队列的特征：FIFO 先进先出\n所以，用两个栈s1和s2模拟一个队列时，s1作输入栈，逐个元素压栈，以此模拟队列元素的入队。\n当需要出队时，将栈s1退栈并逐个压入栈s2中，s1中最先入栈的元素，在s2中处于栈顶。\ns2退栈，相当于队列的出队，实现了先进先出。\n只有栈s2为空且s1也为空，才算是队列空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序为3.6.9......3n。而栈是后进先出的，当a1=3n时说明最后进栈的元素先出栈，这样只有一种出栈序列，即为3n.3n-3.....9.6.3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序为3、6、9、12、…、3n，而栈是后进先出的，当a1=3n时说明最后进栈的元素最先出栈，这样只有一种出栈序列即为3n、3n-3、…、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.用S1来存放已经输入的元素，S1执行入队的操作，此时元素在栈S1中是逆序，当元素需要出队时，将S1中所有元素出栈并入栈到S2中，此时元素在S2中是顺序，再将元素从S2中出栈即可完成出队操作。当S2和S1都为空时，队列为空。\n\n\n\n\n\n\n入队：void Push(stack S1, stack S2, int e){\nif(栈S1不满){\n元素入栈;\n}\nif(栈S1满&& 栈S2空){\nwhile(栈S1不为空){\n元素从S1出栈;\nS2入栈;\n}\n}\n}\n\n\n\n\n\n\n\n\n出队：void Pop(s/tack S1, stack S2){\nif(栈S2不为空&&栈S1为空){ //S2不为空，出栈\n元素出栈;\n}\n}\n\n\n\n\n\n\n\n\n判断为空： bool empty(stack s1,stack s2){\nif(栈s1为空&&栈s2为空){\n队列为空;\nreturn true;\n}\nelse\nreturn false;\n}\n\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "如果在待排序序列的后面的若干排序码比前面的排序\n码小则在起泡排序的过程中排序码可能向与最终它\n应移向的位置相反的方向移动。例如\n574038111334487561997如9向相反方向移动\n657403811133448757199如19向相反方向移动\n675740381113344875919如9向最终方向移动\n679574038111334487519如13向相反方向移动\n679115740381319344875如13向最终方向移动\n679111357403819344875如34向相反方向移动\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "不用插入，删除数据时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "不正确。理由如下：\n\n\n\n\n当栈为空时，本就不存在栈底元素，可见栈底元素可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "1、当链表为空时，头指针指向头节点，使空表和非空表的处理统一，方便操作。\n2、使头指针的值不需要改变，方便理解。\n3、使第一个元素也有前驱，方便在第一个元素前插入或删除第一个元素。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表：存储简单，但插入和删除较慢，不可扩充表的容量\n链表：便于插入和删除，可随时增加表的长度，但代码实现比顺序表复杂\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "8", "answer": "1.栈底元素严格来说不是删除，而是出栈，删除是对与链表来说的，栈底元素要出栈，必须要让其栈顶元素出栈，直到栈底元素同时也是栈顶元素的时候，栈底元素就可以出栈，出栈后，栈为空\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "单链表不行，双链表和单循环链表可以，时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "5", "answer": "等概率情况下：n/2\n不相等概率下：n/2\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "\n\n第一种情况：第一个表中的所有元素都比第二个表的元素小。\n\n\n\n\n\n2.第二种情况：第二个表是平均插入第一个表中。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3(n+1-i)\n因为队列存储元素的特点是先进的先出，后进的后出，所以出队序列和进队序列是一样的\n而栈的特点是先进的后出，后进的先出，所以出队序列是和进队序列的倒序\n即a1=3n,a2=3(n-1).......an=3(n+1-n)=3\n所以ai=3(n+1-i)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "对空间要求高的场合，比如容量很小的设备存放的数据用顺序表的成本就一定比链表要低。读表元操作顺序表优于链表，因为顺序表可实现随机存取结构。\n\n\n\n\n对于数据元素数量少，结构简单时；需要更快获得某个位置的元素时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：不能，因为根据p指向的节点能找到该节点的后继结点，不知道头指针无法找到该节点的前驱结点，则无法删除\n双链表：可根据该节点找到前驱和后继节点，则可删除该节点的元素，时间复杂度为O(1)\n循环单链表：根据该节点可直接找到后继节点，因为是循环单链表，可通过查找找到p的前驱节点，因此可删除。时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "错误的，当前一个元素a进栈后，在后一个元素b进栈前栈顶元素a出栈，此时出栈顺序与进栈顺序不相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点：各个顺序栈各自独立，操作起来较为简单。\n缺点：分配空间可能过大，造成浪费，且各自独立的话缺少关联。\n(2)优点：共享空间可使存储空间得到最大利用，且各个栈关联性较强。\n缺点：栈顶栈底指针的移动需要耗费时间，且操作不是很简便。\n(3)优点：不容易溢出。\n缺点：栈链以指针连接元素，指针也需占用空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "顺序表：1.表中的元素在空间位置上相邻。2.容易进行遍历操作，但不易进行插入、删除的操作。3.使用时需要预估表的大小。\n链表： 1.表中的元素在空间位置上不相邻。2.方便进行插入、删除的操作。3.表的大小足够长，但需要花费额外的空间存储指针。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "2的n-1次方\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "原因：队列是先进先出，进队顺序为3、6、9、12、..... 3n,出队顺序也是一样；而栈是先进后出，入栈元素即为前面进队元素，但是出栈顺序为前面的逆序\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.（1）的优点是存储的地址连续，操作简单，缺点时一开始就确定了栈的大小，容易造成空间浪费或者溢出。\n\n\n\n\n2.（2）的优点是减少存储空间的浪费，缺点是也会造成溢出。\n\n\n\n\n3.（3）的优点是可以根据所需来开辟相应大小的空间，不会造成空间浪费或溢出，缺点是操作复杂。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟，后期无法改变大小（使用动态数组的情况除外）。\n而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "ai=3n+3i-3;\na1=3n说明作为最后一个进栈的3n的一个出栈，则之前并没有出栈操作，所以只能从3n到3按顺序出栈\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入栈操作。\n当需要出队时，则对S2执行出栈操作。\n由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而执行操作前必须判断S2是否为空，否则会导致顺序混乱。\n当栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "错误，栈底元素可以删除，栈可以为空\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "0", "answer": "可以\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序表（数组）实现的栈，栈中元素值的大小不一定有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确，当栈里只有一个元素时，栈顶等于栈底，这时的栈底元素可以删除，否则不能删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "0", "answer": "(n-1)/2\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n在栈中不止一个元素的时候栈底元素不能被直接删除，但若栈中仅有一个栈底元素即可删除变为空栈。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误，因为假如栈里就一个元素，也称其为栈底那样就可以直接删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "0", "answer": "0\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一种情况（最少需要比较n次的情况）：\n若按升序排序，设两个有序表设为A和B，当每次比较时，对于A中的任意一个元素（假设为i），对于B中的元素都有A[i]小于B[0]，或者对于B中的任意一个元素（假设为i），对于A中的元素都有B[i]小于B[0]，则从A[0]到A[n-1]或者B[0]到B[n-1]，都将直接放到长度为2n的有序表的前半部分.此时我们只需比较n次。\n特征：此时有序表的前半部分全是A（或B）中的元素，而后半部分全是B（或A）中的元素\n\n\n\n\n第二种情况（最多需要比较2n-1次）：\n若按升序排序，设两个有序表设为A和B，当每次比较时，对于A和B中的任意一个元素，都有A[i]<B[i]且A[i+1]>B[i]，或者A[i]>B[i]且A[i+1]<B[i]，即2n的有序表中A和B中的元素交替排列。此时需要比较2n-1次。\n特征：此时2n的有序表中A和B中的元素交替排列\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "如对4,3,2,1排序时，第一趟排序结果为3,2,1,4，此时3移向了最终排序相反的方向。\n快速排序过程中没有这种现象，因为快速排序每一趟过程中，比基准数小的数都会被排到左边，比基准数大的数会被排到右边。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "\n\n标识作用, 为遍历整个链表提供一个起始值.\n\n\n判断链表是否为空\n\n\n可作为哨兵节点, 统一插入节点和删除节点的操作\n\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "可以删除。当栈中只剩下这一个元素，那么它既是栈底又是栈顶，可以pop删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "2^(n-1)个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不能实现，双链表和循环链表可以实现。\n双链表时间复杂度为O(1)、循环链表则为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "是正确的。\n\n\n\n\n栈遵循“后进先出”，每次只能访问栈顶元素，所以在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，当栈中只剩一个元素时，栈底元素就可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "9", "answer": "答: 当S1和S2模拟队列时，\n1、入队时元素进入栈S1,若栈S1满且栈S2为空,则将栈S1中的所有元素送入栈S2；\n2、出队时元素从栈S2出栈,若栈S2为空,则将栈S1中的全部元素送入栈S2；\n3、判断队列是否为空则判断栈S1和栈S2是否都为空即可。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）的优点在于操作简单明了，时间复杂度低。\n缺点是很难确定栈空间大小，容易空间利用率低。\n（2）的优点是充分利用存储空间，只有多个栈栈顶相遇时可能发生上溢，会减少上溢可能，可以互补余缺。\n缺点是如果需要移动、修改元素，时间复杂度很高。\n（3）的优点是不用考虑栈的溢出问题。\n缺点是需要用指针连接栈的元素，对存储空间需求更大。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "入队\nbool Enqueue(Stack *S1, Stack *S2, ElemType e){\nif(!StackOverflow(S1)){ //S1不满，入栈\nPush(S1, e);\nreturn true;\n}\nif(StackOverflow(S1) && !StackEmpty(S2)){ //S1满栈，S2不空则无法入队\nreturn false;\n}\nif(StackOverflow(S1) && StackEmpty(S2)){ //如果S1满，S2空\nwhile(!StackEmpty(S1)){ //S1不空，出栈，S2入栈\nPop(S1, x);\nPush(S2, x);\n}\n}\nPush(S1, e);\nreturn true;\n}\n出队\nbool Dequeue(Stack *S1, Stack *S2, ElemType x){\nif(!StackEmpty(S2)){ //S2不为空，出栈\nPop(S2, x);\nreturn true;\n}else{\nreturn false;\n}\nif(StackOverflow(S1)){ //S1栈满时，出栈，S2入栈\nPop(S1, x);\nPush(S2, x);\n}\nPop(S2, x);\nreturn true;\n}\n判空\nbool QueueEmpty(Stack S1, Stack S2){\nif(StackEmpty(S1) && StackEmpty(S2)){ //S1，S2都不为空\nreturn true;\n}\nreturn false;\n}\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈之间不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：便捷容易操作，一个独立的顺序栈只占一个顺序存储空间。缺点：无法控制存储空间的分配大小，可能分配过大空间，也可能分配太小的空间，造成内存浪费或者溢出。\n（2）优点：多个栈共享一个顺序存储空间，存储空间得到充分利用，不容易造成内存浪费而且仅当顺序存储空间都用完时才会溢出。缺点：操作较为麻烦，时间消耗较多。要判断栈满时是否还有空余的空间。并且进行更改栈底和栈项指针，移动元素等一系列操作。\n（3）优点：不会发生溢出。缺点：操作较顺序存储空间不够便捷，需要用指针连接，而且占用空间更多。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "4", "answer": "链式结构。\n在链式存储结构中插入和删除操作不需要移动元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：无法删除\n双链表：可以删除，时间复杂度为O(1)\n循环单链表：可以删除，时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1)\n出队后进入一个栈，所以出队顺序即为入栈顺序，序列为：3，6，9，12，...3n\n根据栈后入先出，出栈顺序与入栈顺序相反，为3n，3(n-1)，...6，3\n所以ai=3*(n-i+1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "6", "answer": "1、入队时将数据压入S1。\n2、若要出队，则循环将栈顶的数据压入S2，直到S1只剩下一个数据，即最先入队的数据，将其出栈完成出队操作，然后在重复将S2的栈顶数据压入S1直到S2为空。\n3、若S1为空则说明队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "在需要按顺序存储大量在逻辑关系和物理关系上均相邻的元素并不需要增加、删除、修改的情况下，使用顺序表比链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "在不涉及插入和删除元素时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "应该采用链式存储结构。因为顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素；而采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，不必移动节点，只要改变节点中的指针，插入、删除更灵活。而且移动指针域操作比移动元素操作花费的时间少得多。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "链表，链表的删除和插入不需要移动后面的所有元素，时间复杂度较低。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "入队：两个栈S1，S2都为空，执行入队操作，将元素直接插入S1中；栈S1为满，栈S2不为空，则队列为满，无法执行入队操作；栈S1为满，栈S2为空，执行入队操作，先将栈S1中的元素逐一出栈，再逐一入栈S2，当S1为空时，将元素插入S1中，实现入队操作。\n\n\n\n\n出队： 栈S2不为空，则队首元素位于S2的栈顶（栈S1为满，S2不为空），执行出队操作，将S2中的栈顶元素出栈，实现出队操作； 栈S2为空，栈S1为空，则队列为空，无法实现出队操作；栈S1不空，栈S2为空，执行出队操作时，先将S1中元素逐一从S1出栈，再逐一入栈S2，最后将S2中的栈顶元素出栈，实现出队操作。\n\n\n\n\n判空：两个栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "要达到这个目标，各种链表的要求不同\n如果是单链表，那么你必须知道一个在p前面的结点。如果不知道就只能免谈了。\n如果是双链表和单循环链表则只要知道任意一个结点就可以了、\n时间复杂度全是O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "单链表：不行。\n双链表：可以。时间复杂度为O（1）。\n循环链表：可以。时间复杂度为O（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "n/2\n(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1)\n对于队列这一数据结构，其遵循的是“先进先出”（FIFO）的规则，而对于栈这一数据结构，其遵循的是“后进先出”（LIFO）的规则。\n那么，首先因为进入队列的序列为3、6、9、12、... 3n，则此时从队头到队尾的元素依次为：3、6、9、12、... 3n。\n之后，队列里面的元素经过一个队列后立即出队进入一个栈，最先出队的元素被压入栈的底部，第二个出队的元素压在栈底元素的上一个元素...以此类推，最后一个入队的元素是3n，它最后出队，出队后进入栈中，位于栈顶。\n因为出栈时的输出序列标记为a1、a2、...an，所以:\na1=3n=3*(n-1+1)\na2=3n-3=3*(n-2+1)\na3=3n-6=3*(n-3+1)\n......\nan=3=3*(n-n+1)\n所以，由归纳推理可得：ai=3*(n-i+1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "（1）首元素因为没有前驱结点，在其前面进行插入、删除操作较为复杂，而头结点的设置可以简化该操作，使其和其他结点的操作一致\n（2）头指针是指向头结点的非空指针，使得空表和非空表的处理统一\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "2n-1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "ai=3\n因为队列是先进先出：3,6,9,12...\n所以进栈的顺序为：3，6,9，12...\n又因为栈是先进后出，所以3最后出\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.单链表：由于只知道该节点的后继，不知道头节点，无法找到该节点的前驱，所以无法删除该节点\n2.双链表：由于提供双向链接，所以可以找到前驱和后继，因此可以删除该节点，时间复杂度为O(1)\n3.循环单链表：由于是循环链表，可以找到该节点的前驱，又已知后继，因此可以删除该节点，时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "队列是从队首出队的，所以第一个出队的是3，最后一个出队的是3n。第一个出队的3最先入栈，最后一个出队的3n最后入栈。栈具有先进后出，后进先出的特点，故最后进栈的3n最先输出。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "有。\n例如9 8 5 6 7，经过一趟排序后变为8 5 6 7 9,其中8就朝着与最终排序相反的方向移动\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储\n优点：在物理空间上是连续的，存取速度高效，通过下标来直接存储\n缺点：1.插入和删除比较慢，2.不可以增长长度\n\n\n\n\n链表的存储方式与顺序表相反，存储数据的时候才申请存储空间\n优点：插入和删除速度快，保留原有的物理顺序\n缺点：查找速度慢\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "队列遵循先进先出的原则，所以序列从队列中出来后仍然保持3、6、9、12…3n。而栈则是先进后出，进入栈后，从栈尾到栈首依次是3n、…12、9、6、3，从栈尾出，所以a1=3n，而ai=3n-3（i-1）。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的.当链表为空的时候,带头结点的头指针就指向头结点.如果当链表为空的时候,单链表没有带头结点,那么它的头指针就为NULL.\n\n\n\n\n2、是为了方便单链表的特殊操作,插入在表头或者删除第一个结点.这样就保持了单链表操作的统一性!\n\n\n\n\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "对的\n先进后出\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，当栈中只有一个元素时，这个元素也是栈顶元素，可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "\n\n\n这是第一种方案：优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，各栈不能共享空间。\n\n\n\n\n\n\n这是第二种方案：优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，提高空间利用率，并减少发生栈上溢的可能性。缺点是当一个栈满时要向左、右查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n\n\n\n\n这是第三种方案：优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n\n\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3n-3i+3。\n要使a1=3n,只有当所有元素都出队并进入栈，等到队空之后才开始执行出栈操作。因此ai=3n-3i+3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表存储数据实行的是 一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n\n\n因此若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。\n\n\n\n\n顺序表的特点是逻辑上相邻的数据元素，物理存储位置也相邻，并且，顺序表的存储空间需要预先分配。\n\n\n\n\n在链表中逻辑上相邻的数据元素，物理存储位置不一定相邻，它使用指针实现元素之间的逻辑关系。并且，链表的存储空间是动态分配的。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "最简单的归并是直接将两个有序的子表合并成一个有序的表。\n最多的比较次数是当两个有序表的数据刚好是插空顺序的时候，比如：第一个序列是1,3,5，第二个序列是2,4,6，\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n\n第一问：有可能：如：在序列：1 5 8 6 2 4 10中第一趟排序过程中，8和6会交换位置，使得6朝着与最终排序相反的方向移动。\n\n\n\n\n\n\n第二问：没有。\n\n\n\n\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "2n-1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "当后面一个有序表的所有元素的排序码值都比前面的有序表的大时，如{5，6，7，8}和{9，10，11，12}，或者后面一个有序表的所有元素的排序码值都比前面的有序表的小时，如{9，10，11，12}和{5，6，7，8}，只需n次，两个有序表的所有元素的码值交错排列时，如{4，6，8，10}和{5，7，9，11}，需要2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "\n\n便于判断链表是否为空\n\n\n无论链表是否为空, 头指针都会指向头结点, 避免了经常出现的空指针异常\n\n\n使用头结点能够统一删除第一个节点/在表头插入元素这种特殊操作与其他操作, 降低代码的复杂性, 减少错误\n\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n当栈顶指针指向栈底元素的时候，可以通过pop（）方法来删除栈底元素\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "7", "answer": "链表。\n因为在顺序表中进行插入和删除操作，要移动平均表中一半的元素，当元素信息量较大时比较难以处理实现，而链表的插入删除主要是比较操作，容易实现。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n插入位置0,...,n，平均移动个数2/n；\n\n\n平均移动元素个数为(2n+1)/3；\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "（1）8 ，6，4，5 在第一趟冒泡后序列变为6，4，5，8，6 朝着与最终排序相\n反的方向移动了。\n（2）在快速排序中也会出现这种情况，例如，对序列[90，32，25，50，60]以90 划分时，序\n列变为[60，32，25，50]，90，其中60 也朝与最终排序相反的方向移动了。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "链表。因为链表只需改变插入或者删除的位置的前后两个结点的指针，而顺序表在进行插入或者删除的操作，需要移动大量的元素，效率较低。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "顺序表存储数据是一次性开辟足够的存储空间，是静态分配的，而链表的存储方式是动态的，存储时一次只开辟存储一个节点的物理空间\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "0", "answer": "平均移动元素个数为 （n + 1 ） / 2个\n为n - i;\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确，顺序栈是指用顺序存储结构实现的栈,栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "答：\n1：优点：采用多个顺序表，算法简单，思路清晰明了；\n缺点：和数组缺点一样，分配空间容易过大或过小，分配小了容易溢出，分配大了又浪费内存。\n2：优点：能够充分利用存储空间，部容易造成浪费。\n缺点：当其中一个栈满时，得修改栈顶或栈底元素，或者需要移动相应元素，较为复杂。\n3：优点：栈不容易溢出，比较安全。\n缺点：算法较为复杂，需以指针为基础，且要分配指针空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1、可用于防止链表为空链表。\n2、无需在程序处理中再对首元结点和中间结点分别处理，使程序更加简洁，流程更加清晰。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "h(n)=h(0)*h(n-1)+h(1)*h(n-2)+...+h(n-1)h(0)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。要查询空闲单元、移动元素和修改栈底和栈顶指针时，计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。操作相对于共享空间容易，相较于顺序存储复杂。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：操作简单。缺点：不能灵活分配存储空间，容易溢出或造成浪费。\n（2）优点：充分利用存储空间。缺点：操作复杂，如一个栈满，在利用左右空余存储单元时需要经历查询是否有空余、修改栈底和栈顶指针、移动元素。\n（3）优点：大幅减少栈溢出可能性。缺点：元素之间逻辑关系用指针表示，需要占用额外空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：每个栈仅用顺序存储空间，操作简单；缺点：分配空间是固定的，不能分享，如果分配大了，浪费空间，如果分配空间小了，就容易溢出。\n（2）优点：充分利用存储空间；缺点：当一个栈满了之后要向左右查询是否有空闲的空间，如果有的话，就要移动元素和移动相关的栈底和栈项指针。当接近栈满时，就要查询是否有空闲的空间、还要移动元素和移动栈底、栈顶指针，这个过程计算复杂耗时。\n（3）优点：不考虑栈的溢出，缺点：需要指针链接，比顺序存储需要更多的存储空间\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "正确的，顺序栈中元素值的大小是有序的。 这里顺序的意思是顺序存储结构，而不代表存储元素一定有序。 栈顶元素和栈底元素有可能是冋一个元素。 栈是一种对进栈、出栈操作总次数做了限制的线性表。 对顺序栈进行进栈、出栈操作不涉及元素的前、后移动问题。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、单链表：因为不知头指针，不能找到p结点的前趋，所以不能删除；\n2、双链表：可以根据该结点找到其前趋和后继，所以可以删除，时间复杂度为O（1）；\n3、循环单链表：可以根据该结点找到其前趋和后继，所以可以删除，时间复杂度为O（n).\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "不正确，因为元素的进栈时间是不确定的，随时可以作为栈顶元素出栈。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "防止单链表为空。当链表为空时，带有头结点的头指针就会指向头结点。如果该链表没有头结点，那么头指针就会为NULL。\n单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n保证处理第一个节点和后面的节点的时候设计的算法相同，实现程序的高效性。\n方便单链表的特殊操作,插入在表头或者删除第一个结点.这样就保持了单链表操作的统一性\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.是为了方便单链表的特殊操作,插入在表头或者删除第一个结点.这样就保持了单链表操作的统一性!\n2.单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "需要快速访问和随机读取大量元素，而不涉及到增删改等动态操作时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "不正确。栈底元素可以在最后被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1、用S1来存放入队的元素，即执行入栈操作。\n2、用S2来执行出栈操作，先判断S2为空，由于从S1出来的元素是原来顺序的逆序，所以必须将S1中所有元素都出栈，再进入到S2中。\n3、S1和S2都为空时队列才为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "解:若将两个长度为n的有序表归并为一个长度为2n的有序表需比较n次,则两个被归并的表应满足:其中一个表的所有元素均小于(或大于)另一个表中的任意元素,若将两个长度为n的有序表归并为一个长度为2n的有序表需比较2n-1次,则两个被归并的表应满足:其中一个表的所有元素不得均小于(或大于)另一个表中的两个或两个以上的元素。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，例如进栈序列为123，出栈序列可以是132\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表的不行，如果要删去P指向的结点，就需要知道该结点前一个结点。\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "2的n-1次方种二叉树\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少的比较次数是这样一种情况：若A表所有元素都小于（或大于）B表元素，则A1比较完B1～Bn之后，直接拼接即可。\n最多比较次数的情况应该是A、B两表互相交错，此时需要穿插重排。则A表的每个元素都要与B表元素相比，A1与B1相比，能确定其中一个元素的位置；剩下一个还要与另一表中下一元素再比较一次，\n即：在表A或表B的n个元素中，除了最后一个元素外，每个元素都要比较2次！最坏情况总共为2n—1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表将无法删除，因为无法找到*p之前的那个节点，而双链表和单循环链表则可以，时间复杂度为n\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "5", "answer": "顺序表适用于需要访问大量元素而不涉及插入和删除操作的时候\n\n\n\n\n链表适用于需要大量增添和删除元素操作的，对访问队列无需求的数据存储\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "栈每次只能把元素插入到第一个位置（栈顶），每次只能读取栈顶的元素，栈只能访问栈顶元素，即“后进先出”\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.顺序栈优点是直接进栈出栈，方便理解，缺点是需要确定栈最大容量，而且往往会浪费空间。\n2.优点是比1更好利用空间，减少浪费，缺点是仍然需要确定栈最大容量，且比1相对麻烦。\n3.优点是无需确定容量，直接动态分配内存，确定需要使用指针，较麻烦。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.单链表，因为没有前驱节点，所以不行。\n2.双链表，因为有直接的前驱节点没所以时间复杂度为O(1)。\n3.循环单链表，因为要寻找前驱的时候需要遍历一遍循环，所以时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "应该采用链式结构存储线性表。因为在链式存储结构中插入和删除操作中不需要大量移动数据元素，只需要改变节点中的指针指向，耗时更为少。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.使得每个节点都有前驱，增，删等操作时无需单独对头节点额外操作；\n2.无论表是否为空，头指针都指向头节点，对于空表和非空表的操作是一致的\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、为防止单链表是空的而设的，当链表为空的时候,带头结点的头指针就指向头结点，如果当链表为空的时候,单链表没有带头结点,那么它的头指针就为NULL。\n2、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "解：队列“先进先出”，故入栈的顺序为3，6，9...3n,栈“后进先出”，又由于最先出栈的是3n,故出栈顺序为3n，...12，9，6，3。由于a1=3n，可推出a2=3(n-1),a3=3(n-2)，所以ai=3(n-(i-1)),即ai=3(n-i+1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "链表。因为采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。但移动指针域操作比移动元素操作花费的时间少得多。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "当数据元素是连续存储的时候，且不需要进行大量的插入和删除操作，已知数据长度。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确，栈底元素是最后可以删除的元素，当栈底元素也是栈顶元素时可以出栈。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误\n栈底元素可删除，只有先将栈底之前的元素删除才能删除栈底元素\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "3", "answer": "[100，1，0，10，11]以100 划分时，序列变为[11，10，0，1]，100，其中11 朝与最终排序相反的方向移动了。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "①顺序表：事先需要规定存储空间的大小。在访问已知位置的数据元素时较为容易。\n②链表：可以动态分配内存。在进行插入删除操作时较为方便。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "0", "answer": "正确，栈的操作顺序是先进后出\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。它只是采用顺序存储结构来实现栈，并不要求元素值大小有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错\n\n\n\n\n在一般情况下，栈存在栈顶和栈底两个元素此时栈底是不能被删除的元素，因为在连续插入的时候，栈底是第一个被插入的元素，根据栈的工作性质，先进后出，后进先出，此时栈底是不能被删除的元素，需要他来标识栈的开始，\n\n\n\n\n但是，当栈底和栈顶是一个元素时，此时删除栈顶就是删除栈底，标志着一个栈的消失。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "答：1.在等概率的前提下，插入一个元素需要平均移动的元素个数是n/2；\n2.插入一个元素需要平均移动的元素个数是(2n+1)/3。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表不可行，找不到p指向的节点的前驱节点。\n双链表和循环单链表可以，时间复杂度都是O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "答：此解释是错误的。进栈的顺序不一定是严格的1~n，可以随机。栈的特点的先进后出，但可以边进边出，如进栈1234，则出栈可以是3421。没有严格的递增或递减顺序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2 ; (2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3n，...，12，9，6，3\n原因：出队顺序：先进的先出，所以进栈是：3，6，9，12，...，3n\n出栈顺序：后进的先出，所以出栈为3n，...，12，9，6，3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "在增删改操作少、查找多的时候使用顺序表优于链表。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1).\n因为a1=3n,则在所有元素均入栈后才进行第一次出栈，此时从栈底到栈顶的顺序与进队序列的顺序一致，则输出序列为进队序列的倒序\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "不正确。\n1.栈是操作受限的数据结构。只允许在栈的顶部进行插入和删除操作，但对于具体栈中元素值的大小，并没有规定是否要有序，我们可以随意输入任意大小的元素，无须保证它们的大小必须是有序的。顺序栈中元素值的大小是否有序对于入栈、出栈等操作没有影响。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "对，前和后是固定的\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "利用两个栈s1和s2来模拟一个队列\n1.对S1的入栈操作用作入队，若S1满，必须先保证S2为空，才能将S1中的元素全部插入S2中\n2.对S2的出栈操作用作出队，若S2为空则先将S1中所有元素送入S2\n3.当栈S1和S2都为空时队列为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表：\n创建时需要固定容量\n可以随机访问元素，且时间复杂度为O（1）\n查询方便，不利于改，删；\n\n\n\n\n链表：\n任意伸缩，储存空间不连续。\n前后元素关系性很强\n适合未知数据容量的情况使用\n删除元素更改元素时间复杂度为O（n），较顺序表低\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "个数是2的n-1次方\n即除了最底层的叶子节点之外，其他n-1个非终端的节点只有一个孩子\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中元素值的大小不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "用S1作为输入栈，S2作为输出栈。\n1、当入队时，将元素压入栈S1中。\n2、当出队时，元素需先从栈S1退栈并逐个压入栈S2中，最先入队的元素应处于S2栈顶，并从S2退栈。\n3、判断队列是否为空：当栈S1为空且S2为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表的不行，如果要删去P指向的结点，就需要知道该结点前一个结点。\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "错误。栈中元素值的大小是无序的。栈中元素的排序只与入栈和出栈顺序有关，与元素的大小无关。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "1.顺序表存储时需要连续的存储空间，链表不需要连续空间。\n2.顺序表要在程序执行之前必须明确规定它的存储规模，事先对“MAXSIZE”要有合适的设定。链表不需要。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "1.给第一个结点设置了前驱，便于在表头插入或删除第一个结点。\n2.防止单链表是空的。\n3.单链表加上头结点后，使得头指针始终指向头结点，方便单链表操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，栈的元素删除只能从栈顶开始\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "例如：4 3 2 1\n第一趟 3 2 1 4\n此时3朝着与最终排序相反的方向移动\n\n\n\n\n没有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "ai=3i。队列先进先出，栈后进先出。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "设有待入队元素: 1, 2, 3, 4, 5.\n\n\n\n\n在队列中, 入队是在队尾插入新的元素; 出队是让队头的元素出队. 若要使用栈来模拟队列, 可以使用两个栈 S\n1\n\t​\n\n,S\n2\n\t​\n\n, S\n1\n\t​\n\n 模拟入队; S\n2\n\t​\n\n 模拟出队. 具体操作如下:\n\n\n\n\n\n入队操作\n\n\n\n\n\n栈 S\n1\n\t​\n\n 来作为队列的缓冲区, 按入队顺序入栈. 如下所示:\n\n\n\nS\n1\n\t​\n\n\t[栈顶]\t5\t4\t3\t2\t1\t[栈底]\n\n\n\n\n出队操作\n\n\n\n\n\n当队列需要出队时, 就将 S\n1\n\t​\n\n 缓冲区中的所有元素依次出栈, 并按出栈顺序入栈到 S\n2\n\t​\n\n 中. 此时, 栈S\n2\n\t​\n\n 内的元素顺序因于 原S\n1\n\t​\n\n栈 中的元素顺序相反. 如下所示:\n\n\n\nS\n2\n\t​\n\n\t[栈顶]\t1\t2\t3\t4\t5\t[栈底]\n\n\n\n缓冲区 S\n1\n\t​\n\n 空栈之后, S\n2\n\t​\n\n 栈顶的元素即第一个入队的元素. 若要对模拟队列出队, S_2 出栈即可完成出队操作.\n\n\n\n\n\n判断队列是否空\n\n\n\n\n\n若 栈S\n1\n\t​\n\n 和 栈S\n2\n\t​\n\n 均为空则队列为空.\n\n\n\n\n有伪代码如下\n\n\n\nvoid enqueue(item x)\n{\n    if(s1.full())\n    {\n        while (!s1.empty()) s2.push(s1.pop());\n    }\n    \n    s1.push(x);\n}\n\nitem dequeue()\n{\n    if (s2.empty())\n    {\n        while (!s1.empty()) s2.push(s1.pop());\n}\n    \n    return s2.pop();\n}\n\nbool empty()\n{\n    return s1.empty() && s1.empty();\n}\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在冒泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向。\n快排中也会存在这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "当后一个有序表的所有的排序码值都比前一个有序表的大时，或后一个有序表的所有元素的排序码值都比前一个有序表的小时，只要n次比较就能够完成所有元素的排序码值交错排列时，需要2n-1次排序码比较。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，因为在进栈的过程中可以随时出栈，这就打乱了进栈的顺序。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不，顺序栈是在内存空间中是连续的，但是他们存储元素值是任意的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.需平均移动的元素个数是n/2；\n2.需要平均移动的元素个数是(1+n)nn/4;\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n快排没有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "6", "answer": "顺序表存储数据实行的是 一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n\n\n因此若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "可用栈S1模拟入队操作，栈S2模拟出队操作（假设栈S2空间大于栈S1，若链表实现可无视该假设）\n\n\n\n\n\n模拟入队操作：若S1未满，则将新元素压入S1中；若S1已满，则检查S2是否为空，若S2已空就将S1中的元素逐个弹出\n并压入S2中，然后再将新元素压入S1中，若S2不空就报错并说明队列已满。\n\n\n模拟出队操作：若S2不空，就直接弹出S2栈顶元素；若S2已空，则检查S1是否为空，若S1不空就将S1中的元素逐个弹出\n并压入S2中，然后再弹出S2栈顶元素，若S1已空就报错并说明队列已空。\n\n\n判断队列是否为空：检查S1和S2是否为空，若S1和S2均空就说明队列已空，否则队列不空。\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "当比较次数为2n-1时，两个有序表的数据刚好是插空顺序，如表1为1，3，5；表2为2，4，6。\n当比较次数为n时，第一个表全部小于第二个表的最小值时。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "方案（1） 优点:只要需要判断各自的栈手是否溢出或者为空即可\n缺点：浪费了空间，栈的空间有限\n方案(2) 优点: 节省了空间\n缺点: 要维护多个栈的栈顶和栈底，比较耗时\n方案(3) 优点: 不需要实现设置栈的大小，可以动态添加元素\n缺点: 每个元素占用空间稍大一点\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比较n次时：其中一个表的最大值比另一个表的最小值小，即归并时只有一个表的元素被存入储存数组\n比较2n-1次时：两个表的元素一大一小，直到其中一个表空了\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：不可以，不知道头指针\n双链表：可以，O(1)\n循环单链表：可以，O(n),通过循环查找找到前驱结点\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "在数据不做大量改动，大部分情况下只用于查找的时候顺序表比链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "n\nn-1\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比如将2 3 1 0 10按升序排列，在第一躺排序时，由于1比0大，所以1会与0交换，使1往右方移动，而对最终排序来说，1需往左移动，这就产生了1往相反运动的现象。\n\n\n\n\n快排没有这种情况。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "宜采用链表来存储。因为链表每次插入和删除不需要移动大量元素，只需改变对应元素的next指针指向即可，需要的时间复杂度较低。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答:\n\n\n\n\n\n(1)优点是 每个栈仅用一个顺序存储空间时，操作较为简单。缺点是分配空间过小，容易产生溢出，分配空间过大大，容易造成浪费，并且各栈不能共享空间\n\n\n(2)优点是 多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出, 减少了浪费。缺点是当一个栈满时需要查询有无空闲单元。如果有，则需要要移动元素和修改相关的栈底和栈项指针。并且当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n(3)优点是 多个链栈一般不需要考虑栈的溢出。缺点是栈中元素要以指针相链接, 数据密度小, 浪费了一部分存储空间。\n\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表存储方式为数据分配连续的存储单元，数据元素按照逻辑顺序，故逻辑顺序相邻的元素物理也相邻；\n链表存储方式分配的存储单元可以不连续，通过每个结点的指针域来表示数据元素之间的逻辑关系，只能顺序访问线性表中的数据元素。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "1", "answer": "方便对链表进行访问，存储链表的地址。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "利用两个栈s1和s2来模拟一个队列，当需要向队列中插入一个元素时用S1来存放已输入的元素，即S1执行入队操作。\n当需要出队时，则队S2执行出栈操作。必须先将S1中所有元素出栈并入栈到S2中，再在S2中出栈即可实现出队操作，而在执行此操作之前必须判断S2是否为空，否则导致顺序混乱\n当栈S1和S2都为空时队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "不涉及插入和删除操作的时候\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "是错误的。\n\n\n\n\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，栈中元素先进后出\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "对。\nn个元素进栈后这些元素都是先进后出，出栈顺序与进栈顺序相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "\n\n需要对数据随机访问\n\n\n对内存空间有更高的要求, 需要紧凑的内存空间\n\n\n静态数据, 不需要对数据进行插入或删除\n\n\n数据规模小或已知数据规模\n\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1.n个元素进栈后，出栈顺序刚好和进栈顺序相反\n比如 进栈元素是 1 2 3 4 5 6\n要出栈，只能 6先出栈 6 然后 5出栈，依次 4 3 2 1 出栈顺序就是6 5 4 3 2 1 与进栈顺序一定是相反的\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不行，需要从头指针开始遍历找到上一节点。双链表可以，O(1)。单循环链表可以，O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "错误，解释:当栈中只有一个元素时，这个元素也称栈底元素，它可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "顺序表可以随机访问数据元素，但是大小固定，不利于增减，插入删除元素（需要移动大量元素）。\n链表采用指针方式存储，有利于增减，插入删除结点，只需要改变指针域即可，但是不能随机访问，只能按照顺序\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "错误，解释：顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "初始： 2 5 3 4 1\n第1次： 2 5 3 4 1\n第2次： 2 3 5 4 1 3比最终位置前移了一个位置\n第3次： 2 3 4 5 1 4比最终位置前移了一个位置\n第4次： 2 3 4 1 5\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "宜采用链表存储，因为其不需要像顺序存储一样移动大量的元素，只需改变指针的指向即可，速度更快。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，这里顺序的意思是指顺序存储结构，不是指存储元素一定有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
