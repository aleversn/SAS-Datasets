{"score": "5", "answer": "            采用链式存储结构。\n            它根据实际需要申请内存空间，而当不需要时又可将不用结点空间返还给系统。在链式存储结构中插入和删除操作不需要移动元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是 \"一次开辟，永久使用\"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外） 而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "是错误的。\n\n\n\n\n栈底元素是最先被插入的元素，也是最后被删除的元素，删除后栈为空。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "1.入队时全部s1中\n2.出队时将s1中元素全部压入s2弹出首个元素\n3.s1与s2皆为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表是事先开辟足够空间，而链表是动态分配空间。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "1.使空表和非空表形成统一，减少出现bug的几率。\n2.方便单链表的特殊操作，例如插入在表头或者删除第一个结点。若链表没有头结点，则首元素结点没有前驱结点，在其前插入结点或删除该结点时操作会复杂些。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少的比较次数是这样一种情况：若A表所有元素都小于（或大于）B表元素，则A1比较完B1～Bn之后，直接拼接即可。\n最多比较次数的情况应该是A、B两表互相交错，此时需要穿插重排。则A表的每个元素都要与B表元素相比，A1与B1相比，能确定其中一个元素的位置；剩下一个还要与另一表中下一元素再比较一次，\n即：在表A或表B的n个元素中，除了最后一个元素外，每个元素都要比较2次！最坏情况总共为2n—1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。因为栈只有顶部的出入口，只能顺序进入，逆序输出。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "\n\n\n两个栈S1，S2都为空，执行入队操作，将元素直接插入S1中。栈S1为满时，栈S2为空时，执行入队操作，先将栈S1中的元素一个个出栈，再一个个入栈S2；\n\n\n\n\n当S1为空时，将元素插入S1，实现入队操作。若栈S2不为空，无法执行此操作。\n\n\n\n\n\n\n\n\n2.当栈S2为空，栈S1为空时，则队列为空，无法实现。栈S2不为空时，队首元素位于S2的栈顶，将S2中的栈顶元素出栈，实现出队操作。\n\n\n\n\n3.若两个栈S1和S2都为空时，则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n\n当我们有两个栈S1和S2，可以用S1来模拟入队，当元素x需要入队时，我们将它push进S1。\n当我们需要出队的时候，则需要用到S2，由于要先入队的先出队，所以我们应该把S1的元素全部出栈\n再按顺序入栈到S2中，即原来S1的栈顶是S2的栈底，S1的栈底变成S2的栈顶，这样S1第一个入栈的也就是\n第一个入队的就可以做到第一个出队。\n\n\n\n\n\n\n\n\n入队\n\n\n\n 当S1不为满的时候，将要入队元素入栈；\n 当S1满了但是S2为空的时候，将S1所有元素出栈再按顺序入栈（S2），这样空出了S1栈可以装入队元素，同时也不会改变元素出队顺序；\n 当S1满了且S2不为空时，则无法再入队。\n\n\n\n\n\n\n出队\n\n\n\n 当S2不为空时，可以出队，及S2出栈；\n 当S2为空，S1不为空，则把S1元素都出栈后按顺序再入栈（S2），这样S2又可以出队（栈）了；\n 当S2，S1都为空，则没有元素可以出队了；\n\n\n\n\n\n\n判断队列是否为空\n\n\n\n  S1和S2同时为空栈，则队列为空。\n\n\n\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "宜用链表存储结构，理由如下：\n不需要移动元素，确定插入和删除的位置后便可进行操作，时间复杂度为O(1)。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表将无法删除，因为无法找到*p之前的那个节点，而双链表和单循环链表则可以，时间复杂度为n\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "正确。\n元素全部进栈之后，只能先出栈栈顶元素，这和入栈顺序相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，头结点的指针域的数值为NULL。\n2、为了方便单链表的特殊操作，设置头结点方便插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.当对表需要频繁实行按序号查找时，顺序表比链表好\n2.当所给元素数量固定且数量大小合适时，使用顺序表比链表好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "1、用S1来存放已输入的元素，即S1执行入队操作。\n2、当需要出队时，则队S2执行出栈操作。先将S1中所有元素出栈并入栈到S2中，再在S2中出栈，实现出队操作，而在执行此操作之前必须判断S2是否为空。\n3、当栈S1和S2都为空时队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "这种叙述是错误的。\n\n\n\n\n当n个元素连续进栈时，它们的出栈顺序和进栈顺序一定正好相反；但是如果不是连续进栈，有可能先进几个元素，然后出栈，再进几个元素，再出栈，进出栈顺序就不一定相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "采用链式存储结构，因为它根据实际需要申请内存空间，而当不需要时又可以将不用节点空间返还给系统。在链式存储结构中插入和删除操作不需要移动元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "①例如按升序排序初始序列：1、2、4、3、5、6\n②若按照升序来进行快速排序，最终基准数左边都小于基准数，基准数右边都大于基准数，不存在这种情况\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "3", "answer": "不正确\n出栈顺序和进栈顺序恰好相反，因为栈的元素输入输出遵循：先入后出\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "平均个数为：n/2;\n平均移动个数为：（2n+1）/3;\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "例如：2 4 7 6 3 1 9 8 排序后为1 2 3 4 6 7 8 9，6排第五位，但在第一趟中，6比7小，6被换至第三位。\n快速排序不存在这种情况\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "不是，顺序栈是指存储方式按顺序存储，而不是指元素值大小有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点：\n每个栈仅用一个顺序存储空间时，操作简单。\n缺点：\n分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点：\n多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。\n缺点：\n当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点：\n多个链栈一般不考虑栈的溢出。\n缺点：\n栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "6", "answer": "需要储存的数据数量是已知的情况和数据元素在物理位置上是连续存储的情况，可以根据数量来开辟相应的空间，不会造成空间的浪费，同时也便于查找和修改数据。无须为表示表元素之间的逻辑关系增加额外的存储空间。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，解释：例如进栈序列为123，出栈的序列可以是132。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，不论n个元素入完栈后是否有其他元素入出栈，跟踪这n个元素，都会发现是与入栈顺序相反的顺序\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1.入队\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "①消耗较多内存并且需要连续的地址空间，但是比较灵活，可以多个栈同时使用一个或多个存储空间，也可以独立使用\n②消耗最少内存并且可以多个栈共享同一段地址空间的数据，缺点是其他栈不能过多的存放自己需要的数据\n③消耗较多的内存但是不需要连续的地址空间，每个栈独享存储空间，但不能共享数据\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "每层只有一个节点，因此树的个数与最后一层在满二叉树情况下的节点数相同，有n个节点并且高度为n的二叉树的个数是2^(i-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.需要最小比较次数时，其中一个表的最后一个元素比另一个表的第一个元素小，只要一个表所有元素与另一个表的第一个元素比较。\n\n\n\n\n2.需要最多比较次数时，两个表的元素刚好是互相插空的，一个表的第i个元素刚好比另一个表的第i个大，比另一个表的第i+1个小。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n如初始：7，5，3，1；\n第一趟排序：5，7，1，3；\n可见5往最终排序相反的方向移动。\n快速排序没有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是 \"一次开辟，永久使用\"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外） 而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "7", "answer": "采用链式存储结构。\n根据实际需要申请内存空间，而当不需要时又可以将不用节点空间返还给系统。在链式存储结构中插入和删除操作不需要移动元素。\n1、比顺序存储结构的存储密度大(链式存储结构中每个结点都由数据域与指针域两部分组成，相比顺序存储结构增加了存储空间)。\n2、逻辑上相邻的节点物理上不必相邻。\n3、插入、删除灵活 (不必移动节点，只要改变节点中的指针)。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "错误，顺序栈是指存储空间按顺序\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "该叙述是错误的。\n因为1、有可能出现上述情况，待所有元素进栈后，再一个一个出栈。\n2、但更多的可能是一边入栈一边出栈，可能一个元素入栈就出栈，这样顺序不会正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表的不行，如果要删去P指向的结点，就需要知道该结点前一个结点。\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "n个节点高度为n说明每个节点只有一个孩子，要么是左孩子要么是右孩子，一共有n-1个节点可以有孩子，所以一共有2^n-1个。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以，因为找不到p节点的前驱节点。无法删除p节点。\n循环单链表可以找到p节点的前驱节点，所以可以删除p节点。时间复杂度为O（n）。\n双链表也可以找到p节点的前驱和后继结点。时间复杂度为O(1)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "队列先进先出，所以进栈的次序依次为3、6、9、12、......3n。栈先入后出，后入先出，当a1=3n时，说明最后进栈的元素最先出栈，所以ai=3（n-i+1）\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1.方便在头结点增删元素\n2.出现多个链表时，可以用结构体分开赋值头结点\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "n（n-1）（n-2)......*1个;\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "当线性表很少进行插入和删除操作，或者插入和删除操作总是在尾部进行时，用顺序表比较好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "S1作为临时得栈，最终得元素是存储在S2中\n入队：先把S2中的所有元素压入S1中，再把需要加入的元素压入S1，最后再把S1中的所有元素从栈顶依次压入S2中\n出队：将S2中的元素从栈顶依次弹出\n判断队列是否为空： 判断S2是否为空即可\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "当一个有序表的所有元素的排序码值都比另一个有序表的大时，只需要比较n次\n当两个有序表的所有元素的排序码值交错排列时，需要比较2n-1次\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)的优点是当每个栈仅用一个顺序存储空间时，操作比较简单。缺点是分配空间较小时容易产生溢出，分配空间大时容易造成空间的浪费，各栈不能共享空间。\n(2)的优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈顶指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，操作复杂且耗时。\n(3)的优点是一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储占用了更多存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "①在对单链表进行插入、删除、排序等修改操作的时候无需对第一个节点进行特殊考虑；\n②头结点指针是非空指针，因此对空表进行操作时无需进行特殊处理。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "错，当n等于1的时候，出栈顺序和进栈顺序是一样的。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1）不带头结点的单链表对于第一个节点的操作和其他节点不一样，需要特殊处理。而对带头结点的链表,表头指针是指向头结点的非空指针,因此空表与非空表的处理是一样的。\n2） 对带头结点的链表,在表的任何结点之前插入结点或删除表中任何结点,所要做的都是修改前一结点的指针域,因为任何元素结点都有前驱结点。若链表没有头结点,则首元素结点没有前驱结点,在其前插入结点或删除该结点时操作会复杂些\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，栈只能在栈顶进行删除操作，当栈底前的所有元素都被删除之后，当只剩下栈底元素时，则可以对栈底元素进行删除操作。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误，当栈中只有一个元素时，这个元素也称栈底元素，它可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "对表中元素增删减改少的时候和需要对表内随机某个元素进行操作时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "①在栈S1中专门实现入队，在栈S2中专门实现出队；\n\n\n\n\n②入队时把元素依次压入栈S1；\n\n\n\n\n③需要出队的时候，将栈S1中的所有元素出栈并立即按照出栈顺序压入栈S2，此时判断：若栈S2空，则说明队列为空，报错，若栈S2非空，则将S2栈顶元素出栈完成一个元素的出队，再将栈S2中的所有元素出栈并立即按照出栈顺序重新压入栈S1，完成一次出队过程【中间可加入判断，若需连续出队可在判断栈S2非空的情况下连续将S2中元素出栈，而不需要立即将S2元素压回S1，可以提高运行效率】；\n\n\n\n\n④按照上述的操作方式，判断队列是否为空只需判断栈S1是否为空即可，若栈S1为空，则队列为空，若栈S1非空，则队列非空。\n\n\n\n/*核心代码示例如下：*/\n#include <stack>\nusing namespace std;\nstack<int>/*或其他类型名*/ S1, S2;\nint x;/*或其他类型名*/ \n/*元素x入队：*/\nvoid Queue_push(int x)\n{\n    S1.push(x);\n}\n\n/*队头元素出队：*/\nvoid Queue_pop()\n{\n    while(!S1.empty())\n    {\n        S2.push(S1.top());\n        S1.pop();\n    }\n    if(S2.empty())\n    {\n        cerr<<\"This queue is empty!\"<<endl;\n        return;\n    }\n    S2.pop();\n    while(!S2.empty())\n    {\n        S1.push(S2.top());\n        S2.pop();\n    }\n}        \n\n/*判断队列是否为空*/\nbool Queue_empty()\n{\n    if(S1.empty())return true;\n    else return false;\n}\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误。顺序栈的元素排列是按照进栈顺序而非元素值大小。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "中间插入删除比较多时用链表，头尾插入删除用顺序表，只查询用顺序表\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "应该采取链表存储，因为链表只需要通过改变指针方向即可实现元素的插入或者删除，操作效率高。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n因为可能一边进栈一边出栈\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3(n-i+1),理由如下：\n\n\n\n\n\n\n由于出栈输出序列为a1,a2,a3,....an,且a1=3n，说明3n是在栈顶的位置，也就是说3n是最后一个入栈的\n\n\n\n\n考虑到队列先进先出的特点，先出队的元素先入栈，那么就可以知道，该序列入栈顺序为3,6,...3n。故出栈\n\n\n\n\n顺序为3n,....9,6,3.即ai=3(n-i+1)。\n\n\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以，因为删除要知道前驱节点是谁，单链表哪怕循环到链表结束，得到的也是NULL。\n双链表可以，双链表可以直接O(1)查询前驱和后驱，直接修改。\n循环单链表也可以，只要不断遍历，总能找到一个节点，使得它指向的节点为P，就是前驱节点。又因为最好和最坏都要把链表遍历一遍，时间复杂度是O（n）。\n（ps：觉得这题的表述有点问题，“若仅知道指针p指向某节点，不知道头指针”，其实如果是双链或者循环单链的话，可以得到的信息不只是这个（比如还可以知道p的前驱)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "正确。\n\n\n\n\nn个元素进栈之后，根据堆栈后进先出的原理，这n个元素的出栈顺序就已经确定了，即与进栈顺序正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "经常做按序号访问数据元素时，顺序表只需要O(1)的时间复杂度;\n按值查找数据元素时，若线性表有序时，顺序表时间复杂度为O(logn)由于链表；\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "最少的是刚好前一个表的元素都比后一个表小。\n最多的比较次数是当两个有序表的数据刚好是插空顺序的时候。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "链式存储结构,数组的中间插入（或删除）一个元素，那么这个元素后的所有元素的内存地址都要往后（前）移动，对最后一个元素插入（或删除）时才比较快，而链表不需要改变内存的地址，只需要修改节点的信息即可\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、方便单链表的特殊操作，插入在表头或者删除第一个结点，实现程序的高效性。\n2、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "当需要开辟大片连续空间存储大量数据，且想要直接依据下标顺序对表中元素进行操作的时候使用顺序表比链表好，时间复杂度为O（1）。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答：此答案是错误的。栈的特点的先进后出，但可以边进边出，如进栈1234，则出栈可以是3421。没有严格的递增或递减顺序。所以不一定出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "2", "answer": "顺序表的元素存储在一段连续的存储空间内，链表的元素存储在不连续的地址中。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "2^（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "要实现删除 p 结点的操作,必须找到其前驱结点,修改其指针域的值使其指向 p 的后继结点,以实现删除结点 p 。\n（单链表）单链表不行,因此不知道头指针就无法找到结点 p 的前驱结点。\n（双链表）双链表可以实现删除 p 结点，双循环链表删除 P 结点的时间复杂度为 O(1) 。\n（循环单链表）.循环单链表可以实现删除 p 结点，循环单链表删除 P 结点的时间复杂度为 O(n) 。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "4", "answer": "快排是基于基准把小于基准值放前面，大于基准值放后面，没有该现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "队列进队之后，顺序为3，6，9....3n，队列出队从队头开始，顺序为3，6，9....3n，分别压入栈，故栈顶a1为3n，a2为3（n-1）....故ai=3（n-i+1）。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "平方公式 C=n(n+1)（2n+1）/6\n等概率 n/2\n不等 （2n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "很少使用插入或删减功能\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表：顺序表的内存空间是连续且固定的，存取速度高效，通过下标直接存储，但是增删元素需要遍历所有元素进行移动，效率较低。\n链表：链表的内存空间不连续，链表存储在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题，增删元素只要通过改变指针方向即可实现，效率较高。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "0", "answer": "正确。因为后进栈的元素先出栈，因此出栈顺序正好相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "第一个最小次数为n是数组1的所有元素均小于数组2，所以数组2的第一个元素和前面n个元素比较之后，就可以直接合并\n最多的情况的时候是当数组1与数组2的末尾是先后归并进去的时候，即数组1的末尾进去之后，数组2的末尾进去结束，这个时候是刚刚好比较2n-1的次数，即数组1的末尾大于数组2的倒二个，小于最后一个\n比如数组1有1，2，3，7，数组2有4，5，6，8 4先和数组一比较4次，7再接着比较3次\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "栈是后进先出的线性表，一个栈的入栈序列是3，6，9，…，3n，而输出序列的第一个元素为3n，说明3，6，9，…，3n一次性全部进栈，再进行输出，所以a1=3n，a2=3(n-1)，…，ai=3(n-i+1)。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。而链表则不同，链表存储数据时一次只开辟一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "4", "answer": "链表，链表在插入的时候可以达到O⑴的复杂度，虽然删除也可能需要on的情况，但插入相较于顺序表更优\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，进栈的次序为3、6、9、12、…、3n。栈是先进后出的，当a1=3n时说明最后进栈的元素最先出栈，所以只有一种出栈序列3n、3n-3、…、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "当需要用顺序表模拟某些情况，如地图等\n由于它逻辑相邻，物理相邻，存储空间使用紧凑\n可随机存取任一元素，对于模拟较为方便\n且难以估读储存空间或是空间要求较苛刻的情况下，由于它无须为表示元素间的逻辑关系而增加额外的存储空间，存储空间使用紧凑，可以直接使用顺序表。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "队列是元素先进去的先出，栈是元素后进去的后出。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以，找不到结点p的前一个结点，不能将前一个结点的next改为p->next，直接删去后链表连不上。\n双链表可以，可以通过指针p找到前一个结点和后一个结点，删除结点p后可以连上链表。时间复杂度O(1)\n循环单链表可以，可以通过指针p遍历一圈找到前一个结点和后一个结点，删除结点*p后可以连上链表。时间复杂度O(N)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "单链表：不知道前一个节点，不能删除。\n双链表：双向的话可以知道前后节点，可以删除。时间复杂度为O（n）。\n循环单表：通过循环可以知道前后节点，可以删除。时间复杂度为O（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "最多的比较次数是当两个有序表的数据刚好是插空顺序的时候，比如：第一个序列是1,3,5，第二个序列是2,4,6，把第二个序列插入到第一个序列中，先把第二个序列中的第一个元素2和第一个序列依次比较，需要比较2次（和1，3比较），第二个元素4需要比较2次（和3,5比较，因为4比2大，2之前的元素都不用比较了），第三个元素6需要比较1次（只和5比较），所以最多需要比较5次。即2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由于队列和栈的存储方式，队列是先进先出，栈是先进后出，进队序列为3、6、9、12、... 3n再出队到一个栈中的时候，此时3n在栈顶，而3在栈底，在出栈时是从栈顶到栈底弹出，所以a1是3n，由此得 a2 = 3n-31, a3 = 3n - 32.... ai = 3n - 3*(i - 1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n单链表的不行，如果要删去P指向的结点，就需要知道该结点前驱结点\n\n\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1)\n\n\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "适宜用链式存储结构。因为链表进行插入和删除操作时，只需要改变指针的指向，效率较高。而顺序表进行插入和删除操作时需要移动大量的元素，效率低。故若要频繁进行插入和删除操作，适宜采用链式存储结构。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "在不需插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找，而不需改变表时，使用顺序表比链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答: 错误, 当栈内只有一个元素时, 栈底元素就能够被删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "n/2个\n2(n-1)^2/3n(n+1)\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，栈底元素是最先被插入的元素，可以在最后被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "不涉及插入，删除操作\n需要随机访问数据\n已知最大元素数量\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "链表式存储结构。因为顺序式链表的插入和删除运算不方便，除表尾运算外，其他位置进行插入或删除操作都必须移动大量元素，效率较低。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。不论n个元素入完栈以后是否有其他元素出入栈，跟踪这个元素，都会发现是与入栈顺序相反的顺序\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "一种是两个从小到大的，一种是从大到小的\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "宜采用链表结构。在链表中插入或删除元素时，不需移动其他元素，时间效率高。而对顺序表进行插入、删除操作时，需大量移动其他元素，时间花费高\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "利用两个栈 S1 和 S2 来模拟一个队列，当需要向队列中插入一个元素时，用栈 S1 来存放入队的元素，即 S1 执行入栈操作。当需要出队时，则对栈 S2 执行出栈操作。由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将 S1 中的所有元素全部出栈并压入到 S2 栈中，再在 S2 中执行出栈操作，即可实现出队操作，而在执行此操作前必须判断 S2 是否为空，否则会导致顺序混乱。当 S1 和 S2 都为空时队列才为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：代码实现简单，缺点：不好控制空间分配，容易溢出或浪费\n（2）优点：充分利用储存空间，不会浪费，缺点：一个栈元素多时需要的计算过程复杂，时间消耗大\n（3）优点：通常不会出现栈满的情况，缺点：指针多占了储存空间\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1、需要随机访问（按数组下标或序号访问）数据时；\n2、能事先确定表中最大元素个数（即最大表长）时；\n3、不需要频繁地插入、删除元素时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "直接对每个确定位置修改或取值更加方便，可以直接锁定具体位置。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2 ^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：每个栈分别使用一个顺序存储空间，对其操作起来较为方面。\n缺点：对每个栈分配的空间难把握，若分配较小容易溢出，若分配较大则回造成空间的浪费。\n（2）优点：多个栈共享一个存储空间，这样充分利用了存储空间。\n缺点：当其中一个栈要进行移动或者修改元素的操作时，查询有无空闲单元会较为繁杂，耗费大量时间。\n（3）优点：多个链栈可以不用考虑栈的溢出。\n缺点：栈内元素以指针相连接，比起顺序存储，占用了较多的存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "7", "answer": "链式存储结构。因为链式存储结构在执行插入或删除运算时，不需要移动大量元素位置，只需要改变指针指向的位置，效率比较高\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "2n-1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "这种叙述是错误的\n\n\n\n\n栈有两种存储表示方法,一是顺序栈，二是链式栈。顺序栈说的是存储结构是有序的，而不是元素大小有顺序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "比较n次：两个有序表之间不穿插，即为一个表后接另一个表；\n比较2n-1次：两个有序表之间完全穿插。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。除非是连续进栈，否则可以在进栈下一个元素之前出栈元素，例如1/2/3进栈，3出栈，4/5进栈，5/4/2出栈，6进栈，6/1出栈，进栈顺序为123456，出栈顺序为354261。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "不涉及插入和删除操作的时候用顺序表比链表好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "不需要频繁的插入和删除。\n或者链表需要频繁的尾部插入时，顺序表较好！\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "n/2。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2\nn−1\n个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表储存元素其地址是连续的，且需要在定义时就预先给出数组的大小。\n链表则是利用非连续的空间，一般来说其地址不连续，每个节点要有一部分用于存储下一个节点的地址，不需要预先给定链表的大小。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "答：两个被归并的表的特征：归并排序是多次将两个或两个以上的有序表合并成一个新的有序表。最简单的归并是直接将两个有序的子表合并成一个有序的表。最多的比较次数是当两个有序表的顺序恰好是插空顺序的时候，即所有的元素都比较过。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n（2）优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素 和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序栈指用顺序的储存结构来储存元素而不是里面的元素为顺序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "答: 正确, 因为栈是一种\"先进后出\"的数据结构, 先入栈的一定后出栈, 所以出栈顺序和进展顺序一定相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.防止单链表是空的而设的.当链表为空的时候,带头结点的头指针就指向头结点.如果当链表为空的时候,单链表没有带头结点,那么它的头指针就为NULL.\n\n\n\n\n2.单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，把空链表和链表不存在的情况给分开了\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表：需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙。\n\n\n\n\n链表：什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "错误。不一定要等到n个元素全部进栈后再依次出栈。一个元素入栈后可以马上出栈。例如进栈顺序是1 2 3，出栈顺序也可以是1 2 3，即1入栈后立即出栈，2再入栈再出栈，最后3入栈再出栈。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "该线性表宜采用链式存储结构。因为采用链式存储结构的线性表，进行插入和删除操作只需要改变指针，时间复杂度为O（1）；而采用顺序存储结构的线性表插入和删除时会涉及到数据元素的移动，时间复杂度为O（n)。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "这个叙述是错误的，可以从栈顶的元素先出栈然后一个一个出，最后出栈底的\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n2、为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便单链表的操作，也减少了程序的复杂性和出现bug的机会。\n4、对单链表的多数操作应明确对哪个结点以及该结点的前驱。不带头结点的链表对首元结点、中间结点分别处理等；而带头结点的链表因为有头结点，首元结点、中间结点的操作相同，从而减少分支，使算法变得简单，流程清晰。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.单链表：若仅知道指针p指向某节点，能够找到后面的节点，但是由于不知道头指针，所以无法访问P指针直指向的节点的前驱节点，所以无法将节点p从相应的链表中删去。复杂度为O(n).\n2.双链表：可以将节点p从相应的链表中删去，复杂度为O(1).\n3.循环单链表:可以将节点*p从相应的链表中删去。复杂度为O（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "\n\n\nS1存放入队元素，当需要入队时对S1进行入栈操作即可。\n\n\n\n\n\n\n出队时，如果栈S1为空，栈S2不为空，则直接对S2出栈；如果S1不为空，S2为空，则先将S1中的元素全部出栈并压入到S2中，再对S2进行出栈操作；如果S1 S2都不为空，则先对S2做出栈操作，S2为空时，才可让S1出栈，并压入栈S2。\n\n\n\n\n\n\n只有当栈S1栈S2都为空时，队列才空。\n\n\n\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "出队列再进队列为顺序，进栈和再出栈为逆序\nai=3(n-i+1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确\n当栈中，一个元素既是栈底也是栈顶的时候，这个元素可以删除\n但当栈中，存在除栈底元素外的其他元素，则栈底元素不能删除，否者违背的栈的定义\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "①保证每个结点都有前驱。\n②在表首进行插入与删除操作时更简易一些。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，无法判断这n个元素是否都入栈后才全部出栈(即要满足栈的先进后出特性,只有n个元素连续入栈后,才能满足出栈顺序和进栈顺序相反)。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、优点：每个栈仅用一个顺序储存空间，调理更加清晰，操作更加便捷；缺点：容易造成空间的浪费或者不够，且栈与栈之间不能共享空间。\n\n\n\n\n2、优点：多个栈仅用一个顺序存储空间，使得存储空间被充分利用，不浪费；缺点：是当一个栈满时要对栈的空余位置进行查询、移动元素和更变栈底、栈顶指针，该过程需消耗时间和操作的复杂程度。\n\n\n\n\n3、优点：无需考虑栈的溢出，储存空间不足等问题；缺点：栈中元素需像链表一样用指针相连，较为占用空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表存储数据实行的是 \"一次开辟，永久使用\"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后就无法改变大小（使用动态数组的情况除外）\n而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n顺序表存储数据，需预先申请一整块足够大的连续的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合。\n链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，存储空间不是连续的。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "n/2; (n-i)/(n*(n+1)/2)*n/2\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，因为栈的元素实现的就是后进先出，先进后出，所以元素进栈的顺序一定与出栈顺序相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "当链表的增删改操作比较少时，或者其插入和删除总在尾部进行时，较宜使用顺序表。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.单链表不行；\n2.双链表可以，时间复杂度为 n；\n3.循环单链表可以，时间复杂度为 n。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是 \"一次开辟，永久使用\"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外） 而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "4", "answer": "1、防止单链表是空\n2、保持了单链表操作的统一性\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错，只有存储结构是有序的，元素是无序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "采用链表。因为链表插入和删除操作比较方便，只需改变指针的指向即可。\n若是采用线性表，插入和删除需要依次调整目标节点之后的所有节点，时间复杂度高。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n\n\n\n\n1.可以先将栈底上面的元素删除，再删除栈底的元素\n\n\n\n\n2.存在只有一个元素的栈，这个元素也是栈底元素\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "不正确\n顺序栈指的是按存储结构按顺序，顺序栈中的元素值的大小并不是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点。如果当链表为空的时候，单链表没有带头结点，那么它的头指针就为NULL。\n2、是为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。当栈只有一个元素时，栈底元素即为栈顶元素，此时可以删除栈底元素。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "9", "answer": "需要随机访问（按脚标访问）数据的时候；\n\n\n\n\n已知最大元素数量（即最大表长）的时候；\n\n\n\n\n不需要大量插入、删除元素操作的时候。\n\n\n\n\n需要随机访问表中的元素的时候用顺序表更好。\n因为顺序表中的元素都是紧挨着排列在一起的，只要知道了第一个元素的地址，在这个地址上加上一个偏移量就可以得到另一个元素。而如果是链表的话，访问某个元素首先都要依次遍历这个元素前面的所有元素，效率是很低的。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "模拟队列：待入队元素先进入栈S1再出栈，出栈后再进入栈S2，再出栈后即得到模拟队列应得序列\n1、入队：\n#include<bits/stdc++.h> stack<int> S1,S2; int a;//待入队序列 cin>>a; S1.push(a);\n2、出队\n#include<bits/stdc++.h> stack<int> S1,S2; S2.push(S1.pop()); S2.pop();\n3、判断队列为空\n#include<bits/stdc++.h> stack<int> S1,S2; if(S1.empty()) return ture\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由题可知元素的进队序列为3、6、9、12、... 3n，\n队列先进先出的特性决定了其出队序列也必然是3、6、9、12、... 3n，\n于是元素的进栈序列和出队序列一致，也是3、6、9、12、... 3n。\n又a1=3n，由栈先进后出的特性可知，栈的操作必然是所有元素都进栈后才开始\n执行出栈操作，于是ai=3*(n+1-i).\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序亦为3、6、9、12、...、3n。而栈是后进先出的，当a1=3n时，说明最后进栈的元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "根据实际需要申请内存空间，而当不需要时又可以将不用节点空间返还给系统。在链式存储结构中插入和删除操作不需要移动元素。\n\n\n\n\n1、比顺序存储结构的存储密度大(链式存储结构中每个结点都由数据域与指针域两部分组成，相比顺序存储结构增加了存储空间)。\n\n\n\n\n2、逻辑上相邻的节点物理上不必相邻。\n\n\n\n\n3、插入、删除灵活 (不必移动节点，只要改变节点中的指针)。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少的时候，若A表所有元素都小于或者大于B表元素，则A1比较完B1～Bn后就可以了，所以是比较n次。\n最多的时候。AB两表互相交错，就要穿插重排，假设A表的每个元素都要和B表元素相比，A1与B1相比，能确定其中一个元素的位置，剩下一个则需要和另一个表中下一个元素再比较一次。所以在A或B两表的N个元素，除了最后一个元素外，每个元素都要比较两次，就是2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "等概率的前提下，平均移动个数为n/2\n若不等概率，则平均移动的元素个数为(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表的优点是无需为表示表元素之间的逻辑关系增加额外的存储空间，可以随机存取访问数据元素；缺点是增删节点不方便，表长变化较大时难以确定数组合适大小。\n链表的优点是用指针方式增删结点，操作方便；缺点是不能随机访问，增加了额外的存储空间开销。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "8", "answer": "1、较少对表进行增减删改的时候\n2、需要对表内随机某个元素进行操作时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "①单链表：不能。不知道头指针，似乎无法找到节点p的前驱节点，没办法删除。\n②双链表：可以。因为双链表的每个节点中设置了两个指针，一个指向前驱，一个指向后继，所以可以删除。时间复杂度为O(1)。\n③循环单链表：可以。循环单链表首尾相接，可以找到节点p的前驱和后继节点，从而删除节点*p。时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序为3、6、9、12、…、3n，而栈是后进先出的，当a1=3n时说明最后进栈的元素最先出栈，这样只有一种出栈序列即为3n、3n-3、…、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确的，栈每次只能把元素插入到第一个位置（栈顶），每次只能读取栈顶的元素，栈只能访问栈顶元素，即“后进先出”\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "利用两个栈s1和s2来模拟一个队列，当需要向队列中插入一个元素时\n用S1来存放已输入的元素，即S1执行入队操作。当需要出队时，则队S2执行\n出栈操作。必须先将S1中所有元素出栈并入栈到S2中，再在S2中出栈\n即可实现出队操作，而在执行此操作之前必须判断S2是否为空，否则导致顺序混乱\n当栈S1和S2都为空时队列为空。\n即：\n①对S2的出栈操作用作出队，若S2为空则先将S1中所有元素送入S2\n②对S1的入栈操作用作入队，若S1满，必须先保证S2为空，才能将S1中\n的元素全部插入S2中\n\n\n\n\n（1）出队算法\n\n\n\nint EnQ(Stack &S1,Stack &S2,Elemtype e){\n    if(!StackOverflow(S1)){\n        Push(S1,e);\n        return 1;\n    }\n    if(StackOverflow(S1)&&!StackEmpty(S2)){\n        printf(\"队列满\");\n        return 0;\n    }\n    if(StackOverflow(S1)&&StackEmpty(S2)){\n        while(!StackEmpty(S1)){\n            Pop(S1,x);\n            Push(S2,x);\n        }\n        Push(S1,e);\n        return 1;\n    }\n} \n\n\n\n\n（2）入队算法\n\n\n\nvoid DeQueue(Stack &S1,Stack &S2,Elemtype &x){\n    if(!StackEmpty(S2)){\n        Pop(S2,x); \n    }\n    else if(!StackEmpty(S1)){\n        printf(\"队列为空\");\n    }\n    else{\n        while(!StackEmpty(S1)){\n        Pop(S1,x);\n        Push(S2,x); \n    }\n    Pop(S2,x);\n}\n} \n\n\n\n\n（3）判断队列为空算法\n\n\n\nint QueueEmpty(Stack S1,Stack S2){\n    if(StackEmpty(S1)&&StackEmpty(S2)){\n        return 1;\n    }\n    else return 0;\n} \n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。栈底的位置不变，而栈底的元素可以删除。栈底元素最后被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "7", "answer": "应该使用链表来实现, 因为对链表进行增删时, 元素不需要进行移动, 只需要修改指针即可, 时间复杂度仅为O(1)\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误\n栈的出入栈顺序的有序的，但是元素大小不一定有序\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "方便在第1个位置进行插入、删除操作时同其他位置一样\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。需要连续进栈，可能一边进一边出。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "采用链式存储结构。因为链式存储结构在插入和删除数据元素时不需要移动数据元素,只需要修改结点的指针域就可以改变数据元素之间的逻辑关系。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "后一个有序表所有元素的值都比前一个大，或都比前一个小时，只要n次。\n两个有序表所有元素的值交错排列时，如2，4，6，8和3，5，7，9，要2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n\n\n\n\n2、为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n\n\n\n\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n\n\n4、对单链表的多数操作应明确对哪个结点以及该结点的前驱。不带头结点的链表对首元结点、中间结点分别处理等；而带头结点的链表因为有头结点，首元结点、中间结点的操作相同,从而减少分支，使算法变得简单，流程清晰。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "有n个节点并且高度为n，则此树每个分支结点都只有一个孩子，这个孩子可能是左孩子，也可能是右孩子，而分支结点共有n-1个，所以共有2^(n-1)个这种树。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "顺序表存储数据是提前开辟好空间，之后无法更改，存储空间连续。链表是一次开辟一个节点存储数据，后续可以再开，存储空间不连续。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "1", "answer": "Push(S,x);//元素x入栈\nPop(S,x) ;//S出栈并将出栈的值赋给x\nStackEmpty(S) ;//判断栈是否为空\nStackOverflow(S) ;// 判断栈是否满\n\n\n\n\nEnqueue ;//将元素x入队\nDequeue ;//出队，并将出队元素存储在x中\nQueueEmpty;/ /判断队列是否为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n2.单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点。因此空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现，\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2的n-1次方种二叉树\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1 队列的特点先进先出\n2 所以进队序列和出队序列相同\n3 进栈的次序为3,6,9,12...3n\n4 栈的特点是后进先出，当a1=3n说明最后进栈的元素最先出栈\n5 所以序列为 3n，3n-1...9,6,3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "等概率插入一个元素需要平均移动的元素个数是n/2\n第二问为(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "第一种情况为第一个有序表中所有元素都比第二个有序表的第一个元素小\n第二种情况为第一个有序表中所有元素于第二个表中元素交错，例如表一的元素为1 3 5 7 9，表二的元素为2 4 6 8 10\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "s2作为输入栈而存在；\n入队：利用stack的push函数将元素入队；\n出队：先将s1的元素全部压入s2,在s2利用pop函数输出；\n判断是否为空：如果说s2，s1均为空，则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "不对\n\n\n\n\n顺序栈的元素顺序只和元素的出入顺序有关，和元素的大小是没有关系的。元素值的大小是不一定有序的，主要看元素的进出顺序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "方案一：\n优点：1.基本所有运算可在O（1）内完成，效率高且操作简单\n缺点：1.空间分配小时，容易溢出。\n2.空间分配大时，由于各栈不能共享空间，容易造成浪费。\n\n\n\n\n方案二：\n优点：1.提高空间利用率，减少栈发生上溢的可能性。\n缺点：1.当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针，这一过程计算复杂且十分耗时。\n\n\n\n\n方案三：\n优点：1.多个链栈一般不考虑栈的溢出。\n缺点：1.缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "（1）优点：操作简单\n缺点：容易造成存储空间的浪费或者存储空间不够\n（2）优点：合理利用存储空间\n缺点：可能会导致错误输出其他栈的元素\n（3）优点：不存在溢出现象\n缺点：比顺序栈占用更多空间\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "使用两个栈S1,S2模拟队列：\n1.入队\n向S1输入，入栈和入队一样。\n2.出队\n让所有数据入S1后，出S1，入S2，再出S2，即完成出队。\n3.判断队列是否为空\n栈S1，S2都没有数据时队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n当发生需要比较2n-1次时，两个有序表的数据刚好是插空顺序\n\n\n当发生需要比较n次时，一个有序表的数据全大于另一个有序表的最大值，或者全部小于另一个有序表的最小值；\n\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n\n\n\n\n2、为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n\n\n\n\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n\n\n4、对单链表的多数操作应明确对哪个结点以及该结点的前驱。不带头结点的链表对首元结点、中间结点分别处理等；而带头结点的链表因为有头结点，首元结点、中间结点的操作相同,从而减少分支，使算法变得简单，流程清晰。\n\n\n\n\n对单链表进行插入、删除操作时，如果在首元结点之前插入或删除的是首元结点，不带头结点的单链表需改变头指针的值，在TurboC算法的函数形参表中头指针一般使用指针的指针(在C++中使用引用&)；而带头结点的单链表不需改变头指针的值，函数参数表中头结点使用指针变量即可，对初学者更易接受。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确，顺序栈是指利用顺序存储结构实现的栈，存储地址是连续有序的，而栈中元素的顺序是先后入栈的顺序，与元素的大小无关。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n栈底元素是我们插入的第一个元素，当我们不断得从栈顶删除元素，直到删除到栈底的时候，就可以删除栈底元素\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "0", "answer": "正确的。我理解的题目意思是栈的容量大小大于n，此时n个元素全在栈中，而栈是先进后出，那么出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。\n链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "(1)分别用多个顺序存储空间建立多个独立的顺序栈\n优点：简单易懂，操作简单\n缺点：占用空间大，易造成空间浪费\n(2)多个栈共享一个顺序存储空间。\n优点：对空间利用率更高\n缺点：操作难度较大，理解较难，当栈中元素过多时，容易出错\n(3)分别建立多个独立的链栈。\n优点：不必考虑空间问题，可随时开辟，多个独立链栈直观明了\n缺点：操作难度更大，对链表的删除插入操作需要很熟悉\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。\n栈的定义为：限定仅在表首进行插入或删除操作的线性表，栈底为表尾，因此栈底元素不可删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "（1）\n\n\n\n\n优点：便于操作，利于分开管理\n缺点：不知道栈的容量大小，若容量过大，开多个栈会造成浪费；过小，容易溢出\n\n\n\n\n（2）\n\n\n\n\n优点：相对于（1）而言节省空间，可以较灵活地操作\n缺点：操作较麻烦，空间容易发生冲突，空间过小，容易溢出\n\n\n\n\n（3）\n优点：完美做到需要多大空间便申请多大空间，空间利用率高\n缺点：操作较前两种困难，且栈中元素要以指针相链接，比顺序存储多占用了存储空间\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。当栈中只有一个元素时，该元素可称作栈底元素，其可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "n/2；(2*n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "队列全部进入栈之后才开始出栈\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "当不涉及插入和删除操作的时候，用顺序表比链表好，因为对于顺序表而言，插入和删除的时候需要移动近一半的元素，而链表的插入和删除操作只需要移动指针的指向即可。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n栈结构只允许对栈顶元素进行修改，通常是无法修改栈底元素的。\n但当栈中只有一个元素，即栈顶元素与栈底元素相同时，栈底元素便可以删除了。\n综上，该叙述有误。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "适宜采用链表。因为链表在进行插入和删除操作的时候无需移动大量元素，只需要改变相应操作节点的前驱和后继节点指针即可，效率较高，且链表逻辑上相邻节点在空间上不必相邻，在空间分配上十分灵活，适宜频繁的插入和删除操作。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不能删去；\n双链表可以删去，其复杂度为O(1)；\n循环单链表可以删去，其复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "3", "answer": "宜采用链式存储结构，因为它使线性表的插入和删除操作的 时间复杂度为O（1），而顺序存储结构的为O（n）。 2、首元结点是指链表中存储线性表中第一个数据元素的结点。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：\n不能，单链表中仅知道指针p是无法访问节点*p的前驱结点的，故无法调整前驱结点的next指针，删除操作不能执行\n双链表：\n可以，复杂度为O(1)\n循环单链表：\n可以，复杂度为O(n)，n为表的规模\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "1.方便对第一个节点进行操作。\n2.方便进行空表操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "（n-1)/2;\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "7", "answer": "不一定\n可能是先入栈在下一个元素还没有入栈的时候便已经出栈，没有考虑到一边入栈一边出栈的情况\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表通常用数组实现，无须为表元素之间的逻辑关系增加额外的存储空间，可以方便存取表中任一元素位置。但是插入和删除很不方便，效率低。且难以确定数组大小。\n链表存储中元素通过指针连接，插入和删除比较快捷，插入和删除不需要移动元素。但链表存储需要更多的存储空间，查找速度较慢。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "（1）\n优点：每个栈单独使用一个顺序存储空间，可便于操作；\n缺点：会造成空间的浪费或不足\n\n\n\n\n（2）\n优点：共享空间，可充分地利用空间；\n缺点：当栈满时，需要移动元素等操作，操作复杂\n\n\n\n\n（3）\n优点：空间较为充沛，不会产生溢出等情况；\n缺点：会多了储存指针的空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答：单链表不能做到，因为单链表不知道P的前驱，只知道P的后继，没有办法进行删除操作，P的前驱无法指向P->next;\n双链表可以做到，有P就可以知道P的前驱和后继，可以进行删除操作，时间复杂度是O(1);\n循环单链表可以做到，知道P的后继，然后可以知道P->next->next;直到找到P的前驱，其时间复杂度是O(n).\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "3", "answer": "1.适合用链表储存。因为链表个别数据的插入删除不会影响到其他数据的储存的地址和空间。\n2.链表储存空间是动态分配，不必担心数据的规模多大。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表的存储空间固定，需要提前预估开辟空间，且存储位置连续，容易对表进行遍历。\n链表不需要提前预估空间，存储数据时才申请存储空间，需要在每个单元中设置指针来表示表中元素之间的逻辑关系，增加了存储空间的额外开销\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "2的（n-1）次方\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错，当只有一个元素时，栈底元素也是栈顶元素，就可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "与待排序方向相反的时候. e.g. 假设冒泡排序的方向从大到小而输入序列的方向从小到大\n\n\n\n原\t1\t2\t3\t4\t5\n1\t5\t1\t2\t3\t4\n2\t5\t4\t1\t2\t3\n3\t5\t4\t3\t1\t2\n4\t5\t4\t3\t2\t1\n\n\n\n从第一次开始, 就会出现元素远离正确位置的现象\n\n\n\n\n而快速排序没有这种情况.\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "错误。\n当栈中只有一个元素的时候，这个元素叫做栈底元素，他可以被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "最小需要：A表所有元素都小于（或大于）B表元素\n\n\n\n\n最多需要：A、B两表互相交错\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "应该采用链式存储结构。\n因为采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。但移动指针域操作比移动元素操作花费的时间少得多。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误。栈中元素值的大小不一定是有序的，顺序栈是顺序结构实现的存储结构，栈中元素在存储结构上是有序的，对应的下标是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "错，可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误\n当栈中只有一个元素时，此时栈顶元素就是栈底元素，执行出栈操作时，就会将栈底元素删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "7", "answer": "错误，顺序栈只是对于栈大小确定，而对栈中元素大小是否有序无关，都要满足先进后出原则。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "采用链式存储结构。因为如果采用链式结构存储线性表，插入和删除操作需要从头指针起查找插入、删除结点的前驱结点，并修改这些结点的指针域，查找过程需平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均表中的一半元素。移动指针域操作比移动元素操作花费的时间少的多。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n因为栈只能在栈顶插入和删除，当我们在栈顶连续运行插入时，栈底元素就会是我们刚刚第一个插入的元素（最早被插入的元素）；当我们在栈顶连续不断运行删除时，栈底元素就会是我们最后删除的元素（最后被删除的元素）。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "在查找比较多，插入和删除的操作很少时，用顺序表比链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表可以随机访问元素，不方便删减。\n链表用指针，方便增删减改，但不能随机访问元素。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "9", "answer": "利用两个栈 S1 和 S2 来模拟一个队列，当需要向队列中插入一个元素时，用栈 S1 来存放入队的元素，即 S1 执行入栈操作。当需要出队时，则对栈 S2 执行出栈操作。由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将 S1 中的所有元素全部出栈并压入到 S2 栈中，再在 S2 中执行出栈操作，即可实现出队操作.而在执行此操作前必须判断 S2 是否为空，否则会导致顺序混乱。当 S1 和 S2 都为空时队列才为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错，可以一边进栈，一边出栈\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2\n(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "链表存储结构。因为对于顺序表而言，插入和删除的时候需要移动近一半的元素，而链表的插入和删除操作只需要移动指针的指向即可。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表的不可以，如果要删去P指向的结点，就需要知道该结点前一个结点。\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n\n\n\n\n2、为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n\n\n\n\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n\n\n4、对单链表的多数操作应明确对哪个结点以及该结点的前驱。不带头结点的链表对首元结点、中间结点分别处理等；而带头结点的链表因为有头结点，首元结点、中间结点的操作相同,从而减少分支，使算法变得简单，流程清晰。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "n/2\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "优点:每个栈用一个顺序存储空间时,操作简单.缺点:容易造成空间溢出;\n优点:充分利用空间,缺点:查询时耗长;\n优点:不用考虑空间溢出,缺点:多占用空间;\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.归并排序是多次将两个或两个以上的有序表合并成一个新的有序表。最简单的归并是直接将两个有序的子表合并成一个有序的表。归并排序最好情况下的复杂度\n为 O(n)。比如A顺序表的最大值如果比B顺序表的最小值还要小，只需要拿B的最小元素与A中所有元素比较一遍即可，后续的B的所有元素都无需在比较。\n2.最坏的情况实质上是让两指针都走完各自的链表，同时某链肯定先走完，因为一次只移动一个指针，另一个链表无论怎样都会至少少走一步，这就是2n-1的含义。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "频繁查找，插入和删除操作较少。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "因为除了根结点外。其他结点都有两个可能，所以为2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1对单链表无法将节点*p删去。\n2对双链表可以删去，利用当前元素左右指针，改变逻辑关系。复杂度为O（1）。\n3循环单链表可以删去，先将指针循环一圈到p的前一位，在改变前一位和p后一位的逻辑关系，复杂度为O（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "ai=n-ai/3+1\n原因：队列的规则是先入队的元素先出队，栈的规则是先入栈的元素后出栈，因此最后的输出序列应当是输入时的倒序。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "链式存储结构。链式结构在进行插入删除操作的时候不需要移动元素，效率高，且删除元素时释放空间方便\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前。有了头结点后，对在第一个元素结点前插入结点和删除第一个结点，其操作与对其他结点的操作统一了。带头结点时，不论删除哪个位置上的结点，用到的代码都一样；不带头结点时，删除第1个元素和删除其它位置上的元素用到的代码不同，较麻烦。\n2、头结点的存在使得空链表与非空链表的处理操作一致。单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "描述1：\n利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入栈操作。\n当需要出队时，则对S2执行出栈操作。\n由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而执行操作前必须判断S2是否为空，否则会导致顺序混乱。\n当栈S1和S2都为空时，队列为空。\n入队2：\n\n\n\n\n\n两个栈S1，S2都为空，执行入队操作，将元素直接插入S1中。\n\n\n栈S1为满，栈S2不为空，则队列为满，无法执行入队操作\n\n\n栈S1为满，栈S2为空，执行入队操作，先将栈S1中的元素逐一出栈，再逐一入栈S2；\n当S1为空时，将元素插入S1中，实现入队操作。\n出队3：\n\n\n栈S2不为空，则队首元素位于S2的栈顶（栈S1为满，S2不为空），执行出队操作，将S2中的栈顶元素出栈，实现出队操作。\n\n\n栈S2为空，栈S1为空，则队列为空，无法实现出队操作。\n\n\n栈S1不空，栈S2为空，执行出队操作时，先将S1中元素逐一从S1出栈，再逐一入栈S2，最后将S2中的栈顶元素出栈，实现出队操作。\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.表的大小比较固定\n2.涉及到的删除和插入操作较少\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.单链表：当指针p指向某节点时，但不知道其头节点，无法访问p指针指向节点的前驱节点，因此无法删除该节点；\n2.双链表：因为双链表双向连接，因此根据已知节点可以找到它的前驱和后驱，从而可以删除p节点，时间复杂度为O(1);\n3.循环单链表：根据p节点可以找到后驱节点，又因为是循环单链表，可以找到p的前驱节点，可以删去pj节点，时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "在需要访问或者是读取输出大量元素，而几乎不需要添加，删除某个元素的时候，使用顺序表比使用链表好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n因为当栈顶指向栈底的元素时，他也可以出栈\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "（1）优点：操作简单，缺点：空间大小难以控制\n（2）优点：空间利用率高，缺点：栈满时需要操作的东西很多\n（3）优点：不需要考虑溢出问题，缺点：需要额外空间存指针\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "否。因为栈有两种存储表示方法,分别为顺序栈和链式栈。顺序栈说的是存储结构，而不是元素值的大小是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3n-3i-3\n队列出队顺序和入队顺序一致，先进先出，所以出队顺序为3，6，9，……，3n\n出栈顺序和进栈顺序相反，先进的后出，所以出栈顺序为3n，3n-3，……，6，3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "等概率：n/2\n第二种：（2*n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "答：有n个节点并且高度为n的二叉树的个数是1。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.插入一个元素需要平均移动的元素个数是n/2\n\n\n\n\n2.插入一个元素需要平均移动的元素个数是(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不是，当栈除了栈底元素外还有其余元素时，无法被删除；但当栈中只有栈底元素时，栈底元素同时时栈顶元素，可以被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "4", "answer": "当线性表的数据元素在物理位置上是连续存储的时候，用顺序表比用链表好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "1", "answer": "方便运算的实现。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "采用链式存储结构。链表在插入和删除时，无需移动元素，只需要改变指针指向的地址即可，比较节省时间。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错，结构存储是顺序，值不一定\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.入队：S1来存放已输入的元素，即S1执行入栈操作来实现入队\n2.出队：由于栈是先进后出，后进先出，而队列是先进先出，后进后出，进行出队操作时，S1出栈顺序是原来出队顺序的逆序，则需先将S1的全部元素出栈后在入栈到S2，接着在对栈进行出栈操作，即可实现出队操作\n3.判断队列是否为空：当判断栈S1和S2都为空时，队列则为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "当后一个有序表比前一个的所有元素都大的时候仅需n次，若两个表所有元素交错排序时为2n-1次\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "数据规模小，需要随机读取数据时用顺序表比较好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "n/2\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "S1作输入栈，逐个元素压栈，以此模拟队列元素的入队。当需要出队时，将栈S1退栈并逐个压入栈S2中，S1中最先入栈的元素，在S2中处于栈顶。S2退栈，相当于队列的出队，实现了先进先出。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表：先开好所需的存储空间，内存空间是连续的，通过地址查找元素\n链表：边储存数据边分配存储空间，通过下一节点的地址来确定节点的位置\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "ai=3*（n+1-i），由于栈的特性，入栈出栈都是栈顶，因此当3n（最后一个元素）第一个出站时，其余元素只能按倒序出栈。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最小需要比较n次：最少的归并就是直接将两个有序的序表合并成一个有序表，只需要比较n次即可。\n最多需要比较2n-1次：最多是两个有序表刚好是插空的数据时，插入一个元素，需要和前面后面进行共两次的比较。所以需要比较2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答：(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈顶指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1：最小比较n次，考虑何时会比较n次？\n当且仅当其中一个有序表的最大值<=另一个有序表的最小值\n比如: 1 2 3 4 5 6 7 和 8 9 10 11 12 13 14\n其中1、2、3、4、5、6、7分别和8比较一次后并入新表，然后发现指针指向空，另一个表可以不用比较直接加入\n该情况下归并表的特征：有序，且前n个全为其中一个有序表元素，后n个全为另一个有序表元素\n2:最多比较2n-1次，考虑何时会比较2n-1次？\n当且仅当每个新被归并的元素交替地来自不同的有序表\n比如 1 3 5 7,2 4 6 8\n1与2比较一次，3与2、4分别比较一次，5与4、6...共比较2*4-1=7次\n该情况下归并表的特征：有序，且表中元素交替地来自不同的有序表\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以，双链表和循环单链表可以。\n双链表：O（1）\n循环单链表：O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "n/2\n（2n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "5", "answer": "适合使用链式存储结构。\n可以灵活使用内存，不会导致浪费内存。每新增一个数据开辟一个结点内存空间。\n插入删除非常灵活，只需要移动指针，并不需要大规模移动节点。\n若使用顺序存储结构，则插入元素后，要重新开辟内存空间，进行数组重定义，耗费空间时间，不够灵活。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误，顺序栈只是存储地址是连续的，和元素值没有关系\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、优点是操作简单；缺点是需要提前分配空间，容易造成空间溢出和浪费\n2、优点是可以充分利用存储空间；缺点是栈满或接近栈满时需要查询空闲空间、移动元素、修改栈底和栈项指针，操作复杂\n3、优点是不用考虑空间溢出的问题；缺点是空间占用较大\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.防止链表为空，无论链表是否为空，头指针始终指向头节点，当链表为空时，头指针指向NULL。\n2.方便在链表表头插入数据元素或删除头节点。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "2", "answer": "单链表：可以删除。将*p结点的数据和其后继结点的数据交换位置，再删除其后继结点，时间复杂度为O（1）；\n双链表：可以删除。其时间复杂度为O（1）；\n单循环：可以删除。如采用上述单链表的删除方法，时间复杂度也为O（1）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "正确。\n栈的结构就是后进先出，每次都是pop栈顶元素，如果可以随意的删除栈底元素，那就不是栈了。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "\n\n顺序表: 顺序表采用连续的空间存储数据\n\n\n优点:\n\n\n能够随机访问数据元素, 查询的时间复杂度较低(O(n));\n\n\n代码书写较为简单\n\n\n\n\n\n\n缺点:\n\n\n顺序表的大小固定, 不利于增删元素, 时间复杂度高(O(n));\n\n\n由于存储空间大小固定, 在数据量较小时, 空间浪费严重\n\n\n\n\n\n\n\n\n\n\n链表: 链表采用一组任意的存储单元来存储数据\n\n\n优点:\n\n\n增删元素仅需要改变前驱结点和后驱节点的指针地址, 不需要移动元素O(1);\n\n\n内存利用率高, 不会存在空间的浪费\n\n\n\n\n\n\n缺点:\n\n\n数据密度低, 需要额外的内存来存储指针\n\n\n遍历困难, 不能随机访问, 查询的时间复杂度为O(n)\n\n\n\n\n\n\n\n\n\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n\n\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，栈的结构是先进后出，栈底元素总是最先被插入的元素，当其他元素都被删除后，栈底元素可以在最后被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "3", "answer": "可以利用S1来进行入队操作，当需要出队时，先对S2进行入栈操作(将S1最顶上元素放入S2)，再将S1最顶上元素进行出栈操作，直到S1为空，此时S2的栈顶元素即为出队的元素。S2的栈顶元素出栈后，再将S2的栈内元素按顺序存入S1\n1、入队\n\n\n\nvoid EnterQueue(Stack *S1, Stack *S2, Element n){\n                if(S2.empty())\n        S1.push(n);\n                else\n                {\n                while(!S2.empty())\n                {        \n                                S1.push(S2.top());\n                                S2.pop;\n                }\n                S1.push(n);\n                }\n}\n\n\n\n\n2、\n\n\n\nvoid OutQueue(Stack *S1, Stack *S2){\n    if(S1.empty() && !S2.empty()){        \n       S2.pop();\n    }\n}\n\n\n\n\n3、\n\n\n\nbool QueueEmpty(Stack S1, Stack S2){\n    if(S1.empty() && S2.empty())\n        return true;\n        else\n    return false;\n}\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表不可以，双链表和循环单链表可以。时间复杂度为o(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "ai=3（n-i+1）(1<=i<=n)\n\n\n\n\n理由如下：\n因为队列是先进先出的，所以出队序列等于入队序列，即为3、6、9、12……。而栈具有先进后出的特点，所以第一个出栈的元素是3n时，表示在3n前所有的元素均已入栈，所以它们会倒序输出。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "单链表不行，双链表和循环单链表可以。双链表O（2），循环单链表O（n）+1。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "由于队列先进先出，输出顺序不变，由于栈后进先出，所以ai = 3n，3n-3 ... 9，6， 3 （1<=i<=n）\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不是，栈遵循后进先出原则，但在进栈过程中，前面的数可以随时出栈，因此不一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n顺序表的存储空间是固定的，需要在创建顺序表前就决定好需要多少空间。（而且顺序表的存储空间是连续的）\n链式表的空间没有固定，使用链表时一次只开辟存储一个节点的空间，后续还有需要可以再次开辟。\n\n\n用顺序表存储可以随机访问数据，但是如果有涉及到删除节点，用顺序表会非常的麻烦。\n链表存储数据时只能有顺序的访问数据，但如果有涉及到删除节点，用链表就很方便。\n\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "要删去节点p就需要知道节点p的前一个节点，即指向*p的节点，所以：\n单链表：不行。（指向单向）\n\n\n\n\n双链表：可以，时间复杂度O(1)。（可通过p指向的节点找到该结点的前驱节点和后继节点）\n\n\n\n\n循环单链表：可以，时间复杂度O(n)。（可以循环得到P指向的节点的前驱节点）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "宜采用链表存储。链表可以通过指针进行插入和删除操作，不需要挪动表中的其他元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "第一种情况是直接把两有序表可以直接合成一个有序表比较n次，第二种则是插空进行合成要2n-1\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "两表元素相同，排列顺序相反\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3(n+1-i)。\n因为队列是先进先出的，说明出队进栈顺序与进队序列相同，即3、6、9、12、...3n。而栈是先进后出的，当a1=3n时，说明最后进栈的元素最先出栈，则只有一种出栈序列，即3n、3(n-1)、...、9、6、3，则ai=3(n+1-i)。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1.不需要改变头指针\n2.方便在第1个位置进行插入、删除操作\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "当不涉及插入和删除操作的时候，用顺序表比链表好，因为对于顺序表而言，插入和删除的时候需要移动近一半的元素，而链表的插入和删除操作只需要移动指针的指向即可。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n\n\n\n\n顺序栈说的是存储结构是有序的，而不是元素值有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3n-3（i-1）。\n3,6,9...3n进栈后，栈顶为3n，下一个为3n-3...以此类推，ai=3n-3(i-1)。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确，顺序栈是利用一组连续的存储单元依次存放从栈底到栈顶的数据元素，地址是按顺序的，但是元素大小是无序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "顺序表：一次开辟，永久使用，空间一旦开辟，大小无法改变；数据在数学逻辑和物理逻辑上相邻。\n链表：存储数据时一次只开辟一个空间，可以不断开辟，拓展大小；数据在数学逻辑上相邻，物理逻辑上通常不相邻。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "1.单链表无法做到上述操作\n2.双链表可以，只需要O(1)的时间复杂度\n3.循环链表可以，需要O(n)的时间复杂度\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "1.操作简单，但是空间的大小不易分配合理。\n2.优点是充分利用了存储空间，缺点是一个栈满时要向左、右查询有无空闲单元。这一过程计算复杂且费时。\n3.优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1.当物理相邻同时逻辑相邻时，不需要另外的存储空间来找元素间的逻辑关系时。\n2.需要紧凑的使用存储空间时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表中的元素的存储地址是连续的，一开始就确定的表的大小，不能更改，可能造成浪费或者不够用，可以通过下标直接访问元素，但在表中插入或删除元素需要挪动表中其他元素。\n链表中的元素的存储地址是不连续的，表的大小可以随需要而更改，插入和删除元素较为方便，访问元素需要从头遍历。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "7", "answer": "前一种情况下，这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字，也就是说，两个有序表是直接可以连接为有序的，因此，只需比较n次就可将一个表中元素转移完毕，另一个表全部照搬就行了。\n\n\n\n\n另一种情况下，是两个被归并的有序表中关键字序列完全一样，这时就要按次序轮流取其元素归并，因此比较次数达到2n-1。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "错误。栈中元素值大小不一定是有序的，要看元素入栈时有无按顺序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "采用链式存储结构。\n\n\n\n\n因为采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可删除，要删除某个节点必须知道前一个节点。\n双链表可以删除。时间复杂度为O（1），通过找到该节点的前驱和后继实现\n循环链表可以删除。时间复杂度为O（n），通过找到该节点的前驱实现\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "最简单的归并需要的次数最少，即两个有序表合并起来刚好有序，如第一个表最小的数据大于第二个表的所有数据，即表1:6，7，8，表2:1,3,5，只需用表1第一个元素与表2各个元素分别比较，即比较n次。最坏的情况是两个有序表刚好是插空排序，如表1:1,3,5，表2:2,4,6，表1第一个元素只需与表2的元素比较一次，而后每个元素都需比较2次，故为2n-1\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "入队时，先入栈S1（此时为逆序），出队时，先将S1的元素出栈再入栈到S2中（此时为顺序），再出栈。如果S1和S2都为空则队列为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "用链表，及链式结构存储线性表。因为顺序表在进行插入和删除的时候得移动一定数量的表的元素，而链表只需移动指针。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "在元素的操作，元素的插入、删除和移动操作极少时适合使用顺序表,这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 O(1)；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 O(n)\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：每个栈分别有各自的顺序存储空间，操作简单。\n缺点：分配空间不足，容易产生溢出；分配空间过大，造成浪费。\n（2）优点：多个栈仅用一个顺序存储空间，充分利用存储空间，只有在整个存储空间用完时才会产生溢出。\n缺点：当一个栈满时需向左右查询有无空闲单元，若有空间需进行移动指针操作，这一过程复杂且耗时。\n（3）优点：多个链栈一般不考虑栈的溢出。\n缺点：栈中元素需要指针链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "将栈S1作为入队的空间，入栈S1即为入队，由于栈出栈顺序为入栈的倒序，因此栈S2作为出队的中间过程，S1中的元素要出栈时，先出S1，判断S2是否为空，若为空再入全部压入S2，再由S2出栈，即可保证出栈序列与入栈一致；若不为空S2中的元素须先出栈，再将S1中出栈的元素压入S2，再逐一出栈。\n判断队列为空即S1、S2两个栈都为空时，队列为空，否则队列不为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "入队：两个栈S1，S2都为空，执行入队操作，将元素直接插入S1中；栈S1为满，栈S2不为空，则队列为满，无法执行入队操作；栈S1为满，栈S2为空，执行入队操作，先将栈S1中的元素逐一出栈，再逐一入栈S2，当S1为空时，将元素插入S1中，实现入队操作。\n\n\n\n\n出队： 栈S2不为空，则队首元素位于S2的栈顶（栈S1为满，S2不为空），执行出队操作，将S2中的栈顶元素出栈，实现出队操作； 栈S2为空，栈S1为空，则队列为空，无法实现出队操作；栈S1不空，栈S2为空，执行出队操作时，先将S1中元素逐一从S1出栈，再逐一入栈S2，最后将S2中的栈顶元素出栈，实现出队操作。\n\n\n\n\n判空：两个栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表不可以，双链表和循环单链表可以，时间复杂度为O(n).\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "队列是先进先出，先进来的数字先出去，栈是后入先出,既然a1=3n，3n只能是最后入栈，那么ai=3n-i*3+3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）已有n个元素，那么有n+1个位置可以插入。位置0移动n个元素，位置1移动n-1个元素*……位置呢n-1移动1个元素，位置n不移动元素。所以总移动元素为n+（n-1）+……+1+0=n（n+1）/2；总位置有n+1个，所以平均移动的元素个数是n（n+1）/2（n+1），即为n/2个\n（2）求期望，平均元素个数为2n+1/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误的;在不限制进栈出栈时机的情况下,栈的进出顺序是任意的,例如1,2,3顺序进入栈,它的出栈顺序可以有多种,例如123,132,213,231,321\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。栈底元素不能随意删除，如果随意删除就不是栈了。删除元素应该从栈顶删，实现先进后出，后进先出。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "顺序表的好处有逻辑相邻的同时物理也相邻，不用为了表示元素间的逻辑关系而增加额外的存储空间，存储空间紧密相接很紧凑，可随机存取任一元素；\n缺点是插入、删除操作需要移动大量的元素，提前开好一个大的空间，造成浪费，表内容量扩充不易。\n链表的优点：插入或者删除元素时不需要移动元素。可以不用连续的单元来存储元素。\n缺点：需要设置指针，所以增加了额外的存储空间\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "链式存储结构。链式存储结构在对数据进行插入和删除时，只需更改目标结点的指针域而不用像顺序表那样移动整个数组。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "对n-i+1从i=1到n+1求和结果是n/2，即平均移动的元素个数为n/2；\n对((n-i)^2)/(n*(n+1)/2)从i=1到n求和结果是(2n+1)/3，即插入一个元素平均移动的元素个数为(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由题意，每一层都只有一个节点。\n∵根结点的位置固定，其余每一层的每一个节点都可以选择左偏或者右偏\n∴共有2^(n-1)个.\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "在查询操作较多, 且增删操作较少时, 能充分利用顺序表的随机访问的特性\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "可以。栈底元素可以且只能在最后被删除。删除后栈为空。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "不正确\n\n\n\n\n原因：栈底元素为第一个入栈的元素，它是最后一个出栈，并不是不能出栈\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "表的存储特点是开辟固定大小的空间进行存储，但是通常很难刚好利用完所开辟的空间，所以会造成空间浪费。并且由于计算机的储存原理的限制，我么们在创建表的时候是连续的，很容易形成碎片化的空间，从而造成空间浪费。\n链表存储时可以自由进行链表的扩充减小并且不会造成空间的浪费。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "1，在进行链表的删除、插入操作时，对第一个结点的操作更方便。\n2，有了头结点之后头指针指向头结点，不论链表是否为空，头指针总是非空，统一空表和非空表的处理。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "答：该线性表采用的是链式结构的存储方式，链式结构可以高效的对线性表进行插入和删除，而顺序表需要移动几乎一半的元素，低效且麻烦。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "1、一个表的最小元素比另一个表的最大元素大\n2、一个表的第n个元素大于另一个表的第n个元素并且小于另一个表的第n+1个元素\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "该叙述是错误的。\n因为顺序栈只是指栈的顺序存储结构，用一维数组来存储栈，栈中的元素大小不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。栈的结构是先进后出，最先进栈的在栈底，元素进栈后会压在栈顶的上面，出栈时必须要在最上面的栈顶先出去，下面的元素才可以出来，新来的总是在最上面。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "入队时，先入栈S1（此时为逆序），出队时，先将S1的元素出栈再入栈到S2中（此时为顺序），再出栈。如果S1和S2都为空则队列为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表\n\n\n\n优点\n\n\n\n\n\n随机访问速度快\n\n\n空间紧凑, 逻辑上相邻\n\n\n信息密度大, 无存储额外信息\n\n\n\n\n\n缺点\n\n\n\n\n\n表的大小固定, 无法动态调整\n\n\n空间利用率不高, 占用不必要资源\n\n\n插入和删除元素效率极低\n\n\n\n\n链表\n\n\n\n优点\n\n\n\n\n\n插入和删除元素的速度快\n\n\n离散的存储数据, 无需占用一整块内存\n\n\n可动态调整大小, 即时申请内存\n\n\n\n\n\n缺点\n\n\n\n\n\n需要存储额外的内存地址, 增加了额外的存储空间\n\n\n不支持随机访问\n\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "2^(n-1),除了叶结点以外都有两种情况\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "冒泡排序：\n例如【2，9，5，6，3】，最终序为【2，3，5，6，9】\n经过一趟冒泡排序后会变成【2，5，6，3，9】，\n5，6的位置就朝反方向移动了\n\n\n\n\n快速排序没有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "3", "answer": "错误\n栈底元素可以删除，只不过要维持栈的话，栈底不能删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "3", "answer": "应采用链式存储结构\n因为该存储结构在进行插入和删除操作时较为灵活，适用于需要大量插入和删除操作。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。栈的特点是先进后出，后进先出。在n个元素进栈之后，元素只能从栈顶出栈，因此它们的出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "宜采用链式存储结构。\n因为链式存储结构在插入和删除数据元素时不需要移动数据元素，只需要修改结点的指针域。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "如5，4，3，2，1\n快速排序也有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "错误.\n栈底的位置不可以改变, 但栈底元素是可以被修改或删除的\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "第一次情况：当前一序列的所有元素都比后一序列元素小或者大时，只需要比较n次；\n第二次情况：两个序列的顺序为乱序，比如{0，3，5}{1,2,6}，则需要比较2n - 1次；\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "当不涉及插入和删除操作的时候，用顺序表比链表好，因为对于顺序表而言，插入和删除的时候需要移动近一半的元素，而链表的插入和删除操作只需要移动指针的指向即可。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）等概率的情况下，平均要移动n/2；\n（2）若不等概率，则平均移动元素为（2n+1）/3；\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n个节点高度为n，说明每个节点只有一个孩子，可以是左孩子也可以是右孩子。\n\n\n\n\n除根节点外，剩下n-1个节点可以是左孩子或者右孩子，故每种两个选择，所以二叉树的个数为 2^（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，顺序栈是按顺序存储结构存储的，即地址是有序的，但存放的元素可以是无序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序的意思是顺序存储结构，而不代表存储元素一定有序。 栈顶元素和栈底元素有可能是冋一个元素。 栈是一种对进栈、出栈操作总次数做了限制的线性表。 对顺序栈进行进栈、出栈操作不涉及元素的前、后移动问题。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "可以。时间复杂度为O（1），O（1），O（n）.\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "不正确，理由如下：\n\n\n\n\n1、栈中元素的排列仅与入栈顺序有关。\n\n\n\n\n2、因为并不一定按元素的大小顺序入栈，所以顺序栈中元素值的大小不一定有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表会在存储数据之前开辟好空间，之后就不可再更改存储空间的大小。存储表通常用数组实现，存储数据之后方便查找定位，可以直接通过数组下标找到地址。但插入和删除不方便，除表尾位置外，其他位置的增加和删除操作都需要移动大量元素，效率低下。\n链表则可以存储一次数据申请开辟一个空间，如果后续还需要存储数据则可以再申请。但查找数据时较麻烦。而移动和删除数据时不再需要移动元素来腾出空间，但需要在每个单元中设置指针来表示元素之间的逻辑关系，增加了额外的存储空间开销。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "双链表和循环单链表能将节点*p从相应的链表中删去，时间复杂度为O(n)；而单链表不能。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "正确，不管是一次性全部出栈还是边入栈边出栈，若跟踪这n个元素，它们的出栈顺序一定是和进栈顺序相反的。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n除了根节点之外，每个结点都可以选择左偏或者右偏，一共有n-1个结点可以偏移，因此有2^(n-1)个二叉树满足条件。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "除了节点，每个节点都有两种选择，一种是作为右孩子，一种是作为左孩子，所以剩下n-1个节点都有两种选择，一共有2^(n-1)个子树满足高度为n\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2 ; (2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "8", "answer": "\n\nA表的最大值比B表的最小值还小，只需要拿B的最小元素与A所有元素比较一遍即可\n\n\n\n\n\n2.B表的元素可以平均插入A中，如A=1,3,5... B=2,4,6...\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表存储方式\n优点：\n逻辑相邻，物理相邻，无须为表示元素间的逻辑关系而增加额外的存储空间\n存储空间紧凑，可随机存取任一元素\n缺点：\n插入、删除需要移动大量的元素\n预先分配空间需按最大空间分配，利用不充分\n表容量难以扩容\n\n\n\n\n链表存储方式\n优点：\n避免了数组要求连续的单元存储元素的缺点\n在执行插入和删除操作运算时，不再需要移动元素，当元素的粒度很大时，移动元素是费时的\n缺点\n需要在每个单元中设置指针来表示元素之间的逻辑关系，因而增加了额外的存储空间。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "8", "answer": "顺序表：存储空间是连续的，通常用数组实现，可以随机访问元素，但是不方便删减，存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）\n链表：运用指针，方便操作进行增减删改，但不能随机访问元素，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "9", "answer": "由于队列是先进先出的，所以进队序列与出队序列相同，这样进栈的次序亦为3、6、9、12、... 3n，而栈是后进先出的，当a1=3n时说明最后进栈的元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、... 、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "8", "answer": "顺序表存储数据，需预先申请存储空间，然后逐一存储，数据之间紧密贴合\n链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠指针维持\n从空间利用率的角度上看，顺序表的空间利用率显然要比链表高。\n链表更适合元素的插入、删除和移动，访问元素的需求很多时使用\n数组适合访问元素的操作，元素的插入、删除和移动操作极少时使用\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "1、设置头结点之后，不论链表是否为空，头指针不会指向空，而且头结点的设置使得对链表的操作更加一致，和表中其他位置一样，统一了空表和非空表的处理。\n2、如果引入头结点，那么头结点的next始终是链表的第一个结点，在进行操作时，需要一直更新头指针的指向，引入头结点更方便对链表的删除和插入操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "栈S1作为中间栈，栈S2作为队列\n1、入队：单次输入：\n先看S2是否为空，若为空，直接入栈\n否则：\n将S2栈顶元素压入S1中直到S2为空，然后将输入压入S2中\n最后将S1栈顶元素压入S2中直到S1为空\n2、出队：直接将S2栈顶元素弹出即可\n3、判断队列为空：S2是否为空(S2.empty() == 1为空)\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "没有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "错\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.使空表和非空表处理方式统一。\n2。使头节点的操作与其他节点的操作相同\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误；\n顺序栈只是采用顺序存储结构储存元素，与栈中元素大小值是否有序无关。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "已知元素个数且需要随机访问数据元素的时候（或者不涉及到删除节点的问题）。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确\n\n\n\n\n原因：顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少的比较次数是这样一种情况：若A表所有元素都小于（或大于）B表元素，则A1比较完B1～Bn之后，直接拼接即可。\n最多比较次数的情况应该是A、B两表互相交错，此时需要穿插重排。则A表的每个元素都要与B表元素相比，A1与B1相比，能确定其中一个元素的位置；剩下一个还要与另一表中下一元素再比较一次，\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错。栈只有一个元素时可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "不需要做大量，增加，删除，更新的操作，而需要查找数据的操作较多的时候，使用顺序表，顺序表可以随时定位元素的位置，时间复杂度都是O(1)\n因为顺序表对增删的操作都需要耗费大量的时间\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少的比较次数：若A表所有元素都小于或大于B表元素，比较一下A1和B1~Bn,直接拼接就可以。\n最多的比较次数：A、B两表穿插，元素大小交错，此时需要穿插重排。则A表的每个元素都要与B表元素相比，Ai与Bi相比，一个元素的位置确定，剩下一个还要与另一表中下一元素再比较一次，也就是说在表A或表B的n个元素中，除了最后一个元素外，每个元素都要比较2次，最坏情况总共为2n—1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "错误，这里顺序的意思是顺序存储结构，而不代表存储元素的值一定有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "对在第一个元素结点前插入结点可以直接使用和原来一致的逻辑;\n删除第一个结点，与对其它结点的操作统一;\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表：缺点： 顺序表的储存空间是静态的，必须实现开辟空间，一旦开辟，储存空间的大小就固定住了\n插入删除运算不方便，除了表位的插入和删除操作外，其他位置上的元素的增删改，都需要移动大量元素\n优点： 可以方便的插在表上任意位置上的元素，不需要为表内元素的逻辑关系增加额外的空间\n链表： 缺点： 查找元素比较麻烦，时间复杂度为 O(n) ，每个元素都有一定的逻辑关系，需要额外开辟空间储存表内逻辑关系\n优点： 储存空间是动态的，不需要提前就设置好最大储存空间，增加，删除元素的操作都比较简单\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确；\nn个元素全部进栈后，只能从栈顶逐个出栈，顺序与进栈顺序恰好相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的，当链表为空的时候,带头结点的头指针就指向头结点，如果当链表为空的时候,单链表没有带头结点,那么它的头指针就为NULL。\n2、是为了方便单链表的特殊操作，能有效减少代码量，在插入在表头或者删除第一个结点时不用考虑特殊情况，删除或插入用户的第一个节点的值和删除或插入中间的值用一样的代码，这样就保持了单链表操作的统一性。\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n4、总结来说，没有头结点对第一个结点的操作大多和中间结点不太一样，每个操作都要考虑特殊情况，有头结点的话就不必考虑那么多了，还不容易出现代码错误。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误的\n顺序栈只是地址连续的，与元素大小无关，所以元素值大小不一定有序\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比如（4，3，2，1），在第一趟冒泡后为（3，2，1，4），关键字3被移动到首位，朝着与最终排序相反的方向移动。\n快速排序中没有这种现象，经过一段排序后确定的位置就是最终位置\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "无需进行查找元素或者插入、删除元素的时候。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比较n次的情况为：其中一个表的元素最大值小于另一个表的元素最小值。\n比较2n-1次的情况为：两个有序表的元素排序顺序刚好为插空顺序。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.等概率（后插），插入位置0.....n,则平均移动个数为n/2;\n2.（2n+1）/3.\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.在等概率的前提下，插入一个元素需要平均移动的元素个数是（n/2）\n2.若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数是（2n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少情况：其中一个表的最小数据大于另一个表的最大数据。\n最多情况：设k，1<k<n,对于任意满足条件的看，表1的第k个数据，大于表2的k-1数据。小于表2的第k的数据。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误。栈底元素可以删除，一般来说，删除前需要判断栈是否为空，若不为空栈，一般都可以删除元素。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "顺序表适宜做查找等静态操作。若得知线性表的大致长度、且主要操作是查找元素，插入，删除，更新操作少的时候适宜用顺序表。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1、存储空间可知，无须预先估计分配表的大小；\n2、删除，插入的操作较少的数组\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "查询操作多，插入，删除，更新操作少的数据适合用顺序表。\n因为顺序表可以随机定位数据，而链表不能；顺序表对于插入和删除操作，需要消耗大量时间和空间。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1 平均移动[0+1+……+(N-1)]/N=(N-1)/2\n\n\n\n\n2 （2n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "方案（1）\n优点：操作简单方便。\n缺点：顺序栈空间预先确定，易造成空间浪费或堆栈溢出，且各个栈不能共享空间。\n\n\n\n\n方案（2）\n优点：各个栈可以共享空间，空间利用率提高，不易造成空间过多的浪费。\n缺点：每次进栈前要检查是否有剩余空间，比较费时。\n\n\n\n\n方案（3）\n优点：空间动态分配，用多少就分配多少，且没有限制大小，只要还有空间就可以继续进栈，不易出现溢出的情况。\n缺点：需要增加额外的空间开销来表示元素间的逻辑关系，空间利用率降低。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。\n栈只能在栈顶插入和删除，当我们在栈顶连续不断运行删除时，栈底元素就会是我们最后删除的元素。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "1.n/2;\n2.(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：不能将指针p从链表中删去，因为不知道头指针，所以无法访问到节点p的前驱节点，也就无法删除。\n双链表：可以删去，可以访问到p的前驱节点。时间复杂度为O(1)。\n循环单链表：可以删去，可以不断指向下一个指针，访问到p的前驱节点。时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "1 当链表为空，头节点为NULL，链表不为空，头节点则不为NULL。这样无论如何，头指针都可以指向头节点。减少bug\n2 可以轻易判断该链表是否为空，只需要看头节点是否为NULL\n3 可以用低复杂度处理一些特殊操作，头部插入，删除等。\n4 头节点方便遍历使用，查找定位比较方便。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由于队列是先进先出，且由出栈时a1=3n，所以可知进栈的顺序为3、6、9、12、...3n。由于栈是先进后出，所以出栈的顺序为3n，3n-3，...，12、9、6、3.\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了容易产生溢出，分配空间大了容易造成浪费，各栈不能共享空间。\n（2）优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左右查询有无空闲单元。如果有，则要移动元素和修改相应的栈底和栈顶指针。当接近栈满时，要查询空闲单元，移动元素和修改栈顶和栈底指针，这一过程计算复杂且耗时。\n（3）优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相连接，比顺序存储多占用了存储空间，\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "链式存储，不要求逻辑上相邻的元素物理上相邻，便于插入或删除\n插入和删除操作是从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；\n而顺式连接的时候平均要移动表中的一半的元素\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "较少对元素进行增删，需对表内随机元素进行操作时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表的存储空间是静态分配的，在程序执行之前必须明确它的存储规模，它不可以动态地增加长度；而链表的存储空间是动态分配的，可以动态增加长度；\n顺序表存取速度高效，是直接通过下标来直接存储的，但插入和删除操作较慢；\n而链表插入和删除的速度较快，只需要改变指针的指向就可以了；\n顺序表内存地址是连续的，而链表的内存地址不连续；\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "ai=3n、... 、12、9、6、3\n因为一个队列出队是从队首出列的所以进入队列的顺序是什么，出列的顺序一样；\n然后进入栈中，栈的特点为先入后出，所以是逆序出栈的\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "因为队列是先进先出的，所以出队顺序和进队顺序相同，则进栈顺序是3、6、9、12、...、3n。\n因为栈是后进先出，又因为a1=3n,所以只存在一种出栈顺序，3n、3n-1、...9、6、3。\n所以ai=3*（n+1-i）；\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "因为栈和队列的输出方向相反，队列出队为先进先出，，栈出栈为先进后出\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "1、用S1执行入队操作，先将全部数据存放到S1，再将全部数据从S1出栈，放入S2。\n2、用S2执行出队操作。出队时，若S2不为空，则将S2的栈顶弹出即可。\n3、若S1和S2都为空，则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "设S1为入队栈：负责接收入队元素并将元素出栈传给S2\nS2为出队栈：负责接收S1传入数据并实现出队\n1、入队\n元素传入S1，再将元素出栈并存入S2\n\n\n\n\n2、出队\n从S2出栈\n\n\n\n\n3、判断队列是否为空\n判断S1和S2是否都为空，都为空则队列为空，否则不为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "比较n次: 当一个表的最大值小于另一表的最小值时，只需比较n次，即只需将一个表的n个元素同另一表的最大值(或最小值)比较就可。\n\n\n\n\n比较2n-1次: 当一个表的所有元素都需插入另一表的相邻2个元素之间(除表首或表尾元素)时，需比较2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小易溢出，分配空间大易浪费，不能实现多个栈共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n\n\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相连接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。例如进栈序列为123，出栈的序列可以是132\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "1可以直接初始化为NULL，并且可以对链表操作前可以通过检测头节点是否为空来判断链表是否为空。\n2对链表进行搜索时可以直接利用头节点开始向后搜索。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "利用两个栈s1和s2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入队操作。当需要出队时，则队S2执行出栈操作。必须先将S1中所有元素出栈并入栈到S2中，再在S2中出栈即可实现出队操作，而在执行并入操作之前必须判断S2是否为空，否则导致顺序混乱。当栈S1和S2都为空时队列为空。\n即：\n\n\n\n\n\n对S2的出栈操作用作出队，若S2为空则先将S1中所有元素送入S2\n\n\n对S1的入栈操作用作入队，若S1满，必须先保证S2为空，才能将S1中的元素全部插入S2中\n\n\n当栈S1和S2都为空时队列为空\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "顺序表的存储空间是静态分配的，空间一旦开辟后期无法改变大小；链表存储时一次只开辟存储一个节点的空间，后期还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "不正确,如果要进栈和出栈顺序相反需要当所有元素进栈后再出栈，但是元素在进栈后随时可以出栈。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "错误的。\n\n\n\n\n原因：栈底的位置是不动的，但是栈底元素是最后被删除的元素。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "7", "answer": "宜采用链式存储结构，因为链式存储结构通过改变指针来进行插入与删除，不需要移动节点，方便快捷\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "错误，大小无序，但出栈遵循，先进后出\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "利用两个栈 S1 和 S2 来模拟一个队列，当需要向队列中插入一个元素时，用栈 S1 来存放入队的元素，即 S1 执行入栈操作。当需要出队时，则对栈 S2 执行出栈操作。由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将 S1 中的所有元素全部出栈并压入到 S2 栈中，再在 S2 中执行出栈操作，即可实现出队操作，而在执行此操作前必须判断 S2 是否为空，否则会导致顺序混乱。当 S1 和 S2 都为空时队列才为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "入队时，先入栈S1，此时为逆序，出队时，先将S1的元素出栈再入栈到S2中，此时为顺序，再出栈。如果S1和S2都为空则队列为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "当所存储的数据所需空间大小已知时；不需要遍历所有数据来找到所需数据时；\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "当线性表很少进行删除和插入操作，或者在尾部进行时，使用顺序表更好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "\n\nn次\n每一个有序表都比前一个有序表值大或者值小\n\n\n2n-1次\n每一个有序表的元素都有比前一个有序表大或小的元素\n\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少：归并排序基本思想 :归并排序是多次将两个或两个以上的有序表合并成一个新的有序\n表。最简单的归并是直接将两个有序的子表合并成一个有序的表。归并排序最好情况下的复杂度\n为 O(n)。\n\n\n\n\n最多：最多的比较次数是当两个有序表的数据刚好是插空顺序的时候，比如：第一个序列是1,3,5，第二个序列是2,4,6，把第二个序列插入到第一个序列中，先把第二个序列中的第一个元素2和第一个序列依次比较，需要比较2次（和1，3比较），第二个元素4需要比较2次（和3,5比较，因为4比2大，2之前的元素都不用比较了），第三个元素6需要比较1次（只和5比较），所以最多需要比较5次。即2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "入队操作\n\n\n\n\n\n两个栈S1，S2都为空，执行入队操作，将元素直接插入S1中。\n\n\n栈S1为满，栈S2不为空，则队列为满，无法执行入队操作。\n\n\n栈S1为满，栈S2为空，执行入队操作，先将栈S1中的元素逐一出栈，再逐一入栈S2；\n当S1为空时，将元素插入S1中，实现入队操作。\n  出队操作\n\n\n\n\n\n栈S2不为空，则队首元素位于S2的栈顶（栈S1为满，S2不为空），执行出队操作，将S2中的栈顶元素出栈，实现出队操作。\n\n\n栈S2为空，栈S1为空，则队列为空，无法实现出队操作。\n\n\n栈S1不空，栈S2为空，执行出队操作时，先将S1中元素逐一从S1出栈，再逐一入栈S2，最后将S2中的栈顶元素出栈，实现出队操作。\n判空操作\n两个栈S1和S2都为空时，队列为空。\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1入队：若S1为还没满，则入栈S1\n若S1满了，S2为空，则S1出栈后入栈S2\n若S1满了，S2不为空，则栈满。\n\n\n\n\n2出队：若S2不为空，则出栈S2\n若S2为空，S1不为空，则出栈S1，再入栈S2\n\n\n\n\n3判断队列是否为空 ：若S1,S2都为空，则\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "因为采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入栈操作。\n当需要出队时，则对S2执行出栈操作。\n由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而执行操作前必须判断S2是否为空，否则会导致顺序混乱。\n当栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表可以随机访问元素，当时不方便删减，\n链表运用指针，方便操作进行增减删改，但不能随机访问元素\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "7", "answer": "宜采用链式存储结构。\n链表中的逻辑上相邻的元素，其对应的存储位置是通过指针链接，所以每个结点的存储位置可以任意，没有相邻的必须性，进行插入和删除操作时，只需修改相关结点的指针域，更加快捷，时间复杂度更小。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2。\n（2n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "有2的（n-1）次方个；\n因为根节点为确定的，只有一个，而子节点开始，可为右节点，也可为左节点，故为1 * 2 * 2 ...=2的n-1次方\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "当某一个有序表的元素全部大于另一个有序表的时候. 有最优情况，即需要比较n次；\n当两个有序表的元素交错排列时。需要比较2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错，顺序栈是用顺序结构存储实现的，其中的元素值得大小不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确，顺序栈是指用顺序存储的结构实现栈，与元素值是否是有序的无关。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "已知需分配空间的大小，需要随机访问、存取、修改表中任一元素。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "对于单链表不可以；对于双链表可以，其时间复杂度为O(1)；对于循环单链表可以，其时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "最小情况是，两个有序表刚好可以首尾相接连一起，b序列的最小值比a序列的最大值大；\n最大情况为，一序列刚好与另一序列穿插\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，因为这时所有元素都已经入栈，只能是栈顶的元素先出栈，后进的先出，所以它们的出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "若经常对表遍历的情况下，使用顺序表比链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1)\n队列遵循先进先出，后进后出；栈遵循先进后出，后进先出\n设队列进队序列为3、6、9、12、... 3n，设为b1，b2...,bn,\n则bn=3*n\n出栈时按bn,…b2,b1的顺序输出，则ai=b(n-i+1)\n\n\n\n\n所以ai=3*(n-i+1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一点答案：错误\n\n\n\n\n第二点答案：顺序栈是指顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "较少使用插入和删除操作时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。\n只有当n个元素连续进栈后，它们的出栈顺序和进栈顺序一定正好相反。\n如果n个元素不是连续进栈，进栈部分元素后可以出栈部分元素再进栈剩余元素，那么最后的出栈顺序和进栈顺序就不正好相反了。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，考虑一边入栈一边出栈的情况，如入栈123，可以先入栈12，再出栈2，再入栈3，再出栈31，最后的输出就是231，而不是321。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "ai=3(n-i+1)\n原因：3、6、9、12、... 3n进队后出队顺序为3、6、9、12、... 3n，进栈顺序3、6、9、12、... 3n，出栈顺序3n、3（n-i+1)、... 3，其中(1≤i≤n)\n\n\n\n\n，\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "采用链式存储结构。\n因为链式结构插入和删除不需要频繁移动大量数据。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.可以让任何元素结点都有前驱结点，不用对表头进行特殊处理。若链表没有头结点,则首元素结点没有前驱结点,在其前插入结点或删除该结点时操作会复杂些。\n2.对带头结点的链表,表头指针是指向头结点的非空指针,因此空表与非空表的处理是一样的。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "个数是2^（n-1）个\n因为除了根节点之外，每个节点都有两种状态可以选，左偏或者右偏\n所以剩下n-1个节点都有两种选择，所以是2^（n-1）个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "\n\n比较n次：若是表均为从小到大排列的有序表，第二张表的第一个值大于等于第一张表的最后一个值；若是表均为从大到小排列的有序表，第二张表的第一个值小于等于第一张表的最后一个值\n\n\n比较2n-1次：两张子表相同位置的值，若一张表的值大于另一张表，那么另一张表的下一位置的值大于这张表这一位置的值（如：135与246）\n\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "该线性表宜采用链式存储结构。因为链式存储结构在插入和删除数据元素时不需要移动数据元素,只需修改结点的指针域就可以改变数据元素之间的逻辑关系。比顺序表方便且耗时少。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "\n\n\n第一问：平均移动的元素个数为（n+1）/2.\n\n\n\n\n\n\n第二问：平均移动的元素个数为（2n+1）/3.\n\n\n\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1 、有了头节点，对在表的第一个元素节点前插入节点和删除第一个节点，其操作和其他位置的节点的操作相同。\n2、统一空表和非空表的操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "如何使用：将所有元素储存在S1，只在需要获取队列头元素或出队时使用S2辅助S1即可。\n1、入队：直接将所有需要入队的元素按顺序压入栈S1。\n2、出队：先将S1内各元素弹出，同时将弹出的元素压入S2，这时S2栈顶元素就是队列首元素，再按顺序把所有需要出队的元素从S2弹出（出队），最后将S2内的所有元素弹出，并压回S1。\n3、判断队列是否为空：只需判断S1是否为空，若S1为空，则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确的。元素进栈后，都是先进后出，因此它们的出栈顺序和进栈顺序一定正好相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "①输入数据为5,4,3,2,1时，若进行升序排列，则4,3两个元素在第一趟排序中朝着与最终排序相反的方向移动【最终序列1,2,3,4,5，第一趟排序后序列：4,3,2,1,5】；\n②快速排序中有这种现象。输入数据为5,2,1,3,4时，若选5作为第一趟排序的基准，则第一趟排序后，序列变成4,2,1,3,5，则4朝着相反方向移动了【最终序列1,2,3,4,5】。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "错误的。\n\n\n\n\n原因是：栈中的各个元素顺序是按进栈次序排序的，不是按照元素值的大小排序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误。\n\n\n\n\n堆栈时元素入栈有顺序，但是元素值的大小不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "pow（2，n-1）；\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "举例：1 9 8 3 4中，在9向后移动时，8将向前移动一格。\n快速排序中没有这种现象。因为其将数据按中位数分为两部分后再排序，小的数字会一直往前移，而较大数字向后移。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "宜采用链式存储结构。\n原因：\n1.顺序表在进行插入和删除操作时，平均需要移动半个表长，对于n个元素的线性表若采用顺序存储结构，平均时间复杂度为(n+1)/2。\n2.链表在进行插入和删除操作时，只需修改相关节点的指针域即可，不需要移动线性表，节省了大量时间。\n因此，若频繁地对一个线性表进行插入和删除操作，宜采用链式存储结构。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是n/2。\n\n\n\n\n若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数是n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3（n-i+1）\n\n\n\n\n3n为最后一个入队，所以也是最后一个出队，即最后一个入栈，如果3n为第一个出栈的，则说明比3n先入栈的元素都还没有出栈，所以出栈顺序为入队顺序的倒序。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "都可以删除\n双链表时间为O(1)\n单循环链表为O(n)\n单链表为O(1)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "队列是先进先出的，进队序列和出队序列相同，进栈的次序亦为3、6、9、12、...、3n。而栈是先进后出的，当a1=3n时，说明最后进栈的元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "一：顺序表的特点是逻辑上相邻的数据元素，物理存储位置也相邻，并且，顺序表的存储空间需要预先分配。\n它的优点是：\n　　（1）方法简单，各种高级语言中都有数组，容易实现。\n　　（2）不用为表示节点间的逻辑关系而增加额外的存储开销。\n　　（3）顺序表具有按元素序号随机访问的特点。\n缺点：\n　　（1）在顺序表中做插入、删除操作时，平均移动表中的一半元素，因此对n较大的顺序表效率低。\n　　（2）需要预先分配足够大的存储空间，估计过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。\n二、在链表中逻辑上相邻的数据元素，物理存储位置不一定相邻，它使用指针实现元素之间的逻辑关系。并且，链表的存储空间是动态分配的。\n链表的最大特点是：\n　　插入、删除运算方便。\n缺点：\n　　（1）要占用额外的存储空间存储元素之间的关系，存储密度降低。存储密度是指一个节点中数据元素所占的存储单元和整个节点所占的存储单元之比。\n　　（2）链表不是一种随机存储结构，不能随机存取元素。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "采用链式存储结构，因为这种方法通过改动指针来进行插入和删除，不需要移动节点，更方便快捷\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "顺序表的特点：存储速度快，可以通过下标来赋值，插入和删除\n链表存储的特点：无须为表示元素之间的逻辑关系增加额外的存储空间，可以方便随机存取表中任意位置的元素\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "不正确。\n顺序栈表示用顺序存储结构实现栈，不是表示栈中存储的元素有顺序\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序亦为3、6、9、12、…、3n，。而栈是后进先出的，当a1=3n时说明最后进栈的元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、…、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "依题意，对于n，满足：2^n -1=n\n因为n=1时，等式成立;\nn>1时，都有2^n -1>n\n所以，有n个节点并且高度为n的二叉树的个数为1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "使用链式存储结构，它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错。只有在一次性将n个元素全部入栈的时候才成立。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表存储方式一般采用数组实现，能够随机访问表内数据，逻辑相邻即物理相邻，无需为表示元素逻辑关系增加存储空间，存储空间紧凑，缺点是大小固定容量难以扩充需预先按最大空间分配，数据增删和移动不方便；链表存储方式一般采用指针实现，无法随机访问表内数据，需要额外空间来表示元素间逻辑关系，但是数据移动和增删方便，可以动态地分配内存。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是存储数据之前先开辟好足够的存储空间，空间一旦开辟后期基本无法改变大小。而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "错误。栈底元素可以删除。当栈中只有一个元素，该元素即为栈底元素，此时top指向0。将栈底元素弹出后，top指向-1，此时栈为空。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "1.已知数据范围\n2.需要把数据存到连续的内存空间中\n3.频繁使用查询数据\n4.很少用到插入或删除数据时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "防止单链表是空的，当链表为空的时候，带头结点的指针就指向头结点\n操作更统一更方便\n减少程序的复杂性\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表无法删除，双链表和循环单链表可以。双链表的时间复杂度为O（1），循环单链表的时间复杂度为O（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "\n\n\n在a（i）后插入平均需要移动n-i个元素\n\n\n\n\n\n\n平均需要移动（n-i）（2（n-i）/n/(n+1））\n\n\n\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，元素入栈和出战遵循先进后出的原则，所以出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.顺序表的储存空间是静态分配的，不宜用在灵活储存数据的地方，需事先确定储存规模的大小，易占空间，而链表的储存室动态分配的，可以根据需要增加表长，不需要的元素可以将其所占空间释放，节约空间\n2.顺序表易实现，在各高级语言都有运用，而链表较不易实现，部分语言不支持指针类型数据\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "当线性表很少进行插入和删除操作，或者插入和删除总是在尾部进行，或者需要随机访问表中元素时，使用顺序表比链表好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答案为 ：2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)\n优点：顺序栈用一个顺序存储空间，操作更简单。\n缺点：不好分配空间，如果分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，而且各栈不能共享空间。\n(2)\n优点：多个栈用一个顺序存储空间，充分利用了存储空间。\n缺点：当快要栈满时操作复杂且十分耗时。当一个栈快满时要向左、右查询有无空闲单元。如果有空闲空间，需要移动元素和修改相关的栈底和栈顶指针。当快要栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针。\n(3)\n优点：一般不考虑栈的溢出。\n缺点：比顺序存储多占用了存储空间，因为栈中元素以指针相链接。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "1", "answer": "方便运算的实现\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表：通常用数组实现，存储空间是连续的。插入、删除操作需要移动大量的元素，表容量难以扩充。\n\n\n\n\n优点：逻辑相邻，物理相邻\n无须为表示元素间的逻辑关系而增加额外的存储空间\n存储空间使用紧凑\n可随机存取任一元\n\n\n\n\n链表：存储空间是不连续的，每个元素通过指针连接起来的，正好不顺序表相反，查找比较耗时，但增加删除元素比较快，可在常数时间内完成。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "1.顺序栈的元素值到大小不一定有序\n可以是 1 2 3 4 5 6\n也可以是 1 4 2 3 6 5\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。栈遵循先进后出、后进先出的规则，因此n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答: 错误. 顺序栈指的不是元素值的大小有顺序, 而是栈存储采用顺序结构存储, 与元素的值的大小无关\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，栈的结构是先进后出，出栈顺序与进栈顺序正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点：每个栈仅用一个顺序存储空间时，操作简单。缺点：不易控制，分配空间小了，容易产生溢出，分配空间大了，容易造成浪费\n(2)优点：充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时，分配空间操作很复杂\n(3)优点：多个链栈一般不考虑栈的溢出。缺点：栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1、可以简化在表首进行插入与删除等边界情况处理。\n2、防止单链表是空的。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "对于链式储存结构，如果要删除某一个节点，必须知道他的前节点，和后节点的信息，对于单链表而言，头指针是没有前驱节点的，如果将*P删除，就会失去链表的位置\n而对于双链表和循环链表可以，因为，双链表和循环链表都可以知道当前节点的前节点和后节点的信息，双链表是有储存前驱的信息的，因此其删除的时间复杂度是O(1)\n而循环链表需要遍历一遍才能获取前驱节点的信息，因此时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "错误。在元素进栈之后，可以随时进行出栈的操作，进行出栈的规则遵从先入后出，因而出栈的顺序不一定于进站顺序相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表的不行，如果要删去P指向的结点，就需要知道该结点前一个结点。\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "答：队列的特点是先进先出，进队序列为3、6、9....3n，出队顺序也为3、6、9....3n，所以进栈顺序为3、6、9....3n，所以栈底是3，栈顶是3n,若a1=3n，显然ai=3;\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "2", "answer": "顺序表的储存空间比较固定\n链表的储存空间可以在需要时再开辟\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "\n\nn/2\n\n\n（2n+1）/3\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。\n缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。\n缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。\n缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "平均需移动的元素个数分别为n/2和（2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "因为队列是先进先出原则，所以出队列的顺序和进队列的顺序相同为3、6、9、12、... 3n，所以进栈顺序也为3、6、9、12、... 3n。3n在栈顶，所以出栈时a1为3n。\n且出栈顺序为3n、...、12、9、6、3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "举个例子，3个数据的线性表,假设插入数据是m,那么可能的插入是\n1,m<a1,移动3个\n2.m<a2,移动2个\n3.m<a3,移动1个\n4.m>a3,移动0个\n共移动:0+1+2+3=6\n插入次数:4\n平均移动步数：6/4=1.5\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1.方便首元素的增删\n2.作为第一个指针可以起命名作用\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "平均移动的个数是 1/2 * (n+1)^2 / n 即 O(n).\n(2)为n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "8", "answer": "对于方案（1）：\n优点：\n1.直观、易懂，进行代码实现时操作简单。\n缺点：\n1.需要声明多个栈的结构，即需要使用多个顺序存储空间，当栈所需要容纳的元素较多时，对于空间比较浪费。\n\n\n\n\n对于方案（2）：\n优点：\n1.当只有两个栈共享一个顺序存储空间时，有效的利用了存储空间。\n缺点：\n1.当一个算法中需要建立两个以上的栈时，比较难在多个栈共享一个顺序存储空间时保证空间的利用率较高。\n2.多个栈共享一个顺序存储空间的操作相对比较复杂，易错。\n\n\n\n\n对于方案（3）：\n优点：\n1.使用链栈而非原来顺序存储的堆栈，不需要开辟一系列顺序存储空间，不会造成空间浪费的情况。\n缺点：\n1.建立多个独立的链栈，使用指针进行操作，操作比较复杂，容易出错。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "7", "answer": "ai=3*（n-i)\n因为队列的特点是先进先出，栈的特点是后进先出\n那么该序列将按照3、6、9、12、···3n的顺序出队并入栈，出栈则是按照相反的顺序3n、···12、9、6、3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "对，栈每次只能把元素插入到第一个位置（栈顶），每次只能读取栈顶的元素，栈只能访问栈顶元素，即“后进先出”\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.顺序表的储存空间是静态分配的，链表储存的储存空间是动态分配的。顺序表在使用前需要知道储存数据的规模，从而准备足够储存空间，而链表储存不需要。\n2.顺序表大多都是由数组组成的，其相邻数据分配的内存空间是连续；链表大多数是由指针连接构成的，相邻数据分配的内存是不连续的。\n3.顺序表中储存数据的类型一般是相同的，链表储存中的数据类型是可以不同的。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "单链表不可以；双链表可以，时间复杂度为O(1)；循环单链表可以，时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "1、对线性表的长度或存储规模难以估计时\n2、查询操作多，插入，删除，更新操作少的数据适合用顺序表，因为顺序表可以随机定位数据，而链表不能；\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "（n+1）/2\n（2*n+3）/2\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：操作简单；缺点：容易造成空间浪费，分配空间变小且各栈无法共享空间。\n（2）优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n（3）优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "就顺序表和链式结构方面考虑，应该选择链式结构。\n从空间方面考虑，频繁插入和删除意味着长度是不确定的，如果采用顺序表，要预先跟系统申请大量空间，但可能造成浪费，而链式存储的空间可以动态申请，俗话说就是“要多大有多大”，不会浪费也不会不够。\n从时间方面考虑，顺序表无论是插入还是删除平均需要移动表中一半元素，而链式表只需要修改指针，时间复杂度最好可以做到O（1）（这么说是因为还要看需操作的元素是怎么给出的）。\n\n\n\n\n\n\n问题是这么回答的，但老师我有个疑惑：作业的第一题我用链表实现，小伙伴们用数组模拟暴力查找，测了一下自己造的数据，指针用了大概1s多，数组只用了0.8s，是不是因为数据量还不算太大，或者偶然性？我一直以为链表会更快一点。还是说，因为数组的内存是连续的，其实底层实现起来，会比指针这种不知道分布在哪里的来得快?\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表无头指针无法删去，无时间复杂度。\n双链表找到前后驱，时间复杂度o（1）。\n循环链表，o（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "对于有n个节点并且高度为n的二叉树，可知除了叶子节点外，每个节点都有且仅有1个孩子，且每个有孩子的节点的孩子有2种情况，又因为有孩子的节点个数为n-1，因此这种二叉树的个数总共有2^(n-1)个。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "已知数据量，删除插入移动等操作少。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表：在存储数据时会一次性开辟所需的存储空间，可以随机访问数据元素；缺点是增删节点较为麻烦；\n链表：存储数据时一次只开辟一个节点所需的物理空间；不能随机访问数据元素，可以通过指针增删节点，操作方便。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "7", "answer": "利用两个栈s1和s2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入队操作。\n当需要出队时，先将S1中所有元素出栈并入栈到S2中，再在S2中出栈即可实现出队操作\n使用empty（），判断其是否为0，为0就是空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表储存空间是连续的，并且在生成顺序表的同时就确定了表的空间，后期无法更改。而链表不是连续的，且每次存储数据时开辟一个节点，空间可以在存储的过程中不断扩大。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "不涉及插入和删除操作的时候\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "(1)优点:操作简单,容易区分,代码好写;缺点:分配空间困难,空间利用率低,时间复杂度高;\n(2)优点:节省了空间;缺点:代码稍微复杂,需要判断栈空间满的临界条件,需要操作耗时;\n(3)优点:时间复杂度低,空间利用率高,不考虑溢出;缺点:需要建立链表,代码复杂。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "0", "answer": "（1）（n+1）/2；\n（2）(n^2+(n-1)^2+....+1)2/(n^2(n+1));\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不行，双链表和多链表可以时间复杂度为o(1),o(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "正确。当全部元素进栈后，其在栈中的排序已经固定，先入栈的元素在栈底，后入栈的元素在栈首，底下的元素必须等上面的元素出栈后才能出栈，所以出栈顺序必然与入栈顺序相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "需要随机访问数据的时候\n不需要大量插入和删除元素的时候\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n方案一的优点是操作简单可以随机访问。缺点是分配空间固定，空间大当数据较少时容易浪费内存，空间小当数据较多时容易内存溢出。\n\n\n方案二的优点是充分利用了存储空间，缺点是实现起来较为繁琐复杂。\n\n\n方案三的优点是不用考虑分配空间的问题，缺点是占用的存储空间比前两种要稍微多一些。\n\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表可以随机访问元素，当时不方便删减，链表运用指针，方便操作进行增减删改，但不能随机访问元素。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "2的n-1次方\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "链表，如果用顺序结构存储，需要移动比较多的元素，耗费更多时间，链表只需改变前后指针域，不需要移动结点\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表：顺序表存储数据要预先申请一定的空间，然后在此空间中，数据按照顺序逐个存储，数据与数据之间紧密贴合，不留空隙。\n链表：在要存储数据的时候才申请空间，数据之间靠数据元素的指针维系逻辑关系。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "ai=3（n-i+1）\n因为队列是正常的先进先出，所以进队顺序和出队顺序是相同的。但进入了栈，栈是后进先出，当a1=3n时，说明当全部元素进栈后才开始出栈，所以队列最后的变到了最前面，并开始3n、3(n-1)、……12、9、6、3依次输出。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1、入队：使用栈S1进行元素入栈。\n2、出队：使用S2作为出栈队列，将S1的元素出栈并入栈进S2（直到S1已出栈到要出队的元素为止），在S2将要出队的元素出栈。\n3、队列为空：当S1、S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "使用链表进行存储。\n链表的插入和删除操作的时间复杂度都为O(n);\n而若使用顺序表，其时间复杂度为O(n)，但移动指针域的时间比移动元素的时间少\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表存储方式就是数据分配连续的存储单元,数据元素按照逻辑顺序可以依次存储至相应存储单元里面,从而使逻辑相邻的数据元素在物理层面上也相邻,由此能够实现随即访问线性表中的数据元素,数据访问的时间复杂度为O(1)。\n而链表存储方式分配的存储单元是可以不连续的,通过每个结点的指针域来表示数据元素之间的逻辑关系,因此只能顺序访问线性表中的数据元素。数据访问的时间复杂度为O(n)。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "ai=3n-3i+3\n队列为先进先出，所以出队后顺序不变，即入栈顺序为3、6、9、...、3n。而栈为先进后出，当最先出栈的为3n时，说明全部数据都入栈了后才出栈，因此出栈顺序与入栈顺序相反，为3n、...、9、6、3。所以ai=3n-3i+3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "s1作为入队栈,s2作为出队栈,如果要入队，首先判断s2是否为空,如果为空，那么直接在s1进行入栈操作，如果s2不为空，要先将s2的元素依次出栈放到s1中，在将元素入队\n如果要出队，要先判断s1是否为空，如果s1为空，s2直接弹出一个元素，如果s1不为空，那么要先将s1的元素倒入s2中再弹出一个元素，当两个栈都是空的时候，队列就是空的\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "①在等概率的前提下，插入一个元素需要平均移动的元素个数为：(n-1)/2；\n②若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数为：第i个元素需要移动的次数为2(n–i)2，所以平均移动元素个数为2(n–i)2/n(n+1)【i从0到n求和】 = 2(n+1)/3个。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序亦为3、6、9、12、…、3n，。而栈是后进先出的，当a1=3n时说明最后进栈的元素最先出栈\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、在单链表中：若指针p指向某结点时，能够根据该指针找到其直接后继，能够顺后继指针找到p结点后的结点。但是由于不知道其头指针，所以无法访问到p指针的结点的直接前驱。因此无法删去该结点。\n2、双链表中：由于这样的链表提供双向指针，根据p结点的前驱指针和后继指针可以查到其直接前驱和直接后继，从而可以删除该结点。其时间复杂度为O（1）。\n3、单循环链表：根据已知结点位置，可以直接得到其后相邻的结点位置，又因为是循环链表，所以我们可以通过查找，得到p结点的直接前驱。因此，可以删去p所指结点，其时间复杂度为0（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "顺序表存储数据实行的是 一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n因此若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "采用链式结构存储线性表，因为当进行插入和删除时，不再需要移动元素来腾出空间或填补空缺，较为方便，快捷。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "对\n\n\n\n\n因为栈的工作性质就是先进后出，后进先出。\n\n\n\n\n所以他们出栈的顺序一定和他们入栈的顺序相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "初始为4 3 2 1，冒泡排序开始第一趟 3 2 1 4，3向前移动了。快速排序中没有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "应该采用链式存储结构，在链式存储结构中插入和删除操作不需要移动元素，且插入和删除灵活。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1、需要随机访问（按数组下标或序号访问）数据时；\n2、能事先确定表中最大元素个数（即最大表长）时；\n3、不需要频繁地插入、删除元素时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "需要随机访问（按脚标访问）数据的时候；\n已知最大元素数量（即最大表长）的时候；\n不需要大量插入、删除元素操作的时候。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确\n先入栈的后出栈，后入栈的先出栈，出栈的顺序的早晚和入栈顺序的早晚完全相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "要实现删除 p 结点的操作,必须找到其前驱结点,修改其指针域的值使其指向 p 的后继结点,以实现删除结点 p 。单链表不行,因此不知道头指针就无法找到结点 p 的前驱结点。双向循环链表和单循环链表可以可以实现删除 p 结点。单循环链表删除 p 结点的时间复杂度为 O(n) ,双循环链表删除 P 结点的时间复杂度为 O(1) 。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "ai=3n−3(i−1).\n求解原因：队列遵循先进先出、后进后出的原则，因此当进队序列为3、6、9、…、3n时，出队序列也为3、6、9、…、3n，此序列出队列后立即进入一个栈，因此进栈顺序为3、6、9、…、3n，又栈遵循后进先出的原则，因此出栈顺序为3n、3(n-1)、…、9、6、3，即ai=3n-3(i-1).\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3(n-i+1)\n因为队列是先进的先出，所以入栈顺序是3、6、9、12、... 3n，但是栈是后进的先出，由于第一个出的是3n，所以出栈顺序是3n、3(n-1)、3(n-2)、...6、3。按规律计算可得ai=3(n-i+1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1的优点是每个栈只用一个顺序存储空间，操作较为简单。但是缺点是对分配的空间要求高，如果分配的空间小，容易产生溢出；分配空间大，浪费内存。\n\n\n\n\n2的优点是多个栈共用一个顺序存储空间，能够充分利用存储空间，只有在整个存储空间都用完时才会产生溢出。但是缺点是如果一个栈满了，就要向左向右查询有没有空闲的单元。如果有空闲单元，要移动元素和修改相关的栈底和栈项指针。这个步骤计算复杂，时间消耗长。\n\n\n\n\n3的优点是多个独立的链栈一般不考虑栈的溢出。但是缺点是栈里的元素要用指针相链接，占用的存储空间会更大。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表：\n1.存储数量大小事先已经确定\n2.顺序表内元素是连续存储\n3.元素顺序存储于一片连续的内存中\n链表：\n1.存储数量的大小事先可以不知道\n2.顺序表内元素是链式存储\n3.链表存储的存储空间可以不在连续的内存中\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "9", "answer": "错误。顺序栈指的是用连续的存贮空间保存数据，顺序按照的是进栈的顺序，而不是元素的大小。\n当然，在特定情况下，也有可能是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性；\n\n\n\n\n2、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现错误的机会。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.插入概率均等时插入一个元素平均移动的元素个数为n/2\n2.平均移动个数为(2n+1)/3;\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "对，因为栈是先进后出，后进先出\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确，理由如下：\n\n\n\n\n1、如果m个（m<n）个元素进栈后，先出栈一部分，之后再继续将剩下未进栈的元素进栈，总的出栈顺序不与进栈顺序相反。\n\n\n\n\n2、只有当个n元素连续进栈，出栈的结果才与入栈顺序相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，栈只能在表首进行插入和删除操作，当栈只剩下一个元素时，栈顶元素就是栈底元素，因此可以删除，也就是说栈底元素是可以删除的。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "4", "answer": "1、有利于对链表的首元素进行删改\n2、可以防止单链表为空\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "答：1.举例：当输入的数据是反序的情况时，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动；\n2.快速排序过程中可能也会有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "9", "answer": "若将两个长度为n的有序表归并为一个长度为2n的有序表需比较n次,则两个被归并的表应满足:其中一个表的所有元素均小于(或大于)另一个表中的任意元素,若将两个长度为n的有序表归并为一个长度为2n的有序表需比较2n-1次,则两个被归并的表应满足:其中一个表的所有元素不得均小于(或大于)另一个表中的两个或两个以上的元素。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表中不知前驱节点，无法删除\n双链表为O(1)\n循环单链表为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "顺序表：\n1、预先分配空间，可能导致溢出或浪费\n2、不需要关注元素间的逻辑关系而增加储存空间\n3、随机存取\n链式：\n1、动态分配空间\n2、借助指针来体现元素间的逻辑关系\n3、顺序存取\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "7", "answer": "用S1来存放已输入的元素，即S1执行入队操作。当需要出队时，则队S2执行出栈操作。必须先将S1中所有元素出栈并入栈到S2中，再在S2中出栈即可实现出队操作。1，将元素输入到栈S1，然后从栈S1输出到栈S2，需要判断栈S2是否为空，如果不为空会造成输出顺序的混乱 2，直接从栈S2输出 3，输入到栈S1，直接判断栈S1是否为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "2", "answer": "防止单链表是空的。\n方便在第1个位置进行插入。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "若一组数中部有一个数字超级大，导致在冒泡排序中不断后移，盖过次大的数据，而次大的数据最初位置又比较小数位置靠前，导致向相反方向进行。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "n个节点高度为n，就是每个节点只有一个孩子么，那么不同种类就是由你结点是左孩子还是右孩子决定的，一共n-1条边，就是2的n-1次方种二叉树\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，和元素值的大小无关。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、顺序表存储\n\n\n\n\n原理：将表中元素一个个存入一组连续的存储单元中，这种存储结构是顺序结构。采用顺序存储结构的线性表简称为“ 顺序表”。\n\n\n\n\n优点：存取速度高效，通过下标来直接存储\n\n\n\n\n缺点：1.插入和删除比较慢\n\n\n\n       2.不可以增长长度    \n\n\n\n\n比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序\n\n\n\n\n2、链式表存储\n\n\n\n\n原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题\n\n\n\n\n优点：插入和删除速度快，保留原有的物理顺序\n\n\n\n\n缺点：查找速度慢，因为查找时，需要循环链表访问\n\n\n\n\n比如：插入或者删除一个元素时，只需要改变指针指向即可\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "7", "answer": "1.数据量小的时候\n2.空间充足且不需要频繁增加和删减数据的时候\n3.要求存储密度高的时候\n4.要求程序利于理解的时候\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表：不可以，须知该结点的上一个结点。\n双链表：可以，因为双链表可以通过指针指向的结点找到其前驱结点和后继结点，时间复杂度为o（n）。\n循环单列表：也可以，可以通过指针找到其前驱结点，时间复杂度o（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "假如进入3，则立即出队列，此时3进栈，位于栈底。当3n出队列时，进入栈顶，随机出栈，所以第一个出栈的是3n。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "设有有序表 A, B.\n\n\n\n\n\n\n需要比较n次的情况\n\n\n\n\n当某一个有序表的元素全部大于另一个有序表的时候. 有最优情况\n\n\n\n\ne.g.\n\n\n\nA\t1\t2\t3\t4\t5\nB\t6\t7\t8\t9\t10\n\n\nA\t6\t7\t8\t9\t10\nB\t1\t2\t3\t4\t5\n\n\n\n\n\n需要比较2n-1次的情况\n\n\n\n\n当两个有序表的元素交错排列时\n\n\n\n\ne.g.\n\n\n\nA\t1\t3\t5\t7\t9\nB\t2\t4\t6\t8\t10\n\n\n\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "不能，理论可以删除，作为数据结构是不能删除的\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "用S1来存放已输入的元素，执行入栈操作，党需要出队时，则对S2执行出栈操作。当栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n顺序栈是指用顺序存储结构实现的栈，未必需要元素值的大小有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "1.入队：将元素压入栈S1中\n2.出队：当栈S2非空时，压出栈顶元素，如果栈S2为空，将栈S1中的元素全部压入栈S1中。\n3.判断队列是否为空：如果栈S1和栈S2都为空时则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "入队：向栈S1中插入元素\n出队：S1中的元素出栈，再插入S2，再让S2中的元素出栈\n判断队列是否为空：S1中有元素则队列不为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表是开数组，每个数组元素的排列顺序直接明显，可以直接搜索到所需位置的元素。\n链表是在数据项后再多定义一个指针，各个元素之间是通过指针相连，前一个元素的指针指向下一位，从而构成顺序关系。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "适合用链表。若用数组存储，则为了确保数据的连续，需要在每次插入和删除的时候前移后续的数据，当数据量很大时将会耗费很多时间。若使用链表，则插入和删除数据时只需要对改动位置前后节点的指针进行修改就可以了，时间复杂度大大降低。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "要用两个栈来模拟队列，主要是要用到栈和队列的特点不同，栈是后进先出，队列是先进先出，两者在出的顺序是相反的。\n\n\n\n\n入队：以S1作为输入栈，将元素入栈，模拟队列元素的入队。此时栈从上到下的顺序与原顺序是相反的，即从上往下是逆序。\n\n\n\n\n出队：由于出队要实现先进先出，所以将S1的元素出栈再入栈到S2中，此时从上往下是顺序，即原来的顺序，再出栈就是实现先进先出。\n\n\n\n\n判断队列是否为空：S1为空且S2为空则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1、若链表没有头结点，则首元素结点没有前驱结点，在其前插入结点或删除该结点时操作会复杂些。\n\n\n\n\n2、无论链表是否为空，头指针均不为空。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "链表存储结构\n因为链表存储结构执行插入和删除运算很方便，只需改变个别指针，无需移动元素\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "将这两个表分为1表和2表\n最少比较n次：如果是从小到大排序，则其中一个有序表的首元素大于另一个表的最末元素（例如1 2 3 4和5 6 7 8）。如果是从大到小排序，则其中一个有序表的首元素小于另一个表的最末元素（例如8 7 6 5和4 3 2 1）。\n最多需要比较2n-1次：即两个表中的元素最终需要交错排列。（例如1 3 5 7和2 4 6 8）。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "一是要归并的两个表都是递增有序的且长度都为n，二是题目问的是最少的关键字比较次数，即最好的情况下的比较次数。而最好的情况应该是：一个表的所有关键字都大于（或小于）另一个表的所有关键字，如：（1 2 3 4）与（5 6 7 8）。比较的时候有两个指针分别指向两个表的第一个元素，由于一个表的关键字要都大于另一个表的关键字，所以关键字小的表中的元素挨个与关键字大的表的第一个元素比较后，先被并入到新表中，这时关键字大的表的指针还是指向第一个元素没变，此时只需将关键字大的表复制到新表中即可。所以花费的比较次数就是关键字小的表长，也就是n。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "\n\n当只需要比较n次时， 说明某个表的头元素大于另一个表的所有元素\n\n\n当需要比较2n-1次时， 说明两个表的元素刚好是插空分布的\n\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "栈的特点是后进先出，队列的特点是先进先出。所以，用两个栈S1和S2模拟一个队列时，S1作输入栈，逐个元素压栈，以此模拟队列元素的入队。当需要出队时，将栈S1退栈并逐个压入栈S2中，S1中最先入栈的元素，在S2中处于栈顶。S2退栈，相当于队列的出队，实现了先进先出。而判断队列是否为空，则判断两个栈是否都为空就可以。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，如果元素全部入栈之后再出栈，元素顺序相反。如果先入栈几个元素之后再出栈则不遵从出栈元素顺序相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。栈有两种存储表示方法,分别为顺序栈和链式栈。顺序栈指的是存储结构，而不是元素值的大小是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n\n\n\n\n1.栈的基本逻辑是先进后出，可以全部都进栈了再push出元素，也可以不用等都进栈了就push出元素\n\n\n\n\n2.例如，如果说入栈元素次序是abc。出栈顺序分别如下：abc push pop push pop push pop a入栈→a出栈→b入栈→b出栈→c入栈→c出栈 acb push pop push push pop pop a入栈→a出栈→b入栈→c入栈→c出栈→b出栈 bac push push pop pop push pop a入栈→b入栈→b出栈→a出栈→c入栈→c出栈 bca push push pop push pop pop a入栈→b入栈→b出栈→c入栈→c出栈→a出栈 cba push push push pop pop pop a入栈→b入栈→c入栈→c出栈→b出栈→a出栈 因此，题目所说错误\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "一、顺序表的特点：逻辑相邻，物理相邻，经常用数组实现\n（1）优点：\n1.方便存取任一位置元素\n2.无需为表元素之间的逻辑关系增加额外的存储空间\n（2）缺点：\n1.插入、删除操作需要移动大量元素\n2.需提前分配空间，极易利用不充分\n3.容量难以扩充\n二、链表存储的特点：经常用指针实现\n（1）优点：\n1.插入、删除方便\n2.不要求用连续的单元存储元素\n（2）缺点：\n1.需为表元素之间的逻辑关系增加额外的存储空间\n2.查找元素效率低\n\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "9", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，进队序列就为3、6、9、12、... 3n；而栈是后进先出的，当a1=3n时说明最后进栈的元素最先出栈，这样出栈顺序为3n、3n-3、...、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "宜采用链式存储结构，因为采用链式结构存储线性表，在插入和删除时只需修改对应节点的指针域，无需移动节点，耗时少\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，栈的结构就是后进先出,每次都是pop栈顶元素\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "前一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n另一种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n\n\n当需要比较n次时，这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字，两个有序表示可以连接为有序的，只需要比较n次就可以将一个表中元素转移完毕；当需要比较2n-1次时，是两个被归并的有序表中关键字序列完全一样，这时就要按次序轮流取其元素归并，因此比较次数为2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "顺序表在存储数据之前需要先开辟好足够的的存储空间，一旦开辟后续无法修改大小；然后将数据按照顺序逐一存入。\n链表存储数据时一次只开辟存储一个节点的物理空间，后续可以根据需要再开辟；且数据之间的逻辑关系依靠每个数据元素携带的指针维持。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "ai = 3n - 3 * (i - 1)\n\n\n\n\n理由如下：\n\n\n\n\n①由队列先进先出的性质可知，进入队列顺序和出队列顺序一致，因此出队列顺序也为3、6、9、12、...、3n；\n\n\n\n\n②因为经过队列立即出队进入栈，所以入栈顺序和出队列顺序一致，即入栈顺序为3、6、9、12、...、3n；\n\n\n\n\n③由栈的先进后出性质可知，若a1=3n，则必定是所有元素全部进栈之后才开始有元素出栈，因此出栈的输出序列必然是开始序列的倒序输出，即3n、3n-3、3n-3*2、...、6、3；\n\n\n\n\n④综上所述，ai = 3n - 3 * (i - 1)。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "不一定，假设进栈顺序为12345，可以12先入栈并出栈再把345进栈并出栈这时出栈的顺序就为21543\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "模拟过程：栈的特点是后进先出，队列的特点是先进先出。所以，用两个栈S1和S2模拟一个队列时，S1作输入栈，逐个元素压栈，以此模拟队列元素的入队。当需要出队时，将栈S1退栈个压入栈S2中，S1中最先入栈的元素，在S2中处于栈顶。S2退栈，相当于队列的出队，实现了先进先出。\n操作：在入队时，如果s1空间已满，s2不为空时，则入队失败。（将s1中的值放至s2中时会影响出队顺序）\n在入队时，如果s1空间已满，s2为空时，则将s1中的所有值出到s2中，然后进行入队操作，将值存入s1中。\n在出队时，如果s2为空时，s1不为空时，则将s1中的所有值出到s2中，然后进行出队操作，即对s2进行出栈。\n如果s1，s2为空时，则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序亦为3、6、9、12、...、3n。而栈是后进先出的，当a1=3n时，说明最后进栈的元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "待排序序列后面的若干关键字比前面的关键字小，则在冒泡排序过程中关键字可能与最终它应移向的位置相反的方向移动。\n\n\n\n\n没有。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的序列也为3，6，9，10....3n,而出栈序列为a1=3n，则证明最后入栈的数字最先出栈，因此出栈顺序为3n,3n-3,3n-6,...,9,6,3.\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "由于队列是先进先出的，出队列和进栈的次序也是3、6、9、12、……3n，而栈是后进先出的，这样出栈的次序就是3n、3n-3、……、9、6、3.\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "等概率情况下，在ai之后插入一个元素需要移动n-i个元素\n若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则平均要移动（n-i）/（2*（n-i）/n/（n+1））个元素\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，元素入栈出栈应符合先进后出\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "否。只有在n个元素连续进栈后，它们的出栈顺序和进栈顺序才一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "由于队列是先进先出，栈是后进后出，所以进栈序列为an，a（n-1）.....a(2),a(1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1，数据元素在物理位置上是连续存储的时候。\n2，存储后不需要做大量的增加、删改的时候。\n3，存储后需经常查找的时候。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表：存储空间是连续的，通常用数组实现。因此，可以通过索引查找，优点是查找修改速度比较快，然而由于顺序存储带来的缺点是：增加和删除要移动数据，操作比较麻烦，速度比较慢。\n\n\n\n\n链表：存储空间是不连续的，每个元素通过指针连接起来，正好与顺序表相反，查找比较耗时，但增加删除元素比较快，可以在常数时间内完成。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "举例说明：\n6 4 2 3\n在第一趟时，4比6小，4前移，但是最终排序4需要后移。\n快速排序过程中有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "解:例如(5,4,2,1),第1趟冒泡排序后为(4,2,1,5),关键字4的位置被移动到首\n\n\n\n\n位﹐朝着与最终排序相反的方向移动。而在快速排序中却不存在这种现\n\n\n\n\n象。因为经过一趟快速排序的区间划分所能确定的枢轴记录的位置就是\n\n\n\n\n此记录最终的位置,而且所有比枢轴记录小的记录均被移动到枢轴之前,\n\n\n\n\n所有比枢轴记录大的记录均被移动到枢轴之后。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "①含有n的结点的二叉树高度最多为n-1\n②n＞n-1\n③因此，这种二叉树不存在，即个数为0\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。当栈中只剩下一个元素的时候该元素即为栈底元素，删除后栈即为空。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "单链表无法操作。\n双链表可以，因为其可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O（1）.\n循环单链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "4", "answer": "顺序表储存方式将表中的元素逐个存放于数组的一些连续的存储单元中。\n链表存储方式是将表中的元素随机存储在内存中，开辟另外的空间存储下一单元的地址。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "8", "answer": "顺序表：顺序结构，可以随机访问元素，存取速度效率高，插入和删减不方便，需要遍历移动元素重新排序。\n链表存储方式：程序运行过程中动态分配空间，插入和删除速度很快，但是查找的时候需要循环链表访问。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "1.使链表的头指针非空\n2.为了方便单链表所要执行的一些特殊操作。如在插入或者删除表头的第一个结点时，不用考虑特殊的情况，在处理时更为方便\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不行，如果要删去P指向的结点，就需要知道该结点前一个结点。通过前驱->next=后驱，断开*p结点\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n单循环链表可以，链表的循环（遍历一次回到原处）可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "n=1，个数为1；\nn>1，个数为2*（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "①平均移动n/2个\n②平均移动(2n+1)/3个\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错，顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "不需要进行插入和删除操作时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不能；\n双链表能：O（1）\n循环单链表能：O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "因为采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.单链表不可以删；\n2.双链表可以，复杂度为O(1)；\n3.循环单链表可以，复杂度为O(n)；\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "123456789从大到小排序时，\n没有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "链表存储结构，因为链表可以在插入和删除操作时，不需要移动元素，节省大量的时间，更方便快捷\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一种方案操作较简单，但是各栈不能共享空间，容易造成空间的浪费。\n第二种方案充分利用存储空间，但是在需要移动栈内元素或进行修改的时候，操作较为复杂。\n第三种方案不需要考虑栈的溢出，但是栈中元素需要一指针相连接，比顺序存储多占用存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "用S1来存放已输入的元素，即S1执行入队操作。当需要出队时，则S2执行\n出队操作。必须先将S1中所有元素出栈并压入到S2中，再在S2中出栈\n即可实现出队操作。\n①对S2的出栈操作用作出队，若S2为空则先将S1中所有元素送入S2。\n②对S1的入栈操作用作入队，若S1满，必须先保证S2为空，才能将S1中\n的元素全部压入S2中。\n当栈S1和S2都为空时队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。\n缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间。\n缺点是当一个栈满时要向左、右查询有无空闲单元。\n(3)优点是多个链栈一般不考虑栈的溢出。\n缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "4", "answer": "当线性表的数据元素在物理位置上是连续存储的时候，用顺序表比用链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n\n\n\n\n1.元素连续进栈时，出栈顺序才会和进栈顺序正好相反。\n\n\n\n\n2.元素有可能一边进栈一边出栈，此时出栈顺序与出栈顺序不相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n次:一个表中最大元素比另一个表中最小元素小\n2n-1次:两个表中元素大小交替\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以\n双链表和循环单链表可以\n双链表的时间复杂度是O（1）,循环单链表的时间复杂度是O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "1.如果链表有头节点，所有结点前插入结点或删除表内任意一个结点，要做的都是修改前一个结点的指针域，因为任何元素结点都有前驱结点。如果链表没有头结点，那么首元素结点没有前驱，在其前插入结点或删除该结点时要单独讨论第一个节点的情况。\n2.对带头结点的链表，表头指针指向头结点的非空指针，所以空表与非空表的处理是一样的，不用单独讨论空表的情况。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "顺序表不方便进行删减更改，但是可以随机访问元素；\n而链表运用了指针，方便进行删减更改，但是不能随机访问元素。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "错的。\n当只有一个元素时，为栈底元素，可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "9", "answer": "如果在待排序序列的后面的若干元素比前面的小，则在冒泡排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动\n例如：57 40 38 11 13 34 48 ，在某趟排序中，13和34会朝着相反方向移动。\n\n\n\n\n快排没有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "(1)优点:每个栈只用一个顺序存储空间，操作变得简单；\n缺点:分配空间如果较大，易造成浪费，分配空间如果较小，易造成溢出；且各栈之间不能共享空间。\n(2)优点:充分利用存储空间，在存储空间都用完时才会产生溢出\n缺点:当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素并修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这个过程计算复杂且十分耗时。\n(3)优点:多个链栈可以不考虑栈的溢出。缺点:栈中元素要用指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "入队：把元素压入S1；\n出队：把S1的元素全部压入S2；弹出S2栈顶元素，再把S2元素全部压入S1\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.数据规模可以确定\n2.不需要删除，插入数据导致需要重新排序\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "方法一:\n-优点:可以直观的得到各个栈的栈满栈空信息,因为采用顺序存储,所以查询速度快,简单、存储密度高\n-缺点:即使栈的长度很长，也还是可能发生上溢。当栈的容量不固定时，必须设置栈的长度以使其可以容纳更多的元素，容易浪费空间。\n方法二:\n-优点:解决了顺序栈的容量不固定时，必须设置栈的长度以使其可以容纳更多的元素，容易浪费空间的问题\n-缺点:是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时\n方法三:\n-优点:多个链栈一般不考虑栈的溢出。\n-缺点:栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.如果代码进行的运算，经常需要通过索引序号来访问，采用顺序表更合适，链表则无法直接通过索引来访问元素\n2.不需要进行太多的插入，删除操作时，使用顺序表更为方便\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "查找操作多于增、删操作时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表可以随机访问数据元素;但是大小固定,不利于增删结点。\n链表的采用指针方式增减结点,非常方便(只需要改变指针指向,不移动结点)，但不能进行随机访问,另外,每个结点上增加指针域,造成额外存储空间增大。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "例如： 9 6 3 7 2 4，6 移向了与最终排序相反的方向\n快速排序不会有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "6", "answer": "冒泡排序中待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4，3，2，1\n第一次排序：3，2，1，4\n第二次：2，1，3，4\n最终：1，2，3，4\n3第一趟移向了与最终位置相反的方向\n\n\n\n\n快速排序中也有这种现象\n如序列\n初始：90，32，25，50，60\n第一次：60，32，25，50，90\n60朝与最终排序相反方向移动\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "不正确。栈底元素可以删除，从栈顶开始进行pop操作一直到pop出栈底元素应该就可以。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "单链表：若仅知道指针p指向某节点，能够根据该指针找到其后继节点，但不知道其头指针，所以无法访问到p指针指向的节点的前驱节点，无法删去；\n双链表：双链表提供双向链接，因此根据该指针可以找到它的前驱和后继节点，因而可以删除节点，时间复杂度为O（1）；\n循环单链表：根据已知节点位置，可以直接找到其后继节点，又因为是循环单链表，所以可以通过循环查找得到p的前驱节点，因此可以删除节点p，时间复杂度为O（n）；\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "宜采用链表. 原因: 运行效率高. 链表可以实现快速的插入和删除操作, 而无须移动大量数据.\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：不知道节点p的前一个指针，无法将p指针删除。\n双链表：知道p指向的节点，将p->right赋值给p的前一个结点的right，将p->left赋值给p->right->left，便删除了p，时间复杂度是O（1）。\n循环单链表：知道节点p的下一个节点，就由p的下一个节点继续指向下一个节点，反复操作，因为这是循环链表，最终可以遍历到p的前一个节点，这样就可以把节点*p删除，时间复杂度是O（n）;\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "当需要较少的插入删除操作和较多的查找操作，或插入删除操作总发生在表尾，且需要的存储空间不太大时，使用顺序表比链表好。\n\n\n\n\n。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "3(n-i+1)\n队列先进先出\n栈先进后出\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "待排序序列后面的若干数据比前面的数据小，则在起泡排序过程中排序数据可能与最终它应移向的位置相反的方向移动。\n快速排序中无这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "1。方便在第一个节点插入和删除节点。\n2.使所有的链表的头指针非空，并使对单链表的插入、删除操作不需要区分是否在第一个位置或者是否是空表，从而与其他位置的插入、删除操作一致，减少他的特殊性。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "宜采用链式存储结构。因为链式存储结构进行增删结点操作时只需要修改相关结点的指针域，不需要移动结点；而采用顺序结构存储进行增删操作需要移动较多元素，操作更繁琐。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。假设n个元素入栈后（前提），那么他们出栈的顺序必定与入栈顺序相反。不管n个元素入完栈之后是否有其他元素入出栈，你跟踪这n个元素，总会发现是与入栈顺序相反的顺序。\n所以没有错。\n如果 入栈 1, 入栈2，入栈3，（考虑1,2,3，这三个元素）.\n会发现入栈顺序，123。\n出栈顺序，321\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最小比较需要n次时：当第一个有序表中所有的元素都小于（或大于）第二个表中的元素，只需要用第二个表中的第一个元素依次与第一个表的元素比较，总计比较n次。\n最多比较需要2n-1次时：当两个有序表的数据刚好是插空顺序的时候，比如第一个表是1，3，5，7...，而第二个表刚好插在其中间时2，4，6，8，...。总计比较2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "链式存储结构。\n链式存储结构在进行插入和删除时不需要移动数据元素，时间复杂度为O(1)；\n而顺序储存结构平均需要移动一半的元素，时间复杂度为O(n)。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "应该采用链式存储结构，原因：在执行插入或删除运算中，不需要移动元素来腾出空间或者填补空缺。操作简单便捷。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "答:ai=a1+3-3i(或ai=3(n+3-i)),求解原因:由于队列是先进先出,栈是后进先出,如果a1是3n,则说明该队列全部元素依次入栈,然后逆序出栈(即栈是后进先出的线性表,队列是先进先出的线性表)。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答前一种情况下这两个被归并的表中其中一个表的\n最大关键字不大于另一表中最小的关键字也就是说\n两个有序表是直接可以连接为有序的因此只需比较n\n次就可将一个表中元素转移完毕另一个表全部照搬\n就行了。\n另一种情况下是两个被归并的有序表中关键字序列\n完全一样这时就要按次序轮流取其元素归并因此比\n较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确\n先进栈的元素在栈底，若要取出栈底元素先要取出栈底以上的所有元素\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最多次数：当两个有序表的数据刚好是插空顺序的时候，比如：第一个序列是1,3,5，第二个序列是2,4,6；\n最少次数：例如前一个表A中的第一个值与后一个表B相比较，发现表A中最小的值比B的最大的值都要大。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "1.入队：将元素进栈S1。\n2.出队：将栈S1的栈顶元素一个个一次次入栈S2，直至S1只剩一个元素。出栈但不入S2，再将S2的栈顶元素依次入栈S1。\n3.判断是否为空：判断S1是否为空即可。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "一、单链表：\n当知道指针p指向某结点时，能够根据该指针找到其直接后继，但是由于不知道其头指针，所以无法访问到p指针指向的结点的直接前驱。因此无法删除该结点。\n二、双链表：\n由于这一的链表提供双向链接，因此根据已知结点可以查找到其直接前驱和直接后继，从而可以删除该结点。其时间复杂度为O(1)。\n三、单循环链表：\n根据已知结点位置，可以直接得到其直接后继，又因为是循环链表，所以可以通过查找得到p结点的直接前驱。因此，可以删除p所指的结点。其时间复杂度应为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "1、顺序表的物理顺序和逻辑顺序一致，链表的物理顺序和逻辑顺序不一致。\n2、顺序表的大小有限制，链表的大小几乎没有限制。\n3、顺序表的的存储密度等于1，链表的存储密度小于1，因为链表需要存储逻辑顺序关系，而顺序表不需要。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "\n\n防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n\n\n为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n\n\n单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n带头结点的链表因为有头结点，首元结点、中间结点的操作相同，使算法变得简单，流程清晰。\n\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误的;栈只能在栈顶插入和删除，当我们在栈顶连续运行插入时，栈底元素就会是我们刚刚第一个插入的元素（最早被插入的元素）；当我们在栈顶连续不断运行删除时，栈底元素就会是我们最后删除的元素（最后被删除的元素）。栈底只能最后删除但并不是不能删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "n/2。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "8", "answer": "当增删改次数很少的时候，或者增加和删除总是在列表末尾的时候，顺序表比列表好，因为更方便。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "错误，不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。\n栈仅在栈顶进行插入与删除操作，即一端入栈、出栈，按一定顺序入栈后，后入栈的元素先出栈，因此，它们的出栈顺序和入栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "方便在第1个位置进行插入、删除操作时同其他位置一样。 加了头结点之后，插入、删除都是在后继指针next上进行操作，不用动头指针；若不加头指针的话，在第1个位置插入或者删除第1个元素时，需要动的是头指针。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。栈底元素是位于栈最底部的元素，它可以被删除，删除后该栈变为空栈。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错，顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "采用链式存储结构。比顺序存储结构的存储密度大，\n\n\n\n\n链表插入、删除灵活 。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "线性表的数据元素在物理位置上是连续存储的情况下，用顺序表比用链表更好，有可以进行随机存取的特点。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "在运行需要访问读取大量元素，而几乎不需要增添、删除元素的程序时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "入队：用S1来存放已输入的元素，进入S1即执行入队操作\n出队：必须先将S1中所有元素出栈并入栈到S2中，再在S2中出栈，即可实现出队操作，而在执行此操作之前必须判断S2是否为空，否则导致顺序混乱\n为空：当栈S1和S2都为空时队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.平均移动的元素个数是n/2。\n\n\n\n\n2.平均移动的元素个数是（2n+1)/3。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "链式储存结构。因为可以动态分配内存，进行插入和删减操作时，只需对指针进行操作，较方便。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.入队：按第奇数个入队的放S1，第偶数个入队的放S2。以第奇数个为例，入队时如果S1为空则直接入栈，若不为空则先将当前S1栈中元素全部出栈，暂时进入栈S2，等当前需入队的元素进入栈S1后，再将刚才暂时进入栈S2的元素全部出栈，进入栈S1，这样栈中的数据顺序就是先入栈的在栈顶，后入栈的在栈底。第偶数个放S2同理。\n\n\n\n\n2.出队：按照先出一个S1栈顶元素，后出一个S2栈顶元素的顺序交替进行，这样元素出队顺序和进队顺序相同，先进的先出。\n\n\n\n\n3.判断队列是否为空：若S1和S2两个栈都为空，则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "n/2\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "8", "answer": "当涉及问题更多关于查找而非插入删除操作时，更适合顺序表。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是 \"一次开辟，永久使用\"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外） 而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "不正确。顺序栈中元素值的大小是无序的，顺序栈指的是存储的结构，而不是元素值有顺序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "错误，栈底的指针位置不动，而栈底的元素可以被最后删除，从而达到栈空状态\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "\n\n\n要求从小到大排：3 16 14 2 1 0第一趟中 14 就朝着与最终排序相反的方向移动\n\n\n\n\n\n\n快排中无这种现象\n\n\n\n\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "错误。\n顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。当栈底元素称为栈顶的时候可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "最小时，一表的最小值大于另一表的最大值，最多时一表元素a[i]介于另一表元素b[i]和b[i+1]之间\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表存储：是把数组放在一个连续的内存空间，表中的元素逐个存放在数组中的一些连续的存储单元中。因此，其无需为表示元素之间的逻辑关系增加额外的存储空间，并且可以随机存取表中任意位置的元素。但其插入和删除运算不方便，在进行插入和删除操作时往往需要移动大量的元素，效率较低。此外，在分配数组空间时难以确定数组的合适大小。\n链表存储：用指针将存储元素的那些单元依次串联在一起，需要在每个单元中设置指针来表示表之间元素之间的逻辑关系。其优点是相邻元素可以随意存放，没有空间限制，且插入和删除效率高。缺点是占用额外的空间存储指针、查找元素慢。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "3", "answer": "将元素存入s1栈中，若需出队时，先将s1的元素出栈，再将其入栈s2（s2为空的前提下），再将其出栈；及s1模拟队列出入队，s2模拟出队。\n入队：先判断队列是否已满，若已满无法入队，返回0；若未满，将rear后移（即q->rear=(q->rear+1)%maxsize），将新入队的值赋给q->rear；\n出队：先判断队列是否为空，若为空则返回0；若非空将front的值返回即（q->front=(q->front+1)%maxsize），将front后移；\n判断队列是否为空：判断front和rear是否相等。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以。\n双链表可以，时间复杂度为O(1)。\n循环链表可以，时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "1.需要对表内的某一个元素进行操作的时候\n2.对表进行删改增减的需求比较少的时候\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "当不涉及插入和删除操作的时候，用顺序表比链表好，因为对于顺序表而言，插入和删除的时候需要移动近一半的元素，而链表的插入和删除操作只需要移动指针的指向即可。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "入队：两个栈S1，S2都为空，执行入队操作，将元素直接插入S1中；栈S1为满，栈S2不为空，则队列为满，无法执行入队操作；栈S1为满，栈S2为空，执行入队操作，先将栈S1中的元素逐一出栈，再逐一入栈S2，当S1为空时，将元素插入S1中，实现入队操作。\n\n\n\n\n出队： 栈S2不为空，则队首元素位于S2的栈顶（栈S1为满，S2不为空），执行出队操作，将S2中的栈顶元素出栈，实现出队操作； 栈S2为空，栈S1为空，则队列为空，无法实现出队操作；栈S1不空，栈S2为空，执行出队操作时，先将S1中元素逐一从S1出栈，再逐一入栈S2，最后将S2中的栈顶元素出栈，实现出队操作。\n\n\n\n\n判空：两个栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "答：\n待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "9", "answer": "利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入栈操作。\n当需要出队时，则对S2执行出栈操作。\n由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而执行操作前必须判断S2是否为空，否则会导致顺序混乱。\n当栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "n/2;2n+1/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "4", "answer": "单链表，可以减少对数据的移动（即操作次数较少\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误！\n栈是先进后出的元素，每次只能删除栈顶元素，但是当栈只剩下一个元素时，栈底元素就是栈顶元素可以进行删除操作\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "\n\n问题一的答案为：\n`int Input(Stack S1,Stack S2,int e){\n if(!StackOverflow(S1)){\n Push(S1,e);\n return 1;\n\n\n}\nif(StackOverflow(S1)&&!StackEmpty(S2)){\n printf(\"队列满\");\n return 0;\n\n\n}\nif(StackOverflow(S1)&&StackEmpty(S2)){\n while(!StackEmpty(S1)){\n     Pop(S1,x);\n     Push(S2,x);\n }\n Push(S1,e);\n return 1;\n\n\n}\n} `\n\n\n\n\n\n2.问题2的答案为\nvoid Output(Stack *S1,Stack *S2,int *x){ if(!StackEmpty(S2)){ Pop(S2,x); } else if(!StackEmpty(S1)){ printf(\"队列为空\"); } else{ while(!StackEmpty(S1)){ Pop(S1,x); Push(S2,x); } Pop(S2,x); } }\n\n\n\n\n\n问题三的答案为\nint Empty(Stack S1,Stack S2){\n if(StackEmpty(S1)&&StackEmpty(S2)){\n     return 1;\n }\n else return 0;\n} \n\n\n\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "例如：9，8，7，6用冒泡排序，\n初始：9,8,7,6\n第一次排序：8,7,6,9\n第二次排序：7,6,8,9\n最终：6,7,8,9\n其中第二次中7朝着与最终排序相反的方向移动。\n在快速排序中也会出现这种情况，例如:对序列[88，46，23，51，58]以88划分时，序\n列变为[58，46，23，51，88]其中58 也朝与最终排序相反的方向移动了。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1)\n\n\n\n\n原因：由于队列是先进先出，栈是后进先出，由已知得：队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 a1=3n，意思是3n是最后一个进入栈的，则进队序列是连续的，所以可以得出，a2=3（n-1），a3=3（n-2），......an=3,所以ai=3*（n-i+1）。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不行，没法改变前一个结点的指针域\n双链表可以，是o(1)\n循环单链表可以，是o(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "1.n(n-1)/2\n2.n-i\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不需要考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "7", "answer": "宜采用链表结构，若使用顺序表除表尾位置外，在表的其他位置上进行插入或删除操作都必须移动大量元素，效率低。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "最小时：两个有序表都是按相同的顺序排列\n最多时：两个有序表的数据刚好是插空顺序的时候\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少：a中的元素都小于b中的元素。如a:1,2,3 b：4,5,6\n最多：a和b中的元素相互交错。如a：1,3,5 b：2,4,6\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.设置头结点，在任何结点前插入结点或删除表中任何结点，需要修改前一个结点的指针域。如果单链表中没有头结点，则首元素结点没有前驱结点，在其前插入或删除该结点时很难操作。\n2.带有头结点的单链表，表头指针指向头结点的非空指针，因此空表和非空表的处理是一样的。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "3*(n-i+1)\n因为队列是先进先出的，栈是先进后出的，现在已知第一个出栈的是队列的最后一个元素，说明队列中所有元素都进入栈后再输出的，因此输出的时候是反着的。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "宜采用链式存储结构。因为采用链式存储结构，插入和删除操作需要从头指针起查找插入、删除结点的前驱结点，并修改这些结点的指针域，查找过程中需平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。移动指针域的操作比移动元素的操作花费的时间少得多。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由队列先进先出，栈先进后出的原理可得，若a1=3n，则3n是最后入栈的，a2=3(n-1)，a3=3(n-2)……所以ai=3(n+1-i)。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "这是不正确的，解释：当一个栈中只有一个元素的时候，栈底元素即为可删除的元素。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "顺序表开始就分配足够的空间以存储数据，在查找数据方面更为便捷。链表以头结点开始，不断分配新空间创建新结点，以存储数据，在插入数据，删除数据方面更加便捷。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "单链表：不可以删去。因为单链表的指针是单向的无法找到上一个节点，若删去将会使链表断裂。\n双链表：可以删去。因为双链表的指针是双向的，可以找到上一个节点。\n循环链表：可以删去。因为循环链表可以通过循环找到其删一个节点。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "4", "answer": "其中栈s1用于插入元素，栈s2用于删除元素，每次删除元素时应将前一个栈的所有元素读出然后进入第二栈中，以此达到模拟队列的效果。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2的n-1次方\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "链式存储结构，因为这种存储结构使用指针来进行插入和删除操作。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "应该使用链式的储存结构，因为链式储存结构在插入和删除的时候不需要移动元素，只要修改前节点或者下一个节点的指针域即可,所花费的代价比较小.\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "        **ai = 3*(n-i+1)**\n\n\n\n\n原因：\n队列的规则是先入队的先出队，后入队的后出队。因此入栈顺序与入队顺序一致。\n而栈的规则是先入栈的后出栈，后入栈的先出栈，所以出栈按照与入队相反的顺序进行。\n所以ai按照以3为梯度递减。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "就存储来说，最主要的是链表可以动态申请，在物理空间上不连续，但很灵活，且支持频繁增删改，只需移动指针而不需移动元素。而顺序表“一次开通，永久使用”，在物理空间上连续，但相对来说大小固定、不够灵活（除了使用动态数组）,不方便增删改，要移动大量元素。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "0", "answer": "2的n次方。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "在等P的前提下，平均插入一个元素需要移动的个数为：(n+……+2+1+0)/n+1 = n/2\n\n\n\n\n在不等P下，平均插入一个元素需要移动的个数为：∑2(n-i)(n-i)/n(n+1) = (2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。当栈中只有一个元素时，这个元素也称栈底元素，它可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "单链表中，如果要删去P指向的结点，就需要知道该结点前一个结点，所以无法删去。\n双链表中，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，所以可以删去，时间复杂度O(1).\n单循环链表中，链表的循环可以得到P指向的结点的前驱结点，所以可以删去，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "5", "answer": "1.入队\n当栈s1不满时，入队直接进入s1\n2.出队\n将s1中所有元素出栈，压入s2，弹出栈首，再把剩余元素压入s1\n3.是否为空\n当且仅当s1为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "这个叙述是不正确的，解释：顺序栈的意思是以顺序结构存储的栈，而不是其元素值大小是有序的栈，它的栈中的元素不一定在大小上是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "当后一个有序表的所有元素的排序码值都比前一个有序表的值大，或者全比前一个有序表值小时，如{1，2，4，5}与{7，8，9，10}. 最多比较n次\n当两序列码值交错排序时候 如{1，3，5，7}与{2，4，6，8}\n最多比较2n-1次\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "1、操作简单，容易溢出\n\n\n\n\n2、充分利用，查找耗时。\n\n\n\n\n3、指针相连，占用多的空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "6", "answer": "采用链表存储结构，因为这种方法通过改动指针来进行插入和删除，不需要移动节点，更方便快捷。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不对，可以一边入栈一边出栈\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.顺序表 :一次性开出足够的空间，大小难以确定，过大造成浪费，过小数据溢出丢失，储存空间连续，利用率高\n2.链表：每次开空间会申请一个节点，空间大小可控，但是地址随机，需要指针存储地址，建立比较麻烦，利用率低\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "8", "answer": "1.较少对表进行增减删改的时候。\n2.需要对表内随便某个元素进行操作时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "需要的空间已知，插入和删减元素行为少。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答: 高度为n说明二叉树每层只有一个节点, 除了根节点外每个节点都有两种状态可供选择(左/右)\n所以一共2\n(n−1)\n中二叉树\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "防止单链表是空的而设的.当链表为空的时候,带头结点的头指针就指向头结点.如果当链表为空的时候,单链表没有带头结点,那么它的头指针就为NULL.\n\n\n\n\n2、是为了方便单链表的特殊操作,插入在表头或者删除第一个结点.这样就保持了单链表操作的统一性!\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "3", "answer": "线性表宜采用链表的存储结构。因为链表中地址不连续，不要求逻辑上相邻的元素物理上也要相邻，便于插入和删除；\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，出栈的元素只要在栈顶时就可以出栈，不一定要等到全部元素入栈后再将元素出栈。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.为了方便单链表插入或删除表的第一个结点\n2.当链表为空时，头指针指向头结点，减少程序复杂性\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "\n\n等概率时， 插入平均需要移动\n2\n1\n\t​\n\nn(n+1)次\n\n\n概率改变时， 平均移动(2n+1)/3次\n\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "5", "answer": "宜采用链式存储结构，这样进行插入和删除操作时不需要再移动元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "解：利用栈“后进先出”的特点，第一个栈实现入队，再用第二个栈接收第一个栈依次出栈的元素，使得最先入栈的元素在另一个栈最先出栈。\n\n\n\n#include<stack>\nstack<int>s1;\nstack<int>s2;\n//入队 \n//若s1未满\ns1.push(x);\n\n//若s1已满 而s2为空\nwhile(!s1.empty())//s1退栈到空，同时把s1中元素压到s2中\n{\ns2.push(s1.top());\ns1.pop();\n}\ns1.push(x);//再把元素压到s1中\n\n//若s1满s2不空 则不能实现入队\n\n\n//出队\n//若s2不空，则s2出栈\ns2.pop();\n\n//若s2空而s1非空 则现将s1中元素压到s2中 再使s2元素出栈 通过栈先进后出，后进先出，实现队列先进先出的功能\nwhile(!s1.empty())\n{\ns2.push(s1.top());\ns1.pop();\n}\ns2.pop();\n\n//若两个栈都为空 则队列为空\n//判断队列是否为空\nif(s1.empty()&&s2.empty())\ncout<<\"队列为空\"<<endl;\nelse cout<<\"队列非空\"<<endl;\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2的（n-1）次方个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n（2）优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n\n\n\n\n（3）优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1、方便在头节点前插入或删除节点\n2、出现多个链表时，可以运用结构体分开赋值头节点\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "否。元素大小跟顺序无关。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "用栈S1和S2来模拟队列：利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放插入的元素，即S1执行入栈操作。当需要出队时，则对S2执行出栈操作。因为从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，需要注意的是执行操作前必须判断S2是否为空，否则会导致顺序混乱。当栈S1和S2都为空时，队列为空。\n1、入队\n两个栈S1，S2都为空，执行入队操作，将元素直接插入S1中。若栈S1为满，栈S2不为空，则队列为满，无法执行入队操作。 栈S1为满，栈S2为空，执行入队操作，先将栈S1中的元素逐一出栈，再逐一入栈S2；当S1为空时，将元素插入S1中，实现入队操作。\n2、出队\n栈S2不为空，则队首元素位于S2的栈顶（栈S1为满，S2不为空），执行出队操作，将S2中的栈顶元素出栈，实现出队操作。栈S2为空，栈S1为空，则队列为空，无法实现出队操作。 栈S1不空，栈S2为空，执行出队操作时，先将S1中元素逐一从S1出栈，再逐一入栈S2，最后将S2中的栈顶元素出栈，实现出队操作。\n3、判空\n两个栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。若先进栈一定数量的元素，再进行出栈操作，再进行进栈，再进行出栈，那样进栈顺序和出栈顺序就不会正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2 ; (2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "5", "answer": "采用链式存储结构，它根据实际需要申请内存空间，而当不需要时又可将不用结点空间返还给系统。在链式存储结构中插入和删除操作不需要移动元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、顺序表存储\n\n\n\n\n原理：将表中元素一个个存入一组连续的存储单元中，这种存储结构是顺序结构。采用顺序存储结构的线性表简称为“ 顺序表”。\n\n\n\n\n优点：存取速度高效，通过下标来直接存储\n\n\n\n\n缺点：1.插入和删除比较慢\n\n\n\n       2.不可以增长长度    \n\n\n\n\n比如：插入或者删除一个元素时，整个表需要遍历移动元素来重新排一次顺序\n\n\n\n\n2、链式表存储\n\n\n\n\n原理：链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题\n\n\n\n\n优点：插入和删除速度快，保留原有的物理顺序\n\n\n\n\n缺点：查找速度慢，因为查找时，需要循环链表访问\n\n\n\n\n比如：插入或者删除一个元素时，只需要改变指针指向即可\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "错误，当只剩下栈底元素时可以删除，那之后栈变为空栈\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "(1)分别用多个顺序存储空间建立多个独立的顺序栈。\n优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是不好设置存储空间的大小。一次定义。不够自由灵活\n(2)多个栈共享一个顺序存储空间。\n优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是这种类型的栈查询修改起来，需要移动的元素很多，时间复杂度高\n(3)分别建立多个独立的链栈。\n优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "7", "answer": "第一种情况下,这两个被归并的表中其中一个表的最大关键字小于等于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表直接复制即可。\n第二种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "我们使用s1存放入队元素，s2存放出队元素。为了满足队列先进先出特性，若要出队，则将s1中的元素压入s2中，这样就实现了逆序，再将s2栈顶元素出栈，即可实现先进先出。\n\n\n\n\n\n入队\n如果s1未满，直接将元素压入s1\n如果s1满，但s2不是空栈，则无法入队（两个栈的大小相同，就算将s1中的全部元素压入s2，s1中仍会剩余元素，这时若将元素入队会改变出队顺序）\n如果s1满，但s2为空，将s1中元素全部压入s2中，再将元素压入s1\n\n\n出队\n如果s2不为空，则直接将s2的栈顶元素出栈\n如果s2为空，但s1不为空，先将s1的全部元素出栈，全部压入s2，再将s2的栈顶元素出栈\n如果s1、s2都为空，则没有元素可以出栈\n\n\n判断队列是否为空\n只有s1和s2都是空栈的时候队列才为空，其他情况队列都非空\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "例如：大于4个数据的数据中，按从小到大排序，第一位为最大数。第二为最小数，则第二位数字会往前进一位。\n快速排序没有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "因为要求有n个节点并且高度为n，则每层只能有一个节点；\n则：在二叉树中，除根节点以外每个结点有左和右两种情况；\n所以个数为2^(n-1)。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "若a1=3n，则a2=3(n-1)，a3=3(n-2)......an=3(n+1-n)=3\n即ai=3(n+1-i)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "入栈s1表示进栈，若要出队则，先入s2，再出栈。若s1为空则为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "要实现删除 p 结点的操作,必须找到其前驱结点,修改其指针域的值使其指向 p 的后继结点,以实现删除结点 p 。单链表不行,因此不知道头指针就无法找到结点 p 的前驱结点。双向循环链表和单循环链表可以可以实现删除 p 结点。单循环链表删除 p 结点的时间复杂度为 O(n) ,双循环链表删除 P 结点的时间复杂度为 O(1) 。\n\n\n\n\n单链表不可以删除p节点，双链表和循环单链表可以删除节点p，时间复杂度分别为O（1）和O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "①比较n次的特征：两个子表均为有序的表，之间将其合并成一个有序的表。\n②比较2n-1次的特征：最多的比较次数是当两个有序表的数据刚好是插空顺序的时候，比如：第一个序列是1,3,5，第二个序列是2,4,6，把第二个序列插入到第一个序列中，先把第二个序列中的第一个元素2和第一个序列依次比较，需要比较2次（和1，3比较），第二个元素4需要比较2次（和3,5比较，因为4比2大，2之前的元素都不用比较了），第三个元素6需要比较1次（只和5比较），所以最多需要比较5次。即2n-1次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "对表内的元素插入和删除的操作较少，且需要频繁地访问或存取任意位置（可通过下标直接定位）元素的时候。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.等概率插入位置0....n，平均移动n/2\n2.不等概率，平均移动(2*n + 1 )/ 3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表：\n\n\n\n\n\n优点：\n\n\n无须为表示表元素之间的逻辑关系增加额外的储存空间\n\n\n\n\n\n可以方便地随机存储表中的任意位置\n\n\n\n\n\n\n\n\n\n缺点\n\n\n插入和删除运算不方便，除表尾位置外，在表的其他位置上进行插入或删除操作都必须移动大量元素，效率较低\n\n\n\n\n\n由于数组要求占用的连续空间，故在分配数组空间时，只能预先估计表的大小，再进行储存分配，\n\n\n链表：\n\n\n\n\n\n\n优点：\n  1.     插入和删除运算方便，不需要移动大量元素，效率较高\n  2.  当表长变化较大时，容易确定数组的合适大小，分配简单便捷\n\n\n\n\n\n缺点：\n\n\n表示表元素之间的逻辑关系需增加额外的储存空间\n\n\n随机存储表中的位置固定，操作受限\n\n\n\n\n\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "ai会等于3*(n-i+1)，由于队列是先进的先出，而栈是后进的先出，所以当队列中最后一个出队的元素，进去栈时，反而其第一次出栈。所以其出栈的顺序会和队列最开始进队的顺序相反。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "不带头结点的链表，如果对表头元素操作就需要特殊处理，不能和其他位置的节点操作一致，比较麻烦。而如果带了头结点，对表内任意元素的操作都可以一致。\n带头结点的单链表，可以减少对表头元素的操作，如果对表头元素频繁操作可能在不经意间就修改了头指针，容易丢失指针的位置。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "\n\n举例：\n4、3、2、1\n第一躺：3、2、1、4\n第二趟：2、1、3、4\n第三趟：1、2、3、4\n第二趟中2就朝着与最终排序相反的方向移动\n\n\n有\n\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "顺序表特点：\n逻辑相邻，物理相邻\n无须为表示元素间的逻辑关系而增加额外的存储空间\n存储空间使用紧凑\n可随机存取任一元素\n插入、删除操作需要移动大量的元素\n预先分配空间需按最大空间分配，利用不充分\n表容量难以扩充\n链表：\n避免了数组要求连续的单元存储元素的缺点 在执行插入或删除运算时，不再需要移动元素\n当元素的粒 度很大时，移动元素是很费时的\n需要在每个单元中设置指针来表示表中元素之间的逻辑关系，因 而增加了额外的存储空间，为获得上述优点付出代价。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "答：1.可以判断此链表是否为空，当头结点指向NULL时，说明此链表为空，若头结点未指向NULL,则此链表不为空。\n2.对单链表设置头结点可以方便在表头进行删除和插入操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "(1)分别用多个顺序存储空间建立多个独立的顺序栈。优点，没个栈有独立空间操作简单，缺点空间不容易分配。\n(2)多个栈共享一个顺序存储空间。优点，不容易溢出，缺点，操作较复杂\n(3)分别建立多个独立的链栈。优点不容易溢出，缺点，操作复杂\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "9", "answer": "适宜使用链表存储结构。因为链表在插入和删除操作时，只需要改变指针指向，而顺序表需要遍历移动元素来重新排列顺序。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不行，如果要删去p指向的结点，就需要知道该结点的前一个结点。\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱和后继结点，时间复杂度为O（1）\n单循环链表也可以，链表的循环可以得到p指向的结点的前驱结点，时间复杂度为O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "5", "answer": "使用栈S1和S2来模拟队列：先将所有元素入栈到S1，因为栈是后进的先出，所有顺序会是反过来的，因此需要将S1所有元素出栈再入栈到S2，从而得到正确的顺序，再在S2执行出栈，从而模拟队列。\n入队：\n\n\n\nbool EnterQueue(Stack S1,StackItem x)\n{\n    if(!StackFull(S1))\n    {\n        push(S,x);\n        return true;\n    }\n    if(StackFull(S1)&&StackEmpty(S2))\n    {\n        while(!StackEmpty(S1))\n        {\n            pop(S1,t);\n            push(S2,t);\n        }\n    }\n    push(S1,x);\n    return true;\n}\n\n\n\n\n出队：\n\n\n\nbool DeleteQueue(Stack S1,Stack S2,StackItem x)\n{\n    if(!StackEmpty(S2))\n    {\n        pop(S2,x);\n        return true;\n    }\n}\n\n\n\n\n判断队列是否为空：\n\n\n\nbool QueueEmpty(Stack S1,Stack S2)\n{\n    if(StackEmpty(S1)&&StackEmpty(S2))\n    {\n                    return true;\n    }\n    else\n    {\n                    return false;\n    }\n}\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误,栈底元素需要等到栈顶指针指向栈底时才能删除(即栈底元素总是最先被插入的元素,从而也是最后才能被删除),但是根据栈的定义,栈底元素在这之前都是不能被操作的,所以也有一点道理。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "4", "answer": "链表，因为链表在执行插入或删除运算时，不再需要移动元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "入队：将元素进入栈S1中。\n出队：S2为空时：将S1中的元素放入S2中，再把元素从S2中出栈。\nS2不为空时：将元素从S2中出栈。\n判断是否为空：如果S1,S2都为空则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）n/2\n（2）（2n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "（1）优点：每个栈独自用一个存储空间，简单方便。\n缺点：存储空间容易溢出或浪费。\n（2）优点：用一个顺序存储空间，充分利用了存储空间。\n缺点：当其中一个栈要进行操作时，若存储空间接近满时，计算复杂，时间长。\n（3）优点：不考虑栈的溢出。\n缺点：是栈中元素要以指针相链接，多占用了存储空间\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：无法删除\n双链表：可以删除，时间复杂度为O(1)\n循环单链表：可以删除，时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "1.使每个结点都有前驱，方便进行插入、删除的操作。\n2.能更好地操作空链表。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "不正确，栈底位置不动但元素可以被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "9", "answer": "错误，元素在进栈之后也可在所有元素全部进站之前出栈，只是元素出栈需从栈顶开始\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "应该采用链式存储结构。\n\n因为链式存储结构可以根据实际需要申请内存空间，而当不需要时又可以将不用节点空间返还给系统，并且在链式存储结构中插入和删除操作不需要移动元素，只要改变节点中的指针。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "如果线性表需要频繁的查找，很少进行插入和删除操作时，可以使用顺序存储结构。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.当想要访问链表所有元素时，便于从头遍历链表的元素，实现程序的高效性\n2.对表头进行插入删除操作时，有了头结点就方便了该操作，从而实现对链表插入删除操作的统一\n3.可适用于链表为空的情况，此时头结点指针便指向头结点，即为NULL\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3 * (n + 1 - i)。先入队的先出队，先入栈的后出栈，因此最后入栈的3n最先出栈，其次是3(n-1)，递推可得ai\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表：顺序表是连续的，其存储密度高，且找到对应的元素时间复杂度是O（1），但其插入和删除元素需要移动几乎一半的数据，不方便；\n链表：存储空间是动态分配的，不受空间限制，且不需要连续，插入和删改不需要移动大量元素，比较方便。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "0", "answer": "栈顶元素同样永远不能被删除，\n栈需要首尾地址，所以不能删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "当后面的有序表的最小值均比前一个有序表的最大值还要大时，或后面的有序表的最大值均比前一个的最小值还小时,需要n次\n当两个有序表的大小交替排列时，需要2n-1\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表：\n①将表中元素逐个放在连续的空间中；\n②无需为表示元素之间的逻辑关系而增加额外的存储空间；\n③数组大小确定之后就难以更改，空间分配的灵活性较差。\n链表：\n①每个逻辑上相邻的元素在空间上不一定是相邻的；\n②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；\n③可以实时分配或释放空间，表长可以灵活变化。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "如一组序列 {13，79，63，43，16}在第一趟对79的排序中，63朝着与最终排序相反的方向移动，快排里面没有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "1.增加头结点可以使链表第一个节点也和其他节点一样拥有前驱，这样在实现一些操作的时候不需要特殊考虑链表首，让问题更简单。\n2.增加头结点可以使空链表至少拥有一个节点，在实现一些操作的时候不需要特殊考虑空链表的情况，让问题更简单。\n3.一些特殊问题需要用到头结点\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai = 3 * (n - i + 1) 栈是先进后出，当第一个出栈的数为3n时， 说明这个队列是按顺序出队，并且所有元素都进栈后才开始进行出栈操作。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "2/n, (2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n元素进入栈后，不一定全部进入栈后才出栈，元素可能边进栈边出栈。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "如：4,3,2,1。3在第一趟排序中移向了左边。\n有。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "（1）优点：建立独立的顺序栈，操作简单。缺点：分配内存空间的大小不好把握，小了容易溢出，大了浪费内存。\n\n\n\n\n（2）优点：充分利用存储空间，只有在整体内存都用完时才会溢出。缺点：当其中一个栈满时，要左右查询空闲空间，移动元素和栈顶栈底的指针，这一步骤计算复杂，耗时。\n\n\n\n\n（3）优点：链栈一般不用考虑溢出问题。缺点：链栈以指针链接各元素，需要消耗内存空间存放指针。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "宜采用链式存储结构。\n若频繁地对一个顺序表进行插入和删除操作，则需要移动顺序表中大量的元素，耗时长，而在链表中只需要修改被插入或删除结点的前驱结点，并修改这些结点的指针域即可完成操作，耗时短且更为便捷。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "在单链表中不可以,因为无法获取头结点地址进行遍历\n在双链表中可以,获取该指针前后节点之一的地址,即可删除该节点,时间复杂度为O(1);\n在循环链表中可以,需要新建一个工作指针初始值为p进行遍历,直到工作指针的next值等于p,即可删除该节点,时间复杂度为O(n);\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "错误。\n\n\n\n\n①栈底元素通常不是不能被删除，而是不能最先被删除，当栈内其他元素被依次删除后，栈底元素就可以被删除。\n\n\n\n\n②当栈内只有一个元素的时候，该元素也成为栈底元素，此时是可以删除的。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "这个叙述是错误的，虽然栈顶先出，但是可以一边入栈一边出栈，这样顺序就不一定正好相反了。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确\n\n\n\n\n原因：可以一边入栈，一边出栈，极端情况就会变成按入栈顺序出栈\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "采用链式存储结构。\n\n\n\n\n根据实际需要申请内存空间，而当不需要时又可以将不用节点空间返还给系统。在链式存储结构中插入和删除操作不需要移动元素。\n\n\n\n\n1、比顺序存储结构的存储密度大(链式存储结构中每个结点都由数据域与指针域两部分组成，相比顺序存储结构增加了存储空间)。\n\n\n\n\n2、逻辑上相邻的节点物理上不必相邻。\n\n\n\n\n3、插入、删除灵活 (不必移动节点，只要改变节点中的指针)。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "a1=3n,a2=3n-3.....,ai=3(n+1-i)\n原因：队列先入队的先出队，即出队进栈的顺序为3，6，9，12....\n然后栈为先入栈的后出栈，出栈的顺序为3n，3n-3.....\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "错，因为元素值是自己输入的，没有顺序\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "9", "answer": "算法设计时不用特意考虑第一个节点和后继节点的不同，保持操作的统一\n当链表为空时，头指针始终指向头结点，操作时不用考虑是否为空表\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最小需要n次时，是当某一个有序表的表头元素大于另一个有序表中所有元素时，此时归并的表前后n个数的顺序为两个顺序表的顺序。\n最大需要2n-1次时，归并表的最后两个元素为原本两个有序表的最后一个元素，前面的所有元素穿插在归并表的前面。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误的，顺序栈是指用顺序存储结构实现的栈，顺序指的是存储空间有序，并不是指栈中元素大小有序，顺序栈中元素不一定有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "模拟队列：先用S1全部入栈，然后S1出栈给S2入栈，最后S2出栈，通过S1入栈S2出栈实现队列。\n1、入队\nrear后移，把新数据给rear此时指向的空间。rear = （rear+1）%n\n2、出队\nfront后移，输出此时front指针指向的数据。front = （front+1）%n\n3、判断队列是否为空\nrear==front，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.使得在链表头部的操作与在链表中部与尾部一致\n2.使非空链表与空链表的操作统一，防止单链表是空的而设的\n3.指定表的起始位置\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表的优点是可以随机访问数据元素;缺点是大小固定,不利于增删结点。链表的优点是采用指针方式增减结点,只需要改变指针指向,不移动结点。缺点是不能进行随机访问,另外,每个结点上增加指针域,造成额外存储空间增大。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "错，栈底的位置不动，而栈底的元素可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "答：在不涉及插入和删除的时候，或者需要连续空间存储数据的时候，在需要访问大量元素的时候。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "错误。栈底元素是最后删除的元素，而不是不能删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n\n\n\n\n2、为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "不涉及插入和删除操作的时候\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表采用顺序存储，需要预分配大片连续存储空间，存储不便；随机访问，存储密度高，但增加、删改等不方便，需移动大量元素；在逻辑和物理上相邻。\n链表采用链式存储，只需要分配指针（可有头结点），存储方便；便于增加、删改；不需要在存储空间上连续相邻。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "答：\n1.要移动n/2个元素；\n2.要移动（2*n+1)/3;\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不行，如果要删去P指向的结点，就需知道上一个节点。\n\n\n\n\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n\n\n\n\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "1.单链表无法将该节点删除，单链表指针仅指向下一个结点\n2.双链表中若P指向头结点则无法删去，若p指向的不是头结点，则可以删去，时间复杂度为O(1)\n3.循环单链表中，p无论指向哪个结点均可以删除，时间复杂度为O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "最小的比较次数是一个表的所有元素都大于（或小于）另一个表的所有元素\n最多的比较次数是当两个有序表的数据刚好是插空顺序的时候\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2\n(2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1),原因：队列是先进先出，所以队列元素出队顺序是3,6,9...3n，则进栈顺序也是3,6,9....3n；而栈是先进后出，后进先出，n-i+由题，3n是第一个出栈的，则前面n-1个元素都已入栈，可推得出栈顺序为3n，3(n-1),3(n-2)....3，即ai=3*(n-i+1)\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确.\n在没有其他辅助栈的情况下, 栈的出栈顺序和进栈顺序相反.\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，栈FILO\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "顺序表：顺序表是一次性开辟完所有要用的存储空间，开辟完成之后，除了使用的是动态数组，否则不能再更改空间大小；\n链表：链表是每次需要时开辟一个单位的存储空间，每次要增加时需要再申请空间。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "个数是2的n-1次方，除了根节点那一层，其他层都有两种位置可供选择。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.入队：若栈s1未满，将元素压入栈s1中；若s1栈满，但s2栈空，先将s1中元素出栈到s2中，再向s1中插入元素。\n2.出队：将s2元素出栈；若s2为空，则首先将s1中全部元素出栈并压入栈s2中，再将s2中元素出栈。\n3.判断队列是否为空：s1和s2都为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.方便单链表在执行在表头的插入或删除操作，特别是用链表实现栈或队列时\n2.由于头结点的存在，表中第一个元素的结点也有了前驱结点，因此具体实现表的操作时无需特别\n区分第一个元素的结点，从而使算法更简洁\n3.避免头指针置空，减少出现bug的概率\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "频繁地对一个线性表进行插入和删除操作，该线性表宜采用链式存储结构。链式存储结构在逻辑上不必相连，不容易在内存空间当中形成碎片化的小内存；并且链式存储结构在进行插入和删除操作的时候只需要改变结点的指针，无需移动结点。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "①在单链表中不可以，因为无法找到节点p的前驱节点；\n②在双链表中可以，可直接找到节点p的前驱节点，时间复杂度为O(1)；\n③在循环单链表中可以，需遍历整个链表，时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "叙述正确，因为栈的特点是先进后出，后进先出，进栈顺序为1,2,3......n-1，n,而出栈顺序为n,n-1,......,3,2,1\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点：每个栈仅用一个顺序存储空间时，操作简单。\n缺点：分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点：多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。\n缺点：当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点：多个链栈一般不考虑栈的溢出。\n缺点：栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n因为a1=3n, 根据栈的先进后出的原则, 栈顶元素是3n, 说明3n是最后一个出队入栈的\n\n\n又因为队列先进先出, 说明在3n之前, 所有元素都已经出队入栈, 没有元素提前出栈\n\n\n所以最后出栈序列为原队列的逆序, ai = 3(n-i+1)\n\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "4", "answer": "入队：若元素在S1中，则S1入栈。若元素在S2中，则S2出栈并压入栈S1，最后执行S1入栈。\n出队：若元素在S1中，则将S1中n-1个元素出栈并压入栈S2，最后S1出栈即为首元素出队。若元素在S2中，则S2出栈。\n判断队列是否为空：判断S1和S2是否同时为空即可。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2的n-1次方个\n\n\n\n\n除根节点外，每一个结点都有两种可能路径，左边或者右边，所以为2的n-1次方个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错的\n因为顺序栈是指用一个连续的存储单元来存储元素，按照顺序存储，不是按照元素值的大小\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai=3*(n-i+1);\n因为队列的结构特点是先进先出，所以第一个元素是最先入栈的，最后一个元素是最后入栈的，而栈的结构特点是后进先出，所以元素的出栈顺序与入栈顺序相反。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.方便在表头插入和删除；\n2.设置头结点后，无论单链表是否为空，头指针都指头结点，方便单链表的操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "问题涉及到主要涉及访问元素的操作，元素的插入、删除和移动操作极少的情况\n\n\n\n\n这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 O(1)；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 O(n);\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。\n当进行一边入栈一边出栈的操作时，出栈顺序与入栈顺序并不正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "适合使用链表 因为该情况下经常涉及元素的插入、删除和移动，访问元素的需求很少,所以适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 O(n);\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入栈操作。当需要出队时，则对S2执行出栈操作。由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而执行操作前必须判断S2是否为空，否则会导致顺序混乱。当栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n快速排序中没有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "n/2\nsum(i=1--n){(n-i)/(n*(n+1)/2)}\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "（1)、优点：每个栈中元素分别存储，不会混搭，操作简单\n缺点：在初始分配空间小时可能出现溢出，分配空间过大可能造成内存空间浪费\n\n\n\n\n（2)、优点：充分利用存储空间\n缺点：当一个栈满时要想拓展空间需要查询有无多余空间，算法的时间复杂度较大\n\n\n\n\n（3)、优点：空间分配灵活，可以随时控制栈的大小\n缺点：指针更占用储存空间，且移动栈顶指针时相对顺序栈代码更复杂\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "6", "answer": "栈的数据结构为先进后出，后进先出，所以输出顺序与一个队列进队顺序倒着来。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "例如序列：3、2、1、4：在第一趟的过程中，3与2交换、3与1交换，2的位置反而向前了。\n快速排序中，没有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "3", "answer": "错误。\n栈每次只能把元素插入到第一个位置（栈顶），每次只能读取栈顶的元素，栈只能访问栈顶元素，即“后进先出”。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "看情况。\n如果栈底元素是栈中仅剩的最后一个元素，是可以删除的。\n如果栈里面还有其他元素，要等上面压着的元素都删除后栈底元素才能删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "答：2^（n-1）\n除了根节点外每个节点都有两种状态可以选择\n所以剩下n-1个节点都有两种选择，故为2^（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "应该采用链表的存储结构。\n理由如下：\n1、顺序表开辟的内存空间固定，频繁插入可能出现越界访问和内存不够的问题。\n2、顺序表进行插入操作的时候其插入位置的数后面所有数都要向后移动一个内存单元，删除操作的时候其前面所有元素都有向前移动一个存储单元，时间复杂度高，程序运行效率低。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "单链表：每个结点数据结构只有一个指针域，指向下一个结点，没有前驱结点指针，因此不能找到该结点的直接前驱，故无法删除该节点；\n双链表：每个结点有两个指针，分别指向直接前驱和直接后继结点，因此可以删除；\n单循环链表：每个结点只有一个指向直接后继的指针 ，但尾结点指针不可为空，而是指向头结点或者链表的第一个结点，因此，根据指针可以进行循环查找，直到找到结点的直接前驱，因此，该结点可以被删除。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "2的（n-1）次方\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "错误。顺序栈中栈的下标是有序的，但栈中元素不一定是有序的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不能删去。因为若要删去p指向的结点，就需要知道结点的前一结点。\n双链表能通过p指向的结点找到该节点的前驱与后继结点，故能删去。时间复杂度为O（1）。\n单循环链表可以删去，因为通过链表的循环可以找到p指向的结点的前驱结点。时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "采用链式结构储存；因为链表插入删除操作灵活，不必移动节点，只要改变节点中的指针。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n/2\n（2n+1）/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "当后一个有序表的所有元素的排序码值都比前一个有序表的大时,或后一个有序表的所有元素的排序码值都比前一个有序表的小时,\n如{6，7，8，9}与{2，3，4，5},只要n次比较就能够完成排序;\n当两个有序表的所有元素的排序码值交错排列时,如{2，4，6，8}与{3，5，7,9},需要2n一1次排序码比较。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "链表\n理由：\n1. 因为它使线性表的插入和删除操作的时间复杂度为O（1），而顺序存储结构的为O（n）\n2. 插入、删除灵活 ，不必移动节点，只要改变节点中的指针\n3. 表长变化方便，较易实现\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "链表。如果采用顺序表需要先找到这个元素的位置，插入这要将其后面所有元素全部全部后移，删除则需要将后面所有元素前移。而链表只需找到这个元素，改变当前位置前后指针指向，无需前移或后移操作。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "1.防止链表为空；\n2.方便在单链表的特殊操作，保证了单链表操作的统一性。\n3。减少了程序的复杂性， 无论单链表是否为空，加上头结点后处理统一，方便了单链表的操作。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "存在 如3 1 2 5 7序列\n当以3为基准，右指针指2时会与1进行交换\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "1 防止链表为空的时候出现错误，如果当链表为空的时候,单链表没有带头结点,那么它的头指针就为NULL。\n2 是为了方便单链表的特殊操作，能有效减少代码量，在插入在表头或者删除第一个结点时不用考虑特殊情况，删除或插入用户的第一个节点的值和删除或插入中间的值用一样的代码，这样就保持了单链表操作的统一性\n3 同时程序对空表和非空表的处理统一了。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.加入头结点后，无论单链表是否为空，头指针都指向头结点，方便单链表的操作。\n2.当出现如插入在表头，或者是删除第一个结点等特殊操作时，可以更为方便操作，这样保持了单链表操作的统一。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：若仅知道指针p指向某节点，不知道头指针，不能将节点p从相应的链表中删去。\n双链表：可以找到指针p指向结点的前驱结点，从而将节点p从相应的链表中删去。时间复杂度为O（1）。\n循环单链表：可以通过链表的循环找到指针p指向结点的前驱结点，从而将节点*p从相应的链表中删去。时间复杂度为O（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "\n\n单链表: 不可以. 在单链表中, 无法知道*p的前驱节点的地址, 删去会造成断链\n\n\n双链表: 可以, 时间复杂度为O(1). 双链表的节点中存储了前驱结点和后驱节点的地址, 可以通过指针进行修改, 完成删除\n\n\n循环单链表: 可以, 时间复杂度O(n). 单链表需要遍历一整个链表才能查询到*p的前驱结点\n\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "(1)优点：每个栈仅用一个顺序存储空间，方便操作。缺点：分配空间小了，容易产生溢出，分配空间大了，容易造成浪费。\n\n\n\n\n(2)优点：多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点：当要修改元素位置或者查询元素是耗时太久。\n(3)优点：多个链栈一般不考虑栈的溢出。缺点：栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.单链表时无法删除，因为无法找到其前面的节点\n2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1).\n3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "5", "answer": "1.判定单链表是否为空，防止程序运行出现错误\n2.便于操作，对于储存数据的任意节点，都有了自己的前驱，实现对操作的统一（即不需要考虑第一个数据的特殊性）\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "后一个有序表的所有元素的排序码的值都比前一个有序表的大，或者都比前一个小，只需要n次\n如果两次排序表的所有元素排序码值交错排序，就需要2*n - 1次排序\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "插入ai与ai+1之间需要移动（n-i）个元素，即求和(n-i)/(n*(n+1)/2)*(n-i）（i初始值为1，最终值为n）\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确。\n解释：\n1.根据栈的操作可知，先进栈的元素后出栈，后进栈的元素先出栈，即栈元素的进栈出栈顺序满足LIFO。由题意，在n个元素进栈后，则它们的出栈顺序一定和进栈顺序正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "s1进行入队操作，s2进行出队操作。\n1：判断队列是否为空，当队列满时无法进栈。\n2：判断队列是否为空，当队列空时结束出栈。\n3：判断s1与s2不同时为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "不正确。\n\n\n\n\n\n栈底元素是最先入栈的元素\n\n\n根据栈先进后出的规则，栈底元素最后一个出栈，是可以被删除的\n\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "0", "answer": "平均移动的元素个数：(n-1)/2\n平均移动的元素个数：[n(n-1)]/(n+1)\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "应该采用链式存储结构。因为采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱，并修改这些结点的指针域，不需要移动元素；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表的优点是可以随机访问数据元素;缺点是大小固定,不利于增删结点。链表的优点是采用指针方式增减结点,非常方便(只需要改变指针指向,不移动结点);缺点是不能进行随机访问,另外,每个结点上增加指针域,造成额外存储空间增大。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "错。\n栈是一种特殊的表，这种表只在栈首进行插入和删除元素。\n当栈内只有一个元素时，栈首就是栈底，可以删除元素。\n当栈底元素被删除后才算空栈。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "一个数的前面有比它更大的数且后面有比它更小的数，在更大的数的移动中，该数会向与最终排序相反方向移动。\n快速排序中也有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "4", "answer": "头结点是单链表第一个元素之前的一个结点，优点有：\n1、便于找到链表并使用其中的数据\n2、方便插入删除的特殊情况的操作\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "1.方便再头节点前插入或删除结点。\n2.出现多个链表时，可以运用结构体分开赋值头结点。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.头结点作为哨兵节点，可以有效减小程序的复杂性和出现bug的概率。因为不带头结点的单链表对于第一个节点的操作与其他节点不一样，需要特殊处理，会更加复杂。\n2.设置头结点也可以防止链表是空的，设置了头结点后，如果链表为空，则带头结点的头指针指向头结点。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，栈底元素可以删除,根据先进后出，栈底元素只是最后删除，删除后栈为空栈\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "看不懂题目^~^\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "因为该二叉树有n个节点并且高度为n，所以每层只有一个结点，除根结点那层，每层都有左子树和右子树的两种可能，故总共有2^(n-1)个这样的二叉树。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "在等概率的前提下，插入一个元素\n需要平均移动的元素个数是n/2个。\n元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数是（2n+1)/3个。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "使用两个栈s1和s2，分别按照元素加入的逆序和顺序保存元素，在适当的时机将元素在两个栈中进行转移，从而模拟队列的操作。\n令s2中元素的顺序为自底向上与元素添加顺序一致，s1与其相反，则：\n入队：若s2不满，将入队元素入s2栈；若s2满，s1空，则将s2中的元素退栈到空，并按退栈顺序压入s1，将入队元素压入s2栈；若s2满，s1空，不能入队。\n出队：若s1不空，则将s1中栈顶元素出栈，作为出队元素；若s1空，s2不空，将s2中的元素退栈到空，并按退栈顺序压入s1，从s1栈顶元素出栈，即队列出队元素；若s1空，s2空，队空，不能出队。\n判断队空：若s1空，s2空，则队空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "当最小需要比较n次时，说明两个表中一个表的元素全部小于另一个表中的第一个元素；\n\n\n\n\n当最多需要比较2n-1次时，说明两个表中A表中的第i个（0<=i<=n-2）元素的大小都介于B表中第i个与第i+1个（0<=i<=n-2）元素之间，A表最后一个元素比B表最后一个元素大。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1) 对带头结点的链表,在表的任何结点之前插入结点或删除表中任何结点,所要做的都是修改前一结点的指针域,因为任何元素结点都有前驱结点。若链表没有头结点,则首元素结点没有前驱结点,在其前插入结点或删除该结点时操作会复杂些。 (2) 对带头结点的链表,表头指针是指向头结点的非空指针,因此空表与非空表的处理是一样的。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "顺序表存储数据实行的是一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外），数据之间紧密贴合，不留一丝空隙。而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请，数据之间的逻辑关系依靠每个数据元素携带的指针维持。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "单链表不可以\n双链表可以，时间复杂度为O（1）\n循环单链表可以，时间复杂度为O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "9", "answer": "（1）优点：每个栈仅用一个顺序存储空间时，操作简单；缺点：容易造成空间溢出或浪费\n（2）优点：充分利用存储空间 ；缺点：查询左右空闲单位时比较复杂切耗时\n（3）优点：不用考虑溢出问题 ；缺点：比顺序存储多占用空间\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "当存取操作明显多于插入和删除操作，并且表的空间容易估计时\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表，不可以，无法找到前驱和后继\n双链表，可以，能找到前驱和后继，时间复杂度为O（1）\n循环单链表，可以，能找到前驱和后继，但要遍历一遍表才能找到前驱，总时间复杂度为O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "单链表的不行，如果要删去P指向的结点，就需要知道该结点的前后结点。没有头结点，无法从头遍历。\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "0", "answer": "双端队列是指允许两端都可以进行入队和出队操作的数列；\n而受限的双端数列包含两种：\na.输出受限的双端队列：允许在一段进行插入删除，而另一端只允许插入的双端队列\nb.输入受限的双端队列：允许在一段进行插入删除，而另一端只允许删除的双端队列\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "链表。直接对结点进行处理，不用像线性表对全部数据都要进行处理。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "//判断为空\nint QueueEmpty(Stack S1,Stack S2){\nif(StackEmpty(S1)&&StackEmpty(S2)){\nreturn 1;\n}\nelse return 0;\n}\n\n\n\n\n//入队算法\nint EnQ(Stack &S1,Stack &S2,Elemtype e){\nif(!StackOverflow(S1)){\nPush(S1,e);\nreturn 1;\n}\nif(StackOverflow(S1)&&!StackEmpty(S2)){\nprintf(\"队列满\");\nreturn 0;\n}\nif(StackOverflow(S1)&&StackEmpty(S2)){\nwhile(!StackEmpty(S1)){\nPop(S1,x);\nPush(S2,x);\n}\nPush(S1,e);\nreturn 1;\n}\n}\n\n\n\n\n//出队算法\nvoid DeQueue(Stack &S1,Stack &S2,Elemtype &x){\nif(!StackEmpty(S2)){\nPop(S2,x);\n}\nelse if(!StackEmpty(S1)){\nprintf(\"队列为空\");\n}\nelse{\nwhile(!StackEmpty(S1)){\nPop(S1,x);\nPush(S2,x);\n}\nPop(S2,x);\n}\n}\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n快速排序不会出现类似情况，因为每一次都是二分\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "9", "answer": "错误。\n栈底元素是最先被插入的元素，也是最后才能被删除的元素。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "3", "answer": "错误。栈顶元素执行的是出栈操作，不可以删除。如果删除，就不知道当前栈顶元素是什么，也就不能出入栈。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "1.优:逻辑简单 缺:空间浪费大，数组长度不方便确定\n2.优:空间利用率较高 缺:数组长度不方便确定\n3.优:储存空间不连续 缺:逻辑上较难理解\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "每个节点就一个孩子，但是可以是左孩子和右孩子，所以有2的n-1次方个二叉树\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比如 1 6 3 8 2 经过一次冒泡排序后，变成1 3 6 2 8 则3 是与最终相反的方向移动\n快速排序中则没有这种现象出现\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "不一定。进栈元素个数跟出栈个数不一定每次都一样。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "由于队列是先进先出的，所以进队序列和出队序列相同，这样进栈的次序亦为3/6/9......。而栈是先进后出的，即3n为最后进栈，导致其最先输出，其他数字同理。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)\n优点：每个栈仅用一个顺序存储空间，操作简单。\n缺点：提前分配内存空间。如果分配空间小了，容易产生内存溢出，但如果分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)\n优点：多个栈共用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。\n缺点：当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)\n优点：多个链栈一般不考虑栈的溢出。\n缺点：栈中元素以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "队列是先进先出的，所以进队序列与出队序列相同。故进栈顺序为3、6、9、12、... 3n。栈是后进先出的，a1=3n说明最后进栈元素最先出栈，所以ai=3(n-i+1).\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：每个栈仅用一个顺序存储空间时，操作简单；\n缺点：分配空间小，容易产生溢出，分配空间大，容易造成浪费，各栈不能共享空间；\n（2）优点：多个栈仅用一个顺序存储空间，充分利用了存储空间；\n缺点：当栈满时需要查询有无空的位置，需要移动元素和相关的指针，时间复杂度高；\n（3）优点：多个链栈一般不考虑栈的溢出；\n缺点：栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "\n\n\n方便单链表的特殊操作,插入在表头或者删除第一个结点，即方便运算的实现\n\n\n\n\n\n\n无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了\n\n\n\n\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，先进后出，后进先出，出栈顺序和进栈顺序一定正好相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "ai=3*(n-i+1)因为3n为第一个出栈所以其为最后一个出队列。所以按顺序进队列进栈。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "4 3 2 1 变1 2 3 4\n没有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "对，先进后出，出栈顺序和进栈顺序正好相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n\n\n\n\n待排序序列后面的若干排序码比前面你的排序码小，则在冒泡排序中排序码可能与最终它应移向的位置相反的方向移动。\n如：初始：4、3、2、1；第一次排序：3、2、1、4；第二次排序：2、1、3、4；最终：1、2、3、4；\n3第一趟移向了与最终位置相反的方向。\n快速排序中没有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "在a(i)之后插入一个元素需要移动(n-i)个元\n素,而要插入的元素在出的可能性为2*(n-i)/n/\n(n+1),那么平均要移动(n-i)×(2*(n-i)/n/\n(n+1))个元素\n\n\n\n\n.\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n快速排序中也有这种现象。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "9", "answer": "宜采用链表存储结构，因采用顺序存储结构每次删除和插入都需要移动大量元素，且因未知插入和删除操作数总数需要预先分配较大空间，而在链表结构中只需要修改指针的指向和动态分配内存即可实现。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.单链表无法删去。\n2.双链表可以删去，时间复杂度是O（1）。\n3.循环链表可以删去，时间复杂度是O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "n个节点时，除了叶子节点外，每个节点的有左儿子与右儿子两种选择，因此个数为2^(n-1)。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "对于单链表：若想要删除结点p，必须知道p的前一个结点，使前一个结点指向指针p的下一个结点，再释放p空间。现在不知道前一个结点，故不能删除。\n对于双向链表：知道p指向的结点，将p->next赋值给p的前一个结点的next，将p->next->front赋值给p->front，如此，便删除了p\n对于循环链表：知道p指向的结点，再由p的下一个结点指向p的下一个结点的下一个结点，又由于这是一个单向循环链表，所以最终可以遍历到p的前一个结点，将p->next赋值给p前一个结点的next，就删除了*p。\n时间复杂度全为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "答：此叙述是错误的。\n1.当栈只有一个元素时，此栈也可以进行删除元素的操作，而这一个元素也被称为栈底元素。\n2.当栈底元素都删除时，栈底元素也能进行删除操作。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "9", "answer": "利用两个栈S1和S2来模拟一个队列，当需要向队列中插入一个元素时，用S1来存放已输入的元素，即S1执行入栈操作。\n当需要出队时，则对S2执行出栈操作。\n由于从栈中取出元素的顺序是原顺序的逆序，所以必须先将S1中的所有元素全部出栈并入栈到S2中，再在S2中执行出栈操作，即可实现出队操作，而执行操作前必须判断S2是否为空，否则会导致顺序混乱。\n当栈S1和S2都为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "在等概率的前提下，插入一个元素需要平均移动的元素个数是n/2。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.这是第一点答案：错误\n\n\n\n\n2.这是第二点答案：栈底的元素最先被插入，从而最后被删除，但是当栈底元素成为栈顶元素时，则可以被删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "错误，顺序栈是指用顺序存储结构实现的栈，栈中的元素不一定是有序的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "（1）优点：每个栈仅用一个顺序存储空间，操作简单；缺点：分配空间容易溢出或者浪费空间。\n(2)优点：多个栈用一个顺序存储空间，只有整个存储空间满了才会溢出；缺点：当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点：多个链栈一般不考虑栈的溢出。缺点：栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，顺序栈顺序栈是指利用顺序存储结构实现的栈，不是指元素值的大小是有序的栈\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，栈的结构就是后进先出，每次都是pop栈顶元素，如果可以随意的删除栈底元素，那就不是栈了。\n当只剩下最后一个数字时，也就是栈底等于栈顶时，才可以删除栈底。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "在等概率的前提下，插入一个元素需要平均移动的元素个数是n/2;\n元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数是（2n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "2", "answer": "叙述错误\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误，当栈中只有一个元素的时候，此时栈底元素就能删除了\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "利用两个栈s1和s2来模拟一个队列，当需要向队列中插入一个元素时\n用S1来存放已输入的元素，即S1执行入队操作。当需要出队时，则队S2执行\n出栈操作。必须先将S1中所有元素出栈并入栈到S2中，再在S2中出栈\n即可实现出队操作，而在执行此操作之前必须判断S2是否为空，否则导致顺序混乱\n当栈S1和S2都为空时队列为空。\n即：\n①对S2的出栈操作用作出队，若S2为空则先将S1中所有元素送入S2\n②对S1的入栈操作用作入队，若S1满，必须先保证S2为空，才能将S1中\n的元素全部插入S2中\n//入队算法\nint EnQ(Stack &S1,Stack &S2,Elemtype e){\nif(!StackOverflow(S1)){\nPush(S1,e);\nreturn 1;\n}\nif(StackOverflow(S1)&&!StackEmpty(S2)){\nprintf(\"队列满\");\nreturn 0;\n}\nif(StackOverflow(S1)&&StackEmpty(S2)){\nwhile(!StackEmpty(S1)){\nPop(S1,x);\nPush(S2,x);\n}\nPush(S1,e);\nreturn 1;\n}\n}\n//出队算法\nvoid DeQueue(Stack &S1,Stack &S2,Elemtype &x){\nif(!StackEmpty(S2)){\nPop(S2,x);\n}\nelse if(!StackEmpty(S1)){\nprintf(\"队列为空\");\n}\nelse{\nwhile(!StackEmpty(S1)){\nPop(S1,x);\nPush(S2,x);\n}\nPop(S2,x);\n}\n}\n//判断队列为空算法\nint QueueEmpty(Stack S1,Stack S2){\nif(StackEmpty(S1)&&StackEmpty(S2)){\nreturn 1;\n}\nelse return 0;\n}\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "除根节点外每个节点都有两种状态可以选择（左偏 或者右偏）\n所以剩下n-1个节点都有两种选择，故为2^（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2的n-1次方个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "n/2；\n（3*n+1）/4；\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "6", "answer": "错误，栈底元素是最后被删除的元素\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "在需要查找某个元素并且不需要增加或者删除元素的程序中使用顺序表比链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "防止单链表为空；\n插入与删除操作是便于对第一个位置进行操作；\n统一对链表的操作；\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "栈的特点是FILO，队列的特点是FIFO。\n用一个栈1用于入队，一个栈2用于出队，在栈1实现对队尾的元素的操作；通过将栈1 的元素按照弹出的顺序入栈栈2，在栈2实现对队头的元素的操作。\n1.入队：将要入队的数据直接入栈到栈1\n2.出队：判断用于出队的栈2是否为空，为空则将栈1栈顶依弹出并入栈至栈2，不为空则直接栈2进行pop操作\n3.判空：两个栈都为空则队列空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "适用于需要大量访问元素的 而少量增添/删除元素的程序。\n顺序表适于做查找这样的静态操作,链表适于做插入和删除这样的动态操作。如果线性表的变化长度变化不大,且其主要操作是查找,则采用顺序表;如果线性表的长度变化较大,且其主要操作是插入、删除操作,则采用链表。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "ai(1≤i≤n)：3n、3(n-1)、3(n-2)、3(n-3)、…3\n\n\n\n\n原因：\n已知这组数经过一个队列后进入一个栈在出栈，由队列的性质——先进先出，可知出队后的顺序不变，3n为最后一个数。在进栈过程中，先进后出，而3n是最后一个进栈，只有一种可能就是栈的大小为n，所以从队列进入的元素实现逆序输出，故答案为：ai(1≤i≤n)：3n、3(n-1)、3(n-2)、3(n-3)、…3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "栈的特点是后进先出，队列的特点是先进先出了，用S1和S2模拟一个队列时，把每个元素一个个压入栈S1，模拟队列中元素的入队。出队时，将栈S1的元素弹出并逐个压入栈S2中，因为s1的栈底成为s2的栈顶，实现了先进先出。\n描述1：\n入队，将元素压入栈S1\n描述2：\n出队，将元素弹出S1并且逐个压入S2，当S1为空时，将S2的栈顶弹出，即实现了出队\n描述3：\n判断队列是否为空，当S1和S2都为空时候，队列为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "确定第一个节点的位置。对第一个节点的操作可以与其他节点统一。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "1.指定表的起始位置\n2.对带头结点的链表，表头指针是指向头结点的非空指针，因此空表与非空表的处理是一样的。\n3. 带头结点的链表，其头结点不随操作而改变，可以减少错误。\n4.增加了链表的顺序性，减少bug\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "n个节点高度为n,那么不同种类就是由你结点是左孩子还是右孩子决定的，一共n-1条边，就是2的n-1次方种二叉树。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "在表首插入元素不需要特殊处理、防止单链表为空。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "纯粹的数据输入，很少对数据非结尾处进行增删时，使用顺序表更好\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表存储的特点：\n1.无需为表示表元素之间的逻辑关系增加额外的存储空间\n2.可以方便随机地存取表中任一位置的元素\n3.插入和删除操作不方便，除去表尾位置，在其他位置执行插入或删除操作均需移动大量元素\n4.要求占有连续的存储空间，需事先确定分配空间的大小，在表长变化大时难以确定空间的大小\n链表存储的特点：\n1.插入和删除运算很方便，执行插入或删除操作只需改变指针，无需移动元素\n2.不要求占有连续的存储空间，无需事先确定分配空间的大小\n3.用指针表示元素间的逻辑关系，增加了额外的存储空间\n4.存取表中任一位置元素的操作不方便，特别是存取表后部的元素时，需遍历前面的大量元素\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "5", "answer": "顺序存储结构用一段连续的存储单位依次存储线性表的数据元素。\n链表采用链式存储结构，用一组任意的存储单位存放线性表的元素，\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "9", "answer": "栈FILO，当栈中有多个元素时，栈底是不能删除的；当仅有一个元素时，其同时为栈顶和栈底，可以删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "1、先判断S1是否栈满，S1满则将S1数据转移到S2中，S1没满就直接存入S1\n2、先判断S2是否有数据，S2有数据直接对S2进行出栈操作，S2没数据就将S1数据转移到S2中再对S2进行出栈操作\n3、S1S2都为空表示队列为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表的不行，如果要删去P指向的结点，就需要知道该结点前一个结点。\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1).\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "6", "answer": "1.可只通过头结点找到整个链表\n2.检查链表是否为空时，只需检查头结点指针是否为空。\n3.简化表头插入、删除元素的操作，无需在表头单独设计算法。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.方便对表首元素的插入和删除进行处理\n2.方便处理空表\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "方便在第1个位置进行插入、删除操作时同其他位置一样。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "冒泡排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动。\n比如，\n对记录13,79，56,20,40，进行冒泡排序，第一次冒泡后的结果为13,56,20,40,79.\n排序码56朝着与最终排序相反的方向移动了。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "3", "answer": "S1执行入队操作，S2执行出队操作\n当一个元素要入队时，若S2不为空，则将S2中的数据放入S1，再将这个数据放入S1\n当一个元素要出队时，如果S1不为空，则将S1中的数据放入S2，再将这个数据从S2中弹出\n如果两个栈都为空，则队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "ai=33-3n，队列FIFO，出队后以同样顺序入栈，栈FILO，因此倒序输出\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "否。栈底在上面元素北删除后，成为栈顶，可以被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "9", "answer": "入队时：S1没满时，直接压入S1，S1满了，压入S2。\n出队时：S2非空时，直接输出S2，S2为空时，将S1压入S2中，再输出。\n判断队列是否为空：若S1，S2都为空时，队列即为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "入队:\n入栈S1\n\n\n\n\n出队:\nS2为空，S1不为空时，S1所有元素依次出栈，出栈后立刻进入S2，那之后，S2出栈一个元素\nS2不为空时，S2出栈一个元素\n\n\n\n\n队列是否为空:\n若S1为空且S2为空，则队列为空\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "n/2.2n+1/3.\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错，顺序栈的意思是顺序存储结构，不是代表存储元素一定有序。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "链式存储结构\n因为链式存储结构，插入和删除较为简单，不需要移动元素\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "链式结构储存\n因为链式结构只需要从头搜索到需要改变的地方，更改其前驱的指针指向的地址即可（插入多一步指针指向后驱结点）。\n而顺序表需要移动整个表的结构，时间复杂度更高\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n栈有可以随时出栈进栈的特性，如果不是有规律的一次出栈一次进栈，则出栈顺序未必是进栈顺序的倒序。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "h(n)=C(2n,n)/(n+1) (n=1,2,3,...)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "如果在待排序序列的后面的若干排序码比前面的排序码小，那么在排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动。如 4321 3214 2134 1234 中的3\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "0", "answer": "正确,栈遵循先入后出原则\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "待排序序列后面的若干排序码比前面的排序码小，则在起泡排序过程中排序码可能与最终它应移向的位置相反的方向移动。\n比如：初始：4.3.2.1\n第一次排序：3.2.1.4\n第二次：2.1.3.4\n最终：1.2.3.4\n3第一趟移向了与最终位置相反的方向\n没有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "1、当一个有序表的所有元素比另一个有序表的所有元素都大时，此时一个有序表中的每个元素只需要进行一次比较，故一共需要比较n次。\n\n\n\n\n2、当一个有序表和另外一个有序表的元素交错时，此时一个有序表的中的每个元素都要比较2n次，故一共需要比较2n-1次\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一种情况下,这两个被归并的表中其中一个表的最大关键字不大于另一表中最小的关键字,也就是说,两个有序表是直接可以连接为有序的,因此,只需比较n次就可将一个表中元素转移完毕,另一个表全部照搬就行了。\n第二种情况下,是两个被归并的有序表中关键字序列完全一样,这时就要按次序轮流取其元素归并,因此比较次数达到2n-1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "不涉及插入和删除操作的时候\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.入队\n\n\n\n//入队算法\nint EnQ(Stack &S1,Stack &S2,Elemtype e){\n    if(!StackOverflow(S1)){\n        Push(S1,e);\n        return 1;\n    }\n    if(StackOverflow(S1)&&!StackEmpty(S2)){\n        printf(\"队列满\");\n        return 0;\n    }\n    if(StackOverflow(S1)&&StackEmpty(S2)){\n        while(!StackEmpty(S1)){\n            Pop(S1,x);\n            Push(S2,x);\n        }\n        Push(S1,e);\n        return 1;\n    }\n} \n\n2.出队\n\n\n\n\n//出队算法\nvoid DeQueue(Stack &S1,Stack &S2,Elemtype &x){\nif(!StackEmpty(S2)){\nPop(S2,x);\n}\nelse if(!StackEmpty(S1)){\nprintf(\"队列为空\");\n}\nelse{\nwhile(!StackEmpty(S1)){\nPop(S1,x);\nPush(S2,x);\n}\nPop(S2,x);\n}\n}\n\n\n\n\n3.判断是否为空\n\n\n\nint QueueEmpty(Stack S1,Stack S2){\n    if(StackEmpty(S1)&&StackEmpty(S2)){\n        return 1;\n    }\n    else return 0;\n} \n\n\n\n\n\n\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "表长已知且固定时，或需要对表中任一位置的元素进行存取时。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，栈满足先进后出原则，如果是栈中有n个元素，则出栈必和进栈顺序相反。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "例如，30，20，10，15在第一次冒泡后序列变为20，10，15，30，20朝着与最终排序相反的方向移动了。\n在快速排序中也会出现这种情况，例如：对序列90，30，20，50，60以90划分时，序列变为60，30，20，50，90。其中60也朝与最终排序相反的方向移动了。\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "当后一个有序表的所有元素的排序码值都比前一个有序表的大时，或后一个有序表的所有元素的排序码都比前一个有序表的小时，只要n次比较就能完成排序；当两个有序表的所有元素的排序码值交错排列时，需要2n-1次比较。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "如该数组：5,4,1,2,3\n第一趟冒泡排序时4向前移动，与最终方向相反。\n快速排序不会出现这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "5", "answer": "在等概率的前提下，插入一个元素，需要平均移动的元素个数是n/2。\n若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)是2(n+1)/3。\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n\n\n\n\n2、为了方便单链表的特殊操作，插入在表头或者删除第一个结点。这样就保持了单链表操作的统一性。\n\n\n\n\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n\n\n\n\n4、对单链表的多数操作应明确对哪个结点以及该结点的前驱。不带头结点的链表对首元结点、中间结点分别处理等；而带头结点的链表因为有头结点，首元结点、中间结点的操作相同,从而减少分支，使算法变得简单，流程清晰。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.n/2\n2.(n-1)/2+1\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "2^（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不可以直接删去, 双链表和循环单链表中可以直接删去. 若要删除链表中的一个节点, 就需要知道该节点的前驱和后继. 已知某节点的指针, 在单链表双链表和循环单链表中都可以获取到这个节点的后继.\n\n\n\n\n但是之所以不能在单链表中删除节点. 是因为删除操作还需要知道被删除节点的前驱. 仅仅知道被删除节点的地址, 而不知道链表头结点, 就无法找到被删除节点的前驱.\n\n\n\n\n而在双链表和循环单链表中, 可通过直接访问节点的前驱或通过遍历链表找到被删除节点的前驱. 从而正确的维护链表, 删去需要删除的节点.\n\n\n\n链表类型\t单链表\t双链表\t循环单链表\n时间复杂度\tN/A\tO(1)\tO(n)\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "1.方便插入或删除第一个节点的特殊操作，保证处理第一个节点和后面的节点的时候设计的算法相同；\n2.不论链表是否为空，链表头指针不变，空表和非空表的处理可以统一。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "5\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "顺序表的优点是可以随机访问数据元素，缺点是大小固定,不利于增删结点。\n链表的优点是采用指针方式增减结点(只需要改变指针指向,不移动结点)，缺点是不能进行随机访问。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "应该采用链式存储结构。因为采用链式结构存储线性表，插入和删除操作需要从头结点起查找被插入或删除结点的前驱结点，并修改这些结点的指针域，查找过程平均移动指针域为表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中的一半元素。但移动指针域操作比移动元素操作花费的时间少得多。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.优点是操作简单，缺点是分配空间过小，容易溢出，过大则会导致浪费，各栈不能共享空间\n\n\n\n\n2.优点是可以共享空间，充分利用了存储空间，缺点是如果一个栈满了就需要左右查询是否有空闲单位，要修改栈底和栈顶指针，比较麻烦\n\n\n\n\n3.优点是不需要考虑溢出问题，缺点是要用到指针相连接，多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.入队：\n将需要入队的元素入栈到S1(此时栈S1的元素从栈顶到栈底的排列顺序相对于元素的入队顺序为逆序）。\n2.出队：\n先将栈S1中的所有元素出栈并入栈到S2(此时栈S2的元素从栈顶到栈底的排列顺序相对于元素的入队顺序为顺序），再从S2中出栈。\n3.判断队列是否为空：\n当栈S1和栈S2都为空时，则队列为空。否则，队列不空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "不需要移动元素的时候顺序表比链表好。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "答：ai = 3n-3(i-1)，1<=i<=n ，原因是：队列里的元素是在队首出队列然后入栈，而栈里的元素是在栈顶出栈。队首元素出队后是作为栈底元素入栈的，\n\n\n\n\n当队列里的所有元素出队并入栈后，栈顶元素为3n，栈底元素为3，且出栈时输出序列满足等差数列，所以ai = 3n-3*(i-1)，1<=i<=n。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "宜采用链式存储结构。因为采用链式存储结构，插入和删除操作需要从头指针起查找插入、删除结点的前驱结点，并修改这些结点的指针域，查找过程需要平均移动指针域或表长的一半；而采用顺序结构存储线性表，插入和删除操作需要平均移动表中一半元素。移动指针域的操作比移动元素操作花费的时间少得多。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "n/2\n2(n+1)/3\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "9", "answer": "1.简化在表首进行插入和删除操作等边界情况的处理，保持操作的统一性\n2.统一空表和非空表的处理，减少程序复杂性\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "采用链表存储结构，链表插入和删除速度快，只需改变节点中指针的指向。\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表：知道p指向某节点，只能知道p的后继，因为不知道头指针，也无法遍历。因此不能删除该节点。\n双链表：知道前驱和后继，可以直接删除后继，复杂度O1；\n循环单链表：可以循环遍历一遍找到该节点，删除，复杂度On\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "8", "answer": "1.基于存储的考虑\n难以估计线性表的长度或存储规模时用链表存储，有固定长度的用顺序表存储方便。\n\n\n\n\n2.基于运算的考虑\n常做按序号访问元素时，顺序表时间复杂度为O（1），链表为O（n），显然用顺序表。\n\n\n\n\n按值访问元素时二者一样。\n\n\n\n\n常进行插入、删除操作时，最优使用链表存储。\n\n\n\n\n3.基于使用环境的考虑\n顺序表存储较为容易实现，任何语言中都有数组类型；而链表操作是基于指针的较为复杂，指针也不稳定，出错问题就复杂。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "答：\n1.入队：S1用来模拟入队，当元素都入队到栈S1。\n2.出队：要出队时，先判断S2是否为空，不空则S1先出栈，将元素出栈到栈S2中，在在S2中进行出栈操作，即实现出队操作。\n3.判断队列是否为空：当S1和S2两个栈均为空时，队列为空。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "1.对第一个元素的插入和删除操作就跟其他结点一样，不用再单独写第一个节点的操作，减少代码量。\n2.不管链表是否为空，头指针都会指向头结点，不会为NULL，不容易出错。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n理由1：最根本原因是：可以边入栈边出栈，所以出入栈顺序没有什么关联。\n比如随便举个反例:\n进站1，2，3，4\n操作顺序PPOPOOPO\n得到的出栈顺序是2,3,1,4。\n出栈顺序和入栈顺序不相反\n理由2：元素个数为n，则合法的栈出站顺序=Catalan数：C(2n,n)/(n+1)\n一定相反的话就说明只有一种啦，和这个基本规律矛盾(doge)\n\n\n\n\n但这句话，对“在n个元素进栈后”有点理解不明白。\n如果n个元素进栈是连续进栈，不断PUSH，全部进入以后再出栈，那一定是相反的。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "应采用链式储存结构；原因：若采用顺序表，插入删除频繁，每次都要大规模的移动元素，使代码运行时间加大，降低了运行效率，而链式储存的链表，储存数据的方式灵活，方法简单，不必移动太多已有的数据元素，大大节省了运行时间，提高代码的运行效率\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "最少的比较次数的情况是：若A表中所有元素都小于或者大于B表元素，则A1比较完B表元素后，直接拼接即可。\n最多比较的情况是：A、B表元素大小相互交错，A表的每个元素都要与B表元素相比，如A1和B1相比，只能确定一个元素的位置，另一个还要与另一表中下一元素再比较一次。\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "采用链式结构。链表插入和删除比较灵活，不需要移动节点，只需要改变指针。删除节点之后空间会直接返还给系统，不需要顺序表那样繁琐的移动数据的操作，移动指针花费的时间比移动数据要少，且移动和删除数据时不再需要移动元素来腾出空间\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误。\n顺序栈表示按入栈顺序存储元素，而不是按照元素的大小顺序存储。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "7", "answer": "链表\n顺序表进行插入和删除需要移动大量元素，而；链表在执行插入或删除运算时，不再需要移动元素\n\n\n", "q_id": "003", "question": "若频繁地对一个线性表进行插入和删除操作，该线性表宜采用何种存储结构，为什么？", "reference1": "在这种情况下，建议采用链式存储结构。由于在顺序表中频繁进行插入和删除操作时，需要移动大量元素，操作耗时较长。而在链表中，只需修改插入或删除节点的前驱节点，并调整相应的指针即可完成操作，效率更高且操作更加便捷。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "{49，38，65，97，76，13，27，49} 使用冒泡排序后，第一趟排序后的76， 快速排序无此现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "7", "answer": "1、用于大小确定，长度变化不大的情况，可节约存储空间\n2、用于查找的操作较多，较少进行插入删除操作\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表存储特点：\n将表中元素一个个存入一组连续的存储单元中，这种存储结构是顺序结构。采用顺序存储结构的线性表简称为“ 顺序表”。\n优缺点：1、存取速度高效，通过下标来直接存储2、插入和删除比较慢3、不可以增长长度4、存储空间是静态分配的，在程序执行之前必须明确规定它的存储规模，事先对“MAXSIZE”要有合适的设定\n链表存储特点：\n链表存储是在程序运行过程中动态的分配空间，只要存储器还有空间，就不会发生存储溢出问题\n优缺点：插入和删除速度快，保留原有的物理顺序。查找速度慢，因为查找时，需要循环链表访问。不用事先估计存储规模，但链表的存储密度较低。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "不正确，当栈中只有一个元素时，这个元素是栈底元素，可以删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "出根节点外每个节点都有两种状态可以选择，所以剩下n-1个节点都有两种选择，故为2^（n-1）\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "1、表长范围不大，并且可以确定变化范围。\n2、很少进行插入删除操作。\n3、经常按照元素下标序数访问元素。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "（1）优点：简单易懂。\n缺点：空间损失比较大。\n（2）优点：空间利用率高。\n缺点：使用时比较麻烦费时间。\n（3）优点：栈不会溢出。\n缺点：占用空间较多，切独立链栈之间要用指针链接。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "0", "answer": "2*n-1个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "第一种情况，其中一个表的最大值小于另一个表的最小值。\n第二种情况，a1<b1<a2<b2<......\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "有n个节点并且高度为n的二叉树的个数是2n-1\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "这是错误的，只是栈底元素最先入栈却最后被删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，分配空间大了，容易造成浪费，各栈不能共享空间，是分配空间小了，容易产生溢出。\n\n\n\n\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。\n\n\n\n\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "第一点答案：错误\n\n\n\n\n第二点答案：当入栈顺序为123时，出栈顺序为132；这是因为并非会先全部进栈之后才可以入栈，可以两者同时进行，此时两者的顺序就并非逆序\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "1.入队:将元素全部压入S1，在S1进行入栈操作\n2.出队:将 S1 中的所有元素全部出栈并压入到 S2 栈中，再在 S2 中执行出栈操作\n3.判断为空:S1和S2都为空栈\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表的不行，如果要删去P指向的结点，就需要知道该结点前一个结点\n双链表可以，因为双链表可以通过p指向的结点找到该结点的前驱结点和后继结点，时间复杂度O(1)\n单循环链表也可以，链表的循环可以得到P指向的结点的前驱结点，时间复杂度O(n)\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "4", "answer": "如何使用s1和s2模拟队列：\ns1模拟入栈，把元素逐个元素入栈。\ns2模拟出栈，当要出栈时，出栈s1,再入栈s2。再将s2出栈，得到出队。\n\n\n\n\n判断是否为空：\n如果s1和s2均为空，则队列为空\n\n\n\n\n插入\n判断s1是否栈满，如果是，则无法再入栈\n如果s1未满，则入栈\n\n\n\n\n删除\n判断s2是否为空，若不为空，则直接出栈；\n如果为空，则从s1出栈，再入栈到s2，再出栈。\n\n\n", "q_id": "011", "question": "简述如何使用栈S1和S2来模拟队列。并且描述1、入队 2、出队 3、判断队列是否为空 三种运算的操作过程。", "reference1": "假设输出元素序列为Y，对于n个元素输入序列X，若按照如下过程进行操作：（1）X中元素按序全部顺序进入S1中。（2）依次将S1中元素出栈并压入S2栈中，直到S1栈空为止。（3）依次将S2中元素出栈并压入Y，直到S2栈空为止。则输出序列顺序与输入序列X完全相同，符合队列先进先出特点。所以两个栈模拟队列三个功能操作过程可描述为：（1）enqueue（入队）：入队元素直接放入S1栈中（Push）。（2）dequeue（出队）：若S2栈不为空，则取S2栈栈顶元素作为出队元素；否则将栈S1中元素全部搬到S2中，再取S2栈栈顶元素（Pop）作为出队元素（这可视为将入队元素分段地通过S1和S2栈）。（3）isEmpty（判空）：若S1和S2两个栈均为空，则队列为空；否则不为空。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "由于队列是先进先出原则，所以进队序列和出队序列相同，这样进栈的序列为3、6、9、12、... 3n，而栈是后进先出，当a1=3n时说明最后进栈的元素最先出栈，这样就只有一种出栈序列，为3n、3n-3、... 6、3。\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "上述叙述错误，栈底元素可以删除。当栈中只有一个元素时，栈底元素也是栈顶元素，是可以删除的。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "7", "answer": "当n个全部入栈后再出栈，一定顺序相反，\n但是如果在中间有元素出栈，那顺序可能不是正好相反\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "答：(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费， 各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈 满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移 动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1.n/2.\n2.(2n+1)/3.\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "8", "answer": "顺序表的存储空间是静态分配的，在程序执行之前必须明确规定他的存储规模，顺序表可以随机访问数据元素，但是大小固定，不利于增删结点；链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请，采用指针方式增减节点，非常方便，但是不能随机访问，且每个结点上增加指针域，增大额外存储空间。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "0", "answer": "叙述正确，栈的特点是先进后出，后进先出，只有把栈底上面的元素都拿走才可以出去。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "10", "answer": "该叙述是错误的。\n因为1、栈底元素可以被删除，使该栈成为一个空栈。\n2、栈底元素只是需要最后一个被删除，并不是不能删除。待栈底元素，同时也变成栈顶元素，即可删除。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "6", "answer": "ai = 3i\n队列先进先出，经过一个队列后，序列为3、6、9、12、... 3n\n栈先进后出，经过一个栈后，若a1=3n，序列为3n、3(n-1)、...9、6、3\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "0", "answer": "正确，栈的结构就是后进先出，每次都是pop栈顶元素，所以不能删除\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "8", "answer": "顺序表存储数据实行的是 一次开辟，永久使用，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n因此若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "6", "answer": "队列的数据是先进先出，栈的数据是先进后出，所以出队列时是3先出，3n最后出，进栈是3先进，3n最后进。所以最后输出应该是3n,3n-3,3n-6.....3.\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "a1为3n，则是将其全部压入栈再进行弹出，则栈顶为3n，一个个依次弹出，则是进队序列的倒序，则ai为3n+3-3i\n\n\n", "q_id": "010", "question": "若已知一个队列进队序列为3、6、9、12、... 3n，经过一个队列后立即出队进入一个栈，当出栈时其输出序列为a1、a2、 . an。 若a1=3n, 求ai(1≤i≤n)，给出求解原因。", "reference1": "由于队列是先进先出，所以进队序列和出队序列相同，这样进栈次序亦为3、6、9、12、...、3n.而栈是后进先出，当a1=3n时说明最后进栈元素最先出栈，这样只有一种出栈序列，即为3n、3n-3、...、9、6、3。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "顺序表：\n优点：逻辑和存储相邻，可随机抽取元素，元素之间的关系无需说明。\n缺点：插入，删除要移动大量元素，难以预先分配合理空间，容量难以扩充。\n链表：\n优点：存储元素是分散的，插入删除元素时无需移动元素，效率好\n缺点：需要设置指针表示元素间的逻辑关系，利用了额外的存储空间\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "10", "answer": "(1)优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易产生溢出，分配空间大了，容易造成浪费，各栈不能共享空间。\n(2)优点是多个栈仅用一个顺序存储空间，充分利用了存储空间，只有在整个存储空间都用完时才会产生溢出。缺点是当一个栈满时要向左、右查询有无空闲单元。如果有，则要移动元素和修改相关的栈底和栈项指针。当接近栈满时，要查询空闲单元、移动元素和修改栈底、栈顶指针，这一过程计算复杂且十分耗时。\n(3)优点是多个链栈一般不考虑栈的溢出。缺点是栈中元素要以指针相链接，比顺序存储多占用了存储空间。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "10", "answer": "有n个节点并且高度为n的二叉树的个数有2的n-1次方个\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "1、防止单链表是空的而设的。当链表为空的时候，带头结点的头指针就指向头结点，如果当链表为空的时候，头结点的指针域的数值为NULL。\n2、为了方便单链表的特殊操作，插入在表头或删除第一个结点。这样就保持了单链表操作的统一性。\n3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此，空表和非空表的处理统一，方便了单链表的操作，也减少了程序的复杂性和出现bug的机会。\n4、对单链表的多数操作应明确对哪个结点以及该结点的前驱。不带头结点的链表对首元结点、中间结点的操作相同，从而减少分支，使算法变得简单，流程清晰。\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "例如 8， 7，1，2在第一趟就朝相反的方向\n会有\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
{"score": "10", "answer": "对于单链表而言，仅仅能够查询到指针p所指的后续结点，但是无法查询到这个结点之前的结点。\n对于双链表而言，由于双链表提供双向连接，因此可以根据该节点之前的结点和之后的节点，所以可以删除p。其时间复杂度为O(1)。\n对于循环单链表而言，可以找到他的后继结点并且也可通过查找得到p的前驱节点，所以可以删去p。其时间复杂度为O(n)。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "10", "answer": "2^(n-1)\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "否。因为栈只能在栈顶进行插入和删除，当在栈顶不断进行插入操作时，栈底元素就是第一个被插入的元素；而当在栈顶不断进行删除操作时，栈底元素最后也会变成栈顶元素，被删除。因此栈底元素是能删除的元素。\n\n\n", "q_id": "006", "question": "请判断以下叙述是否正确，并做出解释：栈底元素是不能删除的元素", "reference1": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference2": "错误。栈中元素可以从栈顶的元素先出栈然后一个一个删除，直到最后删除栈底元素。", "reference3": ""}
{"score": "5", "answer": "1、插入到第一个位置需要移动n-1个元素，插入到第二个位置需要移动n-1个元素......插入到最后一个位置需要移动1个元素，故平均需要移动n*(n-1)/2个元素\n\n\n\n\n2、若插入到ai与ai+1之间的概率为(n-i)/(n*(n+1)/2)，则平均移动的概率为(n-1)(n-1)/(n(n+1)/2)+(n-2)(n-2)/(n*(n+1)/2)+......22/(n*(n+1)/2)+11/(n(n+1)/2)=(2*n+1)/3.\n\n\n", "q_id": "014", "question": "设 LS 是一个线性表，LS=(a1,a2,…,an),若采用顺序存储结构，则在等概率的前提下，插入一个元素需要平均移动的元素个数是多少？若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则插入一个元素需要平均移动的元素个数又是多少？", "reference1": "等概率前提下，插入一个元素需要平均移动的元素个数是n/2；若元素插在 ai与 ai+1之间(0<=i<=n-1)的概率为(n-i)/(n*(n+1)/2)，则需要平均移动元素个数（2n+1)/3", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误\n\n\n\n\n1.顺序栈只是数组的下标是有序的，0123......，这并不代表下标所对应的元素值的大小是有规律的\n\n\n\n\n2.顺序栈的存储空间是连续的，但是空间里所存的元素的大小并不确定\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "6", "answer": "单链表不行，因为不知道它的前驱位置；\n双链表和循环单链表可以，时间复杂度均为O(n）。\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "5", "answer": "1、防止单链表是空的而设的。当链表为空的时候,带头结点的头指针就指向头结点.如果当链表为空的时候,头结点的指针域的数值为NULL。\n2、是为了方便单链表的特殊操作，插入在表头或者删除第一个结点.这样就保持了单链表操作的统一性\n\n\n", "q_id": "004", "question": "对单链表设置头结点的作用是什么？（至少说出两条好处）", "reference1": "1.使得单链表中任何节点都有前驱节点，使得处理首节点和其他节点操作一致；方便对链表中任何节点进行一致操作，而不会出现首节点操作更复杂情况。2.统一空表和非空表的处理，方便对空表进行操作。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "单链表不行\n双链表可以 O(1)\n循环链表可以 O（n）\n\n\n", "q_id": "005", "question": "在单链表、双链表和循环单链表中，若仅知道指针p指向某节点，不知道头指针，能否将节点*p从相应的链表中删去？若可以，其时间复杂度各为多少？", "reference1": "单链表不可以。双链表可以，时间复杂度为O(1)。循环链表可以，时间复杂度为O(n)。", "reference2": "1.单链表时无法删除，因为无法找到其前面的节点 2.双链表可以，因为该链表双向连接可以直接找到其前面的节点，时间复杂度为o(1). 3,循环单链表,可以，在循环一圈后可以找到其前面的节点，时间复杂度为o（n）。", "reference3": ""}
{"score": "7", "answer": "错误。\n栈中元素的顺序由入栈出栈顺序决定，与元素值大小无关。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "(1)优点：操作简单。缺点：内存空间分配不方便。\n(2)优点：空间利用率高。缺点：栈满时操作困难，需要大量移动数据。\n(3)优点：不用考虑栈满的问题。缺点：需要额外空间存放指针，空间利用率较低。\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "5", "answer": "一：优点:所列基本运算都可在O(1)的时间里完成，效 率高。\n缺点:为了使每个栈在算法运行过程中不会溢出， 通常要为每个栈预置一个较大的栈空间。另一方面， 由于各个栈的实际大小在算法运行过程中不断变化。 经常会发生其中一个栈满，而另一个栈空的情形， 空间利用率低。\n二：优点：提高空间利用率，减 少栈发生上溢的可能性。共享资源，对空间的利用更加充分 。\n三：优点：入栈和出栈都在链表的表头进行，不会出现上溢的情况。只要系统有存储空间就不会出现栈满的情况\n缺点：要使用指针，并不是很简单\n\n\n", "q_id": "009", "question": "在一个算法中需要建立多个栈时可以选用以下三种方案之一， 试问这三种方案之间相比各有什么优缺点? (1)分别用多个顺序存储空间建立多个独立的顺序栈。 (2)多个栈共享一个顺序存储空间。 (3)分别建立多个独立的链栈。", "reference1": "（1）优点是每个栈仅用一个顺序存储空间时，操作简单。缺点是分配空间小了，容易溢出，分配空间大了，容易造成浪费，各栈不能共享空间。（2）", "reference2": "", "reference3": ""}
{"score": "0", "answer": "1个。\n\n\n", "q_id": "019", "question": "有n个节点并且高度为n的二叉树的个数是多少?", "reference1": "对于具有n个节点且高度为n的二叉树，由于每个分支节点都只有一个子节点，这个子节点可以是左子节点也可以是右子节点。由于分支节点共有n-1个，因此这种树的总数为2^(n-1)种。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "错误。\n顺序栈中的“顺序”指的是栈的存储结构为顺序存储结构，栈中存储的元素值可以是任意的。\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "4", "answer": "顺序表：存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。\n链表：链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。\n\n\n", "q_id": "001", "question": "简述顺序表和链表存储方式的特点", "reference1": "顺序表的存储空间连续，支持随机访问，按下标进行访问时时间复杂度为O（1），但在数据量不确定的情况下容易造成内存浪费或者元素溢出。链表的存储空间不连续，不支持随机访问，对数据进行操作的时候需要从头开始遍历，最坏情况为O（n），但是链表没有空间限制，不会溢出也不会产生内存浪费。", "reference2": "顺序表：①将表中元素逐个放在连续的空间中；②无需为表示元素之间的逻辑关系而增加额外的存储空间；③数组大小确定之后就难以更改，空间分配的灵活性较差。链表：①每个逻辑上相邻的元素在空间上不一定是相邻的；②需要在每个单元中设置指针来表示元素间的逻辑关系，增加了额外的空间开销；③可以实时分配或释放空间，表长可以灵活变化。", "reference3": ""}
{"score": "0", "answer": "正确，栈只能先进后出。\n\n\n", "q_id": "008", "question": "请判断以下叙述是否正确，并做出解释：在n个元素进栈后，它们的出栈顺序和进栈顺序一定正好相反", "reference1": "错误。例如进栈序列为123，出栈序列可以为132。", "reference2": "", "reference3": ""}
{"score": "8", "answer": "错误\n顺序栈的元素值大小不是有序的，是按照进栈顺序逆向排列的\n\n\n", "q_id": "007", "question": "请判断以下叙述是否正确，并做出解释：顺序栈中元素值的大小是有序的", "reference1": "错误。顺序栈是指使用顺序存储结构实现的栈，栈中的元素不一定是有序的。", "reference2": "", "reference3": ""}
{"score": "10", "answer": "比较n次：其中一个有序表中所有元素比另一个有序表中的第一个元素大或小。\n比较2n-1次：两个有序表a[i]>b[i]>a[i+1]>bi+1或者a[i]<b[i]<a[i+1]<bi+1.\n\n\n", "q_id": "013", "question": "将两个长度为n的有序表归并为一个长度为2n的有序表，最小需要比较n次，最多需要比较2n-1次，请说明这两种情况发生时，两个被归并的表有何特征?", "reference1": "1. 当需要最少比较次数时，如果一个表的最后一个元素小于另一个表的第一个元素，则只需将一个表的所有元素与另一个表的第一个元素进行比较即可。 2. 当需要最多比较次数时，两个表的元素正好交替排列，即一个表的第 i 个元素刚好大于另一个表的第 i 个元素，但小于另一个表的第 i+1 个元素。", "reference2": "", "reference3": ""}
{"score": "5", "answer": "存取表中任意位置的元素，返回表中元素的位置。\n\n\n", "q_id": "002", "question": "在什么情况下使用顺序表比链表好？", "reference1": "在很少需要插入、删除表中元素，或只在表尾插入、删除元素，并且需要对表的操作主要为遍历、查找、随机访问指定位置元素，而不需改变表时，使用顺序表比链表好。", "reference2": "", "reference3": ""}
{"score": "9", "answer": "如1,5,4,2,3\n快速排序过程中没有这种现象\n\n\n", "q_id": "015", "question": "（冒泡）排序过程中，有的关键字在某趟排序中可能朝着与最终排序相反的方向移动，试举例说明之。快速排序过程中有没有这种现象？", "reference1": "在冒泡排序过程中，确实可能出现某些关键字在某趟排序中朝着与最终排序相反的方向移动。举个例子：假设我们有一个数组：[ 3, 1, 4, 5, 2 ]。在冒泡排序的第一次遍历（第一趟）时，排序规则是相邻的元素两两比较并交换，如果顺序错误就交换：1. 比较 3 和 1，3 > 1，交换，数组变为：[ 1, 3, 4, 5, 2 ]。2. 比较 3 和 4，3 < 4，不交换。3. 比较 4 和 5，4 < 5，不交换。4. 比较 5 和 2，5 > 2，交换，数组变为：[ 1, 3, 4, 2, 5 ]。我们注意到，第一个关键字 2 在第一趟排序中从右向左移动，但在最终排序中它应该往右移动到第四个位置。这说明关键字 2 在第一趟排序中朝着与最终排序相反的方向移动了。在快速排序过程中，不会出现关键字朝着与最终排序相反的方向移动的现象。快排划分的过程中，元素只会逐步接近它们的最终位置，而不会暂时朝着与最终排序相反的方向移动。因此，快速排序不存在这种现象。", "reference2": "n/2；sum(i=1--n){(n-i)/(n*(n+1)/2)}", "reference3": ""}
